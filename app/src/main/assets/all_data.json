[{
  "name": "java基础",
  "data": [{
    "title": "string在使用时会创建几个对象",
    "content": "String str1 = \"abc\"; // 在常量池中，如果有不需要创建  1个\n\nString str2 = new String(\"abc\"); // 在堆上 str2 常量池中“abc” abc如果有不需要创建   1或2个\n\nString str = \"abc\" + \"def\"; //在编译时已经被合并成“abcdef”字符串，因此，只会创建1个对象。\n\nString str = \"abc\" + new String(\"def\"); //“abc”和“def”，堆中对象new String(\"def\")和“abcdef”。还会创建一个StringBuilder来进行字符串的拼接\u2028  字符串、new、builder"
  }, {
    "title": "抽像类与接口的差别",
    "content": "抽象类是对整个类进行抽象，包括属性和方法，是一种模板设计。我们可以有选择地重写需要用到的方法。而接口是对行为的抽象，实现接口的一定要实现接口里定义的所有方法，里面不能有私有的方法或变量，是用于让别人使用的。还有就是一个具体类只能extends一个抽象类，可以implements多个接口。\n\n还有些就是定义上的区别，比如抽像类可以有构造器，但接口没有，访问修饰符抽像类可以有public protected  default等，但接口默认修饰符是public，不可以用其他修饰符。"
  }, {
    "title": "介绍下String，为什么要设计成不可变的？以及StringBuffer、StringBuilder",
    "content": "String并不是基础类型，是final修饰的java类，之所以被设计成不可变主要是为了保证数据不被污据，方法区中的字符串池，当一个字符串已经被创建并且该字符串在池中，该字符串的引用会立即返回给变量，而不是重新创建一个字符串再将引用返回给变量。如果字符串不是不可变的，那么改变一个引用（如:string2）的字符串将会导致另一个引用（如:string1）出现脏数据。\n\nstring不是基本数据类型，那么一个string的内存位置是什么呢？一共有两种情况：\n　　1、string直接赋值：\n　　　　String s = \"haha\";\n　　　　s的引用存在栈内存中，引用指向的haha存在方法区的常量池中（先判断常量池中是否有一个haha，存在则直接指向）\n　　2、string对象new创建\n　　　　String s = new String(\"haha\");\n　　　　s的引用存在于栈内存中，引用指向的haha对象，存在堆内存中（每new一次，在堆中创建一个新的haha对象）\n\n和String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象\n\nStringBuffer是线程安全的，可以在多线程操作字符串\nStringBuilder是非线程安全的，性能会比StringBuffer好些"
  }, {
    "title": "Java 中的 final, finally 和 finalize?",
    "content": "final：对基本类型而言，你不能改变其数值，对于引用，你不能将其指向一个新的引用，即用final关键字修饰方法，它表示该方法不能被覆盖重写，但是可以被重载，用final修饰的类是无法被继承的\nfinally：是异常处理中进行收场处理的代码块，比如配合lock使用，在finally里面关闭锁。关闭一个数据库连接，清理一些资源占用的问题。不管有没有异常被捕获，finally子句中的代码都会被执行。\nfinalize：finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，定位bug"
  }, {
    "title": " == 和 equals() 有什么区别？",
    "content": "1、对于==，比较的是值是否相等\n\n如果作用于基本数据类型的变量，则直接比较其存储的 值是否相等，\n\n如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等。\n\n\n2、equals()方法不能作用于基本数据类型的变量，在没有重写equals()的类中，调用equals()方法其实和使用==的效果一样，也是比较的是引用类型的变量所指向的对象的地址\n\n不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。"
  }, {
    "title": " hashCode()与equals()",
    "content": "hashCode也是Object类的一个方法。返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。\n\n如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。\n\n如果两个对象不equals，他们的hashcode有可能相等。\n\n如果两个对象hashcode相等，他们不一定equals。\n\n如果两个对象hashcode不相等，他们一定不equals。"
  }, {
    "title": " 重载和重写的区别",
    "content": "重载：方法签名相同，参数列表不同（与返回值无关）\n\n重写：同名同参同返回，前面的权限修饰符不能比父类的更封闭，抛出的异常不能更宽泛。重载：方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。\n\n重写：是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。如果父类的方法有异常声明，那么子类重写这个方法时候，所要声明的异常不应该比父类的大。只能是小等，或者可以没有\n\n可否重写父类的静态方法\n\n静态方法，是在运行时，虚拟机已经认定此方法属于哪个类。 静态方法的调用不需要实例化， \"重写\"只能适用于实例方法.不能用于静态方法.对于静态方法,只能隐藏... "
  }, {
    "title": " java三大特性",
    "content": "1、对于==，比较的是值是否相等\n\n如果作用于基本数据类型的变量，则直接比较其存储的 值是否相等，\n\n如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等。\n\n\n2、equals()方法不能作用于基本数据类型的变量，在没有重写equals()的类中，调用equals()方法其实和使用==的效果一样，也是比较的是引用类型的变量所指向的对象的地址\n\n不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。"
  }, {
    "title": " == 和 equals() 有什么区别？",
    "content": "封装：将类的属性和方法细节隐藏起来，只对外提供访问和修改接口\n\n\n继承：一个类可以使用另一个类的部分属性与方法，比如子类继承父类后，除了private子 类不可见，其他属性与方法都可以使用\n\n\n多态：一种类形具有表现多种形态的能力，多态的作用就是消除类型之间的耦合关系，它的三个必要条件是继承、重写、父类引用指向子类对象。这样可以提高程序的扩展力，是一种面向抽象编程的思想。"
  }, {
    "title": " 介绍下 泛型、反射",
    "content": "泛型：\n在集合中存储对象并在使用前进行类型转换是很不方便的，并且容易出错，为了防止这种情况，泛型产生。泛型提供了编译期的类型安全，确保我们只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException（类型转换异常）\n\n反射：就是动态加载一个指定的类，并获取该类中的所有的内容，比如有些第三方的JAR文件中的资源，我们没法直接调用，就可以用反射这种比较原始的方法来调用。\n\n1、获得Class对象，就是获取到指定的名称的字节码文件对象。\nClass c = Class.forName(className);\n\n2、实例化对象，获得类的属性、方法或构造函数。\n\u2028Field[] fields = c.getDeclaredFields();\u2028\u2028for (int i = 0; i < fields.length; i++) {\n\n// 打印属性的 修饰符 类型 名称\nSystem.out.println(Modifier.toString(fields[i].getModifiers()) + \" \" + fields[i].getGenericType() + \" \"+ fields[i].getName());}\n\n\n\n3、访问属性、调用方法、调用构造函数创建对象。"
  }, {
    "title": "java引用类型",
    "content": "强引用：当我们使用new创建对象时，被创建的对象就是强引用，如Object object = new Object()，其中的object就是一个强引用了。如果一个对象具有强引用，JVM就不会去GC它，JVM宁可会报OOM来终止程序，也不回收该对象。\n\n软引用: 如果一个对象只具备软引用，如果内存空间足够，那么JVM就不会GC它，如果内存空间不足了，就会GC该对象。\n\n弱引用: 如果一个对象只具有弱引用，只要JVM的GC线程检测到了，就会立即回收。弱引用的生命周期要比软引用短很多。不过，如果垃圾回收器是一个优先级很低的线程，也不一定会很快就会释放掉软引用的内存。\n\n虚引用：如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行GC。\n\n\n软引用一般用于图片缓存，场景，图片编辑bitmap，用法类似于SoftReference<String> sr = new SoftReference<String>(new String(\"hello\")); System.out.println(sr.get());\nWeakReference<Car> weakCar = new WeakReference<Car>(car); if(weakCar.get()!=null)，虚引用可以解决一些内存泄漏的问题，如Handler之类的。"
  }, {
    "title": "ReferenceQueue的使用与作用",
    "content": "ReferenceQueue queue = new ReferenceQueue();\n\nSoftReference ref = new SoftReference( aMyObject , queue );\n\n\n当软引用对象被GC之后，虽然这个SoftReference对象指向的对象已不存在,但这个SoftReference对象本身还占用内存，如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法。ReferenceQueue的poll()方法来检查是否有它所关心的非强引用对象被回收。作用就是通知处理"
  }, {
    "title": "什么是注解",
    "content": "注解就是一种类似注释的机制，用来将信息或元数据与程序元素(类、方法、成员变量等)进行关联，为程序加以说明。\n\n原理：注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象 Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用 AnnotationInvocationHandler 的 invoke 方法。该方法会从 memberValues 这个 Map 中索引出对应的值。而 memberValues 的来源是 Java 常量池。\n\n系统内置标准注解：Override、Deprecated、SuppressWarnnings\n\n注释：元数据是指用来描述数据的数据，更通俗一点，就是描述代码间关系，或者代码与其他资源(例如数据库表)之间内在联系的数据。"
  }, {
    "title": "常见的运行时错误",
    "content": "1、NullPointerException - 空指针引用异常\n\n2、ClassCastException - 类型强制转换异常。\n\n3、IndexOutOfBoundsException - 下标越界异常\n\n4、IllegalArgumentException - 传递非法参数异常。\n\n5、ArithmeticException - 算术运算异常\n6、ArrayStoreException - 向数组中存放与声明类型不兼容对象异常\n7、NegativeArraySizeException - 创建一个大小为负数的数组错误异常\n8、NumberFormatException - 数字格式异常\n9、SecurityException - 安全异常\n10、UnsupportedOperationException - 不支持的操作异常"
  }]
}, {
  "name": "四大组件",
  "data": [{
    "title": "四大组件",
    "content": "Activity【活动】：用于表现功能。 \nService【服务】：后台运行服务，不提供界面呈现。 \nBroadcastReceiver【广播接收器】：用来接收广播。 \nContent Provider【内容提供商】：支持在多个应用中存储和读取数据，相当于数据库。\n"
  }, {
    "title": "Activity生命周期及跳转",
    "content": "onCreate:create表示创建\nonStart:start表示启动\nonResume:resume表示继续、重新开始\nonPause:pause表示暂停\nonStop：stop表示停止\nonDestroy：destroy表示销毁\nonRestart：restart表示重新开始\n\n当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume，最后才执行A的onStop!!!\n\n当B按下返回键，B先执行onPause，然后是A再执行onRestart -> onStart -> onResume，最后才是B执行onStop  -> onDestroy\n\n如果B是dialog或透明的，A只会执行onPause，不会执行onStop。当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume。（注意：A的 onStop 不会执行）\n\n当B按下返回键，B先执行onPause，然后是A只会执行 onResume，最后 B 执行onStop  -> onDestroy。\n\n Activity弹出 Dialog 对生命周期\n生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响"
  }, {
    "title": "Activity启动模式",
    "content": "standard 模式:这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。\n\nsingleTop 模式:如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的\n\nsingleTask 模式:如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建\n\nsingleInstance 模式：在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再启动该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。\n\n\nsingleInstance模式加载activity时，无聊从哪个任务栈中启动该activity，只会创建一个activity实例，并且会使用一个全新的任务栈来装载该activity实例\n\n\n1、设置启动模式的位置在 AndroidManifest.xml 文件中 Activity 元素的 Android:launchMode 属性。2、通过intent跳转时，给intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)"
  }, {
    "title": "activity横纵向切换，或页面发生改变时",
    "content": "程序在运行时，一些设备的配置可能会发生改变，如：横竖屏切换、键盘的可用性等这样的事情发生的时候，activity在没有配置android:configChanges属性时会重新启动\n生命周期：onSaveInstanceState-->onPause-->onStop-->onDestroy-->onCreate-->onStart-->onRestoreInstanceState-->onResume\n\n但如果给configChanges配置了orientation|keyboardHidden|screenSize这些属性后，再发生屏幕改变会调用onConfigurationChanged方法，我们可以通过Configuration里的orientation属性判断是横向还是纵向。\n\n onNewIntent 什么时候调用\n 如果此次启动不创建该Activity的新实例,则系统会调用原有实例的onNewIntent()方法来处理此intent"
  }, {
    "title": "fragment生命周期",
    "content": "onAttach() 在Fragment 和 Activity 建立关联是调用（Activity 传递到此方法内）\n\nonCreate()\n\nonCreateView() 当Fragment 创建视图时调用\n\nonActivityCreated() 在相关联的 Activity 的 onCreate() 方法已返回时调用。\n\nonStart() ：Fragment对用户可见的时候调用，前提是Activity已经started。\n\nonResume()：Fragment和用户之前可交互时会调用，前提是Activity已经resumed。\n\nonPause()：Fragment和用户之前不可交互时会调用。\n\nonStop()：Fragment不可见时会调用。\n\nonDestroyView() 当Fragment中的视图被移除时调用\n\nonDestroy()\n\nonDetach() 当Fragment 和 Activity 取消关联时调用。"
  }, {
    "title": "fragment切换时生命周期的变化",
    "content": "1、用replace替换后Fragment都是销毁重新创建的,生命周期全走。加了回退栈的，只是销毁视图onDestroyView() -> 重新创建视图onCreateView()。这种方法会消耗流量和性能\n\n2、add hide show------onHiddenChange()，使用hide() show()方法切换fragment 不会走任何的生命周期 无法通过生命周期进行刷新，需要监听onHiddenChanged方法，来判断fragment显示与否。add 与 remove，会走正常创建与销毁周期。"
  }, {
    "title": "fragment与Activity通信",
    "content": "第一种：setArguments  bundle\n\nactivity:\nMyFragment myFragment = new MyFragment();\nBundle bundle = new Bundle();\nbundle.putString(\"DATA\",values);//这里的values就是我们要传的值\nmyFragment.setArguments(bundle);\n\nFragment:\nBundle bundle = getArguments();\n        if(bundle!=null){\n            titles = bundle.getString(\"title\");\n        }\n\n\n第二种：接口,编写接口，定义方法，在fragment中的attach方法中获取到宿主activity并赋值\nif(activity instanceof FragmentBackListener ) {\n    listener = (FragmentBackListener )activity; // 2.2 获取到宿主activity并赋值\n} \n\n//fragment按钮点击时\nlistener.dosomething()\n\n\n第三种：直接调用，上下文强转\n  @Override\n       public void onAttach(Context context) {\n           super.onAttach(context);\n           titles = ((MainActivity)getActivity()).getTitles();\n\t}\n\n\n第四种：广播和eventbus"
  }, {
    "title": "support包 fragment懒加载方法",
    "content": "1、viewpager+fragment场景时，主要的方法是Fragment中的setUserVisibleHint()，此方法会在onCreateView(）之前执行。使用setUserVisibleHint() 可以返回fragment是否可见状态。  通过在setUserVisibleHint中判断显示与否，再进行异步初始化，初始化后显示正常UI。\nonCreateView—> lazyLoad()异步初始化方法\nsetUserVisibleHint—>if (isVisibleToUser)—>lazyLoad()异步初始化方法\n\n    override fun setUserVisibleHint(isVisibleToUser: Boolean) {\n        super.setUserVisibleHint(isVisibleToUser)\n        this.isVisibleToUser = isVisibleToUser\n        judgeLazyInit()\n    }\n\n2、add+show+hide场景时，我们可以利用onHiddenChanged 来完成懒加载机制,它里面会返回个boolean，相当于onPause、onResume\n\nprivate var isLoaded = false //控制是否执行懒加载\n\noverride fun onHiddenChanged(hidden: Boolean) {\n        super.onHiddenChanged(hidden)\n        isVisibleToUser = !hidden\n        judgeLazyInit()\n    }\n\n\n3、当add+hide+show和viewpager+fragment 嵌套组合时，也可以配合setUserVisibleHint+onHiddenChanged来进行懒加载，但需要设置些变量来管理状态"
  }, {
    "title": "Androidx下 fragment懒加载方法：",
    "content": "1、ViewPager+Fragment，在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有behavior字段的构造函数，当mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT后，只有显示的fragment才会调用onResume我们只需要在onResume中，来进行懒加载就可以了。可以加个标识，防止多次加载。\n\n  public FragmentPagerAdapter(@NonNull FragmentManager fm,\n            @Behavior int behavior) {\n        mFragmentManager = fm;\n        mBehavior = behavior;  //BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT\n    }\n\n2、add+show+hide在add fragment时仅把要显示的fragment通过setMaxLifecycle设置为只有显示的fragment调用resume，其他fragment均设置为STARTED。\n在show、hide切换显示的fragment时仅把show的fragment通过setMaxLifecycle设置为只调用onResume，其他hide的fragment再还原成STARTED\n\nprivate fun showHideFragmentTransaction(fragmentManager: FragmentManager, showFragment: Fragment) {\n    fragmentManager.beginTransaction().apply {\n        show(showFragment)\n        setMaxLifecycle(showFragment, Lifecycle.State.RESUMED)\n\n        //获取其中所有的fragment,其他的fragment进行隐藏\n        val fragments = fragmentManager.fragments\n        for (fragment in fragments) {\n            if (fragment != showFragment) {\n                hide(fragment)\n                setMaxLifecycle(fragment, Lifecycle.State.STARTED)\n            }\n        }\n    }.commit()\n}\n\n3、复杂嵌套\n当fragment嵌套fragment等复杂情况下，只要父fragment回调onresume生命周期函数那被嵌套的所有同级子fragment都会回调onresume，所以我们需要再加上fragment是否隐藏的标识，来判断是否要进行懒加载\n\nViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法,可以通过setOffscreenPageLimit（）传入Int,来控制两侧要加载的数量\n\n解释：懒加载，只有显示时才执行onResume(),viewpager 的适配器构造行数里有个字段，可以控制是否是运行完全周期，还是显示后才只调用onResume"
  }, {
    "title": "Service生命周期",
    "content": "startService方式\nonCreate()：创建  \nonStartCommand()：运行\nonDestroy() ：停止\n\nbindService方式\nonCreate()：创建\nonBind()：运行\nonUnbind()：取消绑定 \nonDestroy() ：停止"
  }, {
    "title": "service两种启动方式",
    "content": "两种启动方式：\n\n通过StartService启动Service：startService(new Intent(this, NormalService.class));\n\n通过bingService启动Service:bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);"
  }, {
    "title": "两种启动的区别",
    "content": "主要是生命周期不同\n\nstartService一旦服务开启跟开启者就没有任何关系\n\n而bindService可以通过unBindService来停掉Service。而且调用者挂了，服务也会跟着挂掉。\n\n"
  }, {
    "title": "如何停止service",
    "content": "终止的话使用stopSelf()或stopService(intent)\n\n混合启动如何停止：同时使用 startService 与 bindService Service 的终止，需要unbindService与stopService同时调用，才能终止 Service。不管 startService 与 bindService 的调用顺序"
  }, {
    "title": "activity与service通信",
    "content": "一、通过Intent，startService（intent）来启动Service，在intent中放入数据，在Service的onStartCommant()中接收通过intent传过来的值。（性能差）\n\n二、binder+回调\n在Activity中实现ServiceConnection，在onServiceConnected()中获取Service的实例，通过这个实例就能调用Service的方法和变量了。通过回调可以将Service主动将变化通知Activity。\n\n三、Broadcase方式\n在Service中需要通知更新UI的地方，发送广播，在Activity中注册广播，在BroadcaseRecever中接受广播，更新UI。\n\n四、EventBus"
  }, {
    "title": "介绍下IntentService",
    "content": "IntentService其本质上是一个Service，因为它是继承至Service，所以开启IntentService和普通的Service一致。\n\n 但是他和普通的Service不同之处在于它可以处理异步任务，在任务处理完之后会自动结束。\n\n另外，我们可以启动多次IntentService，而每一个耗时任务会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且是串行执行。\n\n其实IntentService的内部是通过HandleThread和Handle来实现异步操作的。\n1、新建service类并继承自IntentService\n2、实现service的构造方法\n3、在manifast.xml中注册服务\n4、在服务的onHandleIntent方法中实现业务逻辑\n\nonHandleIntent处理任务以后，会调用stopSelf (在onHandleIntent方法中)，这也就是为什么IntentService完成任务以后，会自动退出。\n\npublic class WorkService extends IntentService {\n    public WorkService() {\n        //必须实现父类的构造方法\n        super(\\\"WorkService\\\");\n    }\n\n    @Override\n    protected void onHandleIntent(@Nullable Intent intent) {\n                .......\n\t\n    }}\n"
  }, {
    "title": "什么是ContentProvider",
    "content": "ContentProvider为存储和获取数据提供了统一的接口，供外部调用\n\n外部应用通过getContentResolver().delete(uri,String,String[])(直接调不用继承和实现ContentResolver)"
  }, {
    "title": "介绍下ContentResolver",
    "content": "是数据调用者，ContentProvider将数据发布出来，通过ContentResolver对象结合Uri进行调用\\n\" + \"\\n\" + \"通过ContentResolver对象可以调用ContentProvider的增删改查"
  }, {
    "title": "创建自定义ContentProvider的步骤",
    "content": "1.使用SQLite技术，创建好数据库和数据表\n\n2.新建类继承ContentProvider\n\n3.重写6个抽象方法 onCreate、delete、insert、query、update、getType\n\n4.创建UriMatcher，定义Uri规则，Uri（通用资源标识符 Universal Resource Identifer），代表数据操作的地址，每一个ContentProvider发布数据时都会有唯一的地址。\n\n5.在Manifest中注册provider\n\n6.ContentResolver对ContentProvider中共享的数据进行增删改查操作"
  }, {
    "title": "有序广播与无序广播的区别",
    "content": "无序广播：通过 sendBoradcast()方法发送的广播，普通广播对于接收器\n来说是无序的，没有优先级，每个接收器都无需等待即可以接收到广播，接收\n器之间相互是没有影响的，这种广播无法被终止，即无法阻止其他接收器的接收动作。\nBroadcastReceiver 无法使用 setResult系列 ， getResult系列 及 abort系列API\n\n有序广播：通过 sendOrderedBroadcast()方法发送的广播，是通过 Context.sendOrderedBroadcast 来发送。所有的receiver依次执行。BroadcastReceiver可以使用setResult系列函数来结果传给下一个BroadcastReceiver，通过getResult系列函数来取得上个BroadcastReceiver返回的结果，并可以abortBroadcast()函数来截断广播，使用该广播不再传送到别的BroadcastReceiver。\n\n如果BroadcastReceiver是代码中注册的话，且其intent-filter 拥有相同 android:priority 属性 的话，先注册的将先收到广播。\n\n有序广播，即从优先级别最高的广播接收器开始接收，接收完了如果没有丢弃，就下传给下一个次高优先级别的广播接收器进行处理，依次类推，直到最后。级别数值是在 -1000 到 1000 之间 , 值越大 , 优先级越高\n\n可以通过在 intent-filter 中设置 android:priority 属性来设置receiver的优先级。优先级相同的receiver其执行顺序不确定。\n\n//静态广播设置优先级示例\n<receiver android:name=\".SmsReceiver\" >\n   <intent-filter android:priority=\"100\">\n    <action android:name=\"android.provider.Telephony.SMS_RECEIVED\" />                    \n   </intent-filter>\n</receiver>\n\n\n//动态设置优先级\n    private void initReceiver1() {\n        MyReceiver myReceiver = new MyReceiver();\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.setPriority(200);\n        intentFilter.addAction(ACTION);\n        registerReceiver(myReceiver, intentFilter);\n    }\n\n\nget、setResult(修改广播中intent数据)与abortBroadcast()中断广播\n\n  private class EndReceiver extends BroadcastReceiver{\n\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            Bundle bundle = getResultExtras(true);\n            String name = bundle.getString(KEY);\n            Log.i(TAG, \"EndReceiver onReceive:\"+name);\n        }\n    }\n\n    public class MyReceiver extends BroadcastReceiver {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            Log.i(TAG, \"MyReceiver onReceive\");\n            Bundle bundle = new Bundle();\n            bundle.putString(KEY,\"优先级高的广播存入数值\");\n            setResultExtras(bundle);\n        }\n    }\n\n    public class MyReceiver2 extends BroadcastReceiver {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            Bundle bundle = getResultExtras(true);\n            String name = bundle.getString(KEY);\n            Log.i(TAG, \"MyReceiver2 onReceive:\"+name);\n        }\n    }\n\nMyReceiver onReceive\nEndReceiver onReceive:优先级高的广播存入数值\nMyReceiver2 onReceive:优先级高的广播存入数值"
  }, {
    "title": "动态注册广播",
    "content": "动态注册：创建Receiver类，重写onReceiver，在代码中再创建一个IntentFilter添加action，通过registerReceiver（Receiver实例，IntentFilter实例）完成注册\n\n//    动态广播接收器\n    class DynamicReceiver extends BroadcastReceiver {\n\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            Toast.makeText(context,intent.getStringExtra(\"dynamicInfo\"), Toast.LENGTH_SHORT).show();\n        }\n    }\n\n\n//设置广播接收器参数并注册\n @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n//        实例化动态广播所需IntertFilter\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(\"dynamic\");\n        dynamicReceiver = new DynamicReceiver();\n//        动态注册广播\n        registerReceiver(dynamicReceiver, intentFilter);\n    }\n\n\n//完成以上两步就可以发送广播了\n    Intent intent = new Intent();\n    intent.setAction(\"dynamic\");\n    intent.putExtra(\"dynamicInfo\", \"动态广播\");\n    sendBroadcast(intent);\n\n"
  }, {
    "title": "静态注册广播",
    "content": "1、清单文件中注册广播接收器，2、代码中定义接收器，重写onReceive方法。3、发送广播\n\n8.0中，静态注册的广播接收者将无法接受 隐式 广播\n\n//注册广播\n<receiver\n    android:name=\".MyReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"false\">\n       <intent-filter>\n           <action android:name=\"test.example.com\" />\n       </intent-filter>\n</receiver>\n\n\n//定义接收器\npublic class MyReceiver extends BroadcastReceiver {\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // TODO: This method is called when the BroadcastReceiver is receiving\n        // an Intent broadcast.\n        Toast.makeText(context,\"收到广播了~\",Toast.LENGTH_LONG).show();\n        //throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n\n//隐式广播:隐式意图不直接指定应该调用的Android组件,只是指定要执行的操作\n//Intent intent=new Intent(\"test.example.com\");  \n\n//显式广播:将使用这些类型的意图,明确知道您要启动哪个组件.\nIntent intent=new Intent(MainActivity.this,MyReceiver.class); \nsendBroadcast(intent);"
  }, {
    "title": "本地广播和全局广播的差别",
    "content": "BroadcastReceiver是针对应用间、应用与系统间、应用内部进行通信的一种方式\n\nLocalBroadcastReceiver仅在自己的应用内发送接收广播，也就是只有自己的应用能收到，数据更加安全广播只在这个程序里，而且效率更高。\n\nBroadcastReceiver 使用\n\n制作intent（可以携带参数）\n使用sendBroadcast()传入intent;\n制作广播接收器类继承BroadcastReceiver重写onReceive方法（或者可以匿名内部类啥的）\n在java中（动态注册）或者直接在Manifest中注册广播接收器（静态注册）使用registerReceiver()传入接收器和intentFilter取消注册可以在OnDestroy()函数中，unregisterReceiver()传入接收器\n\n\nLocalBroadcastReceiver 使用\n\nLocalBroadcastReceiver不能静态注册，只能采用动态注册的方式。在发送和注册的时候采用，LocalBroadcastManager的sendBroadcast方法和registerReceiver方法"
  }, {
    "title": "BaseActivity作用",
    "content": "主要就是作一些样式的统一，仿IOS侧滑finish页面实现、沉浸式状态栏、还有横竖屏切换之类的，然后还可以用一个list来管理Activity，最后退出的时候统一销毁。\n\n0、用途的就是存一个栈，最后退出的时候统一销毁。\n1、屏幕横竖屏切换，AndroidManifest中将不用再写android:screenOrientation=\"portrait\"\n2、ButterKnife绑定页面\n3、沉浸式实现\n4、携带数据的页面跳转\n5、应用被强杀检测\n6、标题栏统一实现\n7、仿IOS侧滑finish页面实现\n8、Loading页面统一实现（可替换成骨架图）\n9、点击Edittext弹出软键盘，点击空白区域让软键盘消失\n10、结合MVP模式下的BaseActivity"
  }]
}, {
  "name": "组件化",
  "data": [{
    "title": "组件化通信原理，打包",
    "content": "组件化使用的是ARouter 核心实现思路是，我们在代码里加入的@Route注解，会在编译时期通过apt生成一些存储path和activityClass映射关系的类文件，然后app进程启动的时候会拿到这些类文件，把保存这些映射关系的数据读到内存里(保存在map里)，然后在进行路由跳转的时候，通过build()方法传入要到达页面的路由地址，ARouter会通过它自己存储的路由表找到路由地址对应的Activity.class(activity.class = map.get(path))，然后new Intent()，当调用ARouter的withString()方法它的内部会调用intent.putExtra(String name, String value)，调用navigation()方法，它的内部会调用startActivity(intent)进行跳转，这样便可以实现两个相互没有依赖的module顺利的启动对方的Activity了。\n\n打包的时候，可以通过gradle中的plugin来切换它是application还是library"
  }, {
    "title": "ARouter拦截器的处理",
    "content": "自定义拦截器需要实现IInterceptor接口，并且添加@Interceptor的注解，其中priority为拦截器的优先级，值越小，优先级越高；然后实现pocess()和init()方法。\n\n @Override\n    public void process(Postcard postcard, InterceptorCallback callback) {\n        Log.e(\"testService\", Test1Interceptor.class.getName() + \" has process.\");\n        //拦截跳转，进行一些处理\n        if (postcard.getPath().equals(\"/test/test1\")) {\n            Log.e(\"testService\", Test1Interceptor.class.getName() + \" 进行了拦截处理！\");\n        }\n        callback.onContinue(postcard);\n    }\n\n\nif (postcard.getExtra() == ConstantMap.LOGIN_EXTRA) {\n    boolean isLogin = postcard.getExtras().getBoolean(ConstantMap.IS_LOGIN);\n    if (!isLogin) {\n        ARouter.getInstance().build(RouterMap.INTER_MIDDLE_ACTIVITY).navigation();\n    } else {\n        postcard.withString(ConstantMap.IS_LOGIN_EXTRA, \"登录了!\");\n        callback.onContinue(postcard);\n    }\n}\n"
  }, {
    "title": "ARouter的使用",
    "content": "path的规则：/group/child…至少两个“/”；和Activity的@Route注解值匹配，Route主要有两个属性，path和group，在RouteProcessor中处理这个注解，在注解处理的方法中会根据注解的类型创建上面使用过的RouteMeta\n\n// 标准路由\nARouter.getInstance().build(\"/home/main\").navigation();\n\n// 标准分组路由\nARouter.getInstance().build(\"/home/main\", \"ap\").navigation();\n\n// Uri跳转\nARouter.getInstance().build(uri).navigation();\n\n// startActivityForResult  在navigation后加入\nARouter.getInstance().build(\"/home/main\", \"ap\").navigation(this, 5);\n\n跳转activity的时候，但凡涉及activity的任务栈，必须使用navigation(context)并且context只能是activity。建议，如果当前可以获取activity，最好传了。\n\n// 使用方式同Activity，navigation()方法会返回要跳到的对象实例，跳转Fragment可以拿到Fragment实例操作。\nFragment fragment = (Fragment) ARouter.getInstance().build(\"/test/fragment\").navigation();\nfragmentList.add(fragment);\n\n\n直接传bundle\t\t.with(bundle)\n\n指定flag\t\t\t.withFlags();\n\n传对象\t\t\t.withObject(\"key\", new Obj(“”))\n\n转场动画\t\t\t.withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)\n\n还提供了int、long、short等基本变量和String、Object、Serializable、Parcelable和对应的数组、List\n"
  }, {
    "title": "组件化跳转流程及关键类",
    "content": "1、获取ARouter实例\n2、构造路由信息的容器postcard\n3、如果需要拦截，就进行拦截器的处理，否则就调用_navigation方法。\n\n所有的Url/Intent跳转信息都使用Postcard邮戳进行信息封装。\n\n\nWarehouse\u2028存储跳转Path所对应的activity/fragment/url/provider，通过APT解析出来的映射关系存储在Warehouse中。\n\nLogisticsCenter\u2028负责解析注解并构造Postcard。以懒加载的方式从Warehouse中获取信息，包括class/url/extras/params等跳转信息。构造Postcard的信息储存对象为HashMap形式的RouteMeta。\n\n_ARouter\u2028负责根据Postcard进行页面跳转。Native采用startActivity形式。\n"
  }, {
    "title": "组件化资源冲突",
    "content": "在app模块引用greet字符串就会出现资源冲突问题。就是给每个子模块给资源名添加前缀，然后在子模块的build.gradle文件的android块内添加resourcePrefix “资源名前缀”。AS会约束我们定义资源。\n\nresourcePrefix \"me_\""
  }]
}, {
  "name": "Handler",
  "data": [{
    "title": "Handler四大组件",
    "content": "Message\nMessage是在线程之间传递的消息，它可以在内部携带信息，用于在不同线程之间交换数据。\n\nHandler\n处理者，它主要用来发送和处理消息。发送消息一般是使用Handler的sendMessage()方法，消息经过处理后，最终传递到Handler的handlerMessage()方法中。\n\nMessageQueue\n消息队列，它主要用来存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理。每个线程只有一个Messgequeue\n\nLooper\n是每个线程中MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，每当发现MessageQueue中存在一条消息，就会将其取出传递到Handler的handleMessage()方法当中。注意：每个线程中只会有一个Looper对象。"
  }, {
    "title": "Handler的使用",
    "content": "Handler异步消息处理流程：\n首先在UI线程我们创建了一个Handler实例对象，重写handleMessage方法，我们可以通过这个方法的参数msg来实现接受消息过后Ui线程的逻辑处理。\n\n在子线程中需要更新UI的时候，可以通过obtain获取一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理。\n\nLooper会不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法\n\n\n先是message的callback，然后是handler的callback，最后再是handleMessage方法来接收 "
  }, {
    "title": "子线程中创建handler",
    "content": "子线程中创建Handler的方法：需要调用Looper.prepare()创建一个looper,并调用looper.loop来启动循环\n\n一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？\n一个Thread只能有一个Looper，一个MessageQueen，可以有多个Handler。\n\n以一个线程为基准，他们的数量级关系是：Thread(1) : Looper(1) : MessageQueue(1) : Handler(N)。"
  }, {
    "title": "为什么Looper.loop不会卡死",
    "content": "looper.loop()是个死循环，但并不是所有的死循环都会卡死进程的，如果我们的程序运行完就结束了，那我们的应用也就没法使了。\n\n所以我们的应用还需要依赖死循环一直执行下去。真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume里的耗时操作\n\n而looper.loop在没有事务要处理的时候，便阻塞在messagequeue中的nativePollOnce()方法里。\n\n这是个本地代码，会通过Linux epoll监听文件描述符的写入事件来实现阻塞，直到有新事务要处理的时候，才会调用nativeWake方法，通过往pipe管道写入数据来唤醒主线程工作。\n\n在这期间，主线程是处于休眠状态的，并不会消耗大量CPU资源，所以looper.loop本身不会导致应用卡死。"
  }, {
    "title": "延迟消息处理",
    "content": "Handler会先在sendMessageAtTime这个方法里去计算消息被处理的时间，也就是当前时间加上延迟时间\n\n然后再把消息在enqueueMessage这个方法当中，按时间msg.when的时间先后顺序插入到消息队列中去\n\nhandler每次插入message都会唤醒线程，通过next()方法，依次拿到队首消息，先判断屏障消息，如果不是的话\n\n再判断当前时间是否小于消息的执行时间，如果小于就是消息还没准备好发送，就会设置一个超时时间，给到nextPollTimeoutMillis，然后通过调用nativePollOnce本地方法进行阻塞\n\n等到时间后，再通过pipe管道写入数据来唤醒线程，判断时间到后，发送消息"
  }, {
    "title": "Handler同步屏障",
    "content": "屏障消息是用来挡住普通消息来保证异步消息优先处理的。在next()方法中，判断下队首消息的的target是否为空，如果为空的话，说明是同步屏障消息，那它就会寻找队列中的下一个异步消息优先处理。\n\nHandler有个构造方法，可以传入async标志为true，这样构造的Handler发送的消息就是异步消息，优先级高于普通消息，优先发送\n\n还可以通过message.setSynchronus();把本条消息设成异步消息。\n\n同步屏障是通过MessageQueue的postSyncBarrier方法插入到消息队列的。\n\n移除屏障可以通过MessageQueue的removeSyncBarrier方法：\n\n屏障消息和普通消息的区别在于屏障没有tartget，普通消息有target是因为它需要将消息分发给对应的handler，而屏障不需要被分发，"
  }]
}, {
  "name": "JVM相关问题",
  "data": [{
    "title": "JVM模型",
    "content": "虚拟机栈\nJava 方法执行的内存模型，每个方法执行的时候，都会创建一个栈帧用于保存局部变量表，操作数栈，动态链接，方法出口信息等。一个方法调用的过程就是一个栈帧从 VM 栈入栈到出栈的过程。VM 栈主要用于存储方法包含的信息如，基本数据类型、局部变量等，VM 栈也是线程私有的\n\n堆区\n所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象都在这分配内存。Java 堆是线程共享的。\n\n方法区\n存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。这部分区域包含「运行时常量池」，所以这个区域主要存储常量。方法区是线程共享的\\n\"\n\n本地方法栈\n执行 Native 方法的栈，与 VM 栈发挥的作用非常相似，VM 栈执行Java 方法（字节码）服务，Native 方法栈执行的是 Native 方法服务。Native 栈也是线程私有的\n\n程序计数器\n一块较小的内存空间，是字节码解释器的行为指示器。程序执行的过程中会有分支、循环、跳转、异常处理、线程恢复等基础功能，也就是程序运行碰到了关键字或特殊行为，字节码解释器就需要进行特殊处理，而字节码需要怎么做正是由程序计数器去通知。程序计数器是线程私有的"
  }, {
    "title": "简述GC机制",
    "content": "Java 中的堆是用于存放实例对象的，堆被划分成年轻代 ( Young )、老年代 ( Tenured)。\n\n年轻代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。配比是8：1：1。大多数刚被创建的对象会存放在伊甸园空间，当空间不足时，会触发MinorGC，MinorGC采用复制算法。首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域，清空Eden和ServicorFrom中的对象，再把ServicorTo和ServicorFrom互换。将在指定次数回收后仍然存在的对象移动到老年代中,MinorGC执行完后，会得到一个空的可用的年经代。\n\n在年轻代经历多次垃圾回收后仍然存活的对象，会被放到老年代，老年代空间不足时会触发Full GC，所采用的是标记-清除算法，或者标记整理算法。\n首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。\n\n老年代触发Full GC的频率要比年轻代低，耗时要长。\n\n之前还有持久代，用于存放静态文件，如今Java类、方法等，JAVA8 开始持久代也已经被彻底删除了。现在取代它的是方法区。"
  }, {
    "title": "GC root 对象",
    "content": "1.虚拟机栈(栈帧中的本地变量表)中引用的对象\n2.方法区中类静态属性引用的对象\n3.方法区中常量引用的对象\n4.本地方法栈中 JNI(一般说的 Native 方法)引用的对象"
  }, {
    "title": "JVM预定义有三种类加载器",
    "content": "1是根类加载器bootstrap classloader，他主要加载JDK/lib目录下的rt、resources等jar包和class等核心类库，他底层是由C++代码来编写的。\n\n2是扩展类加载器，Extention ClassLoader，可以加载ext目录下的jar包和class文件\n\n3是系统类加载器，App ClassLoader，加载当前应用的classpath下的所有类"
  }, {
    "title": "类加载机制、流程",
    "content": "类加载指的是将类的class文件动态的加载到内存中，最终可以被虚拟机直接使用， 这些工作是通过加载器来完成的\n\nJVM采用的是双亲委派加载，也就是有任务会先委派给父加载器，这样从下到上逐层委派，最终会给到根类加载器，如果父类无法加载，子类才会自己尝试加载。双亲委派机制的好处一是可以避免重复加载，二是防止核心API被随意篡改。\n\n整体加载流程也可以叫生命周期有七步：\n1、加载：把class文件加载到内存里，转换成二进制字节流\n2、验证：格式、字节码等验证，保证符合虚拟机要求\n3、准备：在方法区为类变量分配内存设默认值\n4、解析：把虚拟机常量池中的符号引用转换为直接引用也就是内存地址\n5、初始化：为类的静态变量赋初值\n6、使用：\n7、卸载：执行完成\n\n解析这一步是不固定的，有可能会放在初始化之后，为了支持JAVA语言的动态绑定"
  }, {
    "title": "Android类加载机制",
    "content": "在Android中，类加载最上层是ClassLoader这个抽象类，它有两个子类\n\nBootClassLoader：用于加载Android Framework层class文件。\n\n还有个BaseDexClassLoader，也就是我们常用的父类加载器，它有两个子类，\n\n一个是PathClassLoader用于加载程序中已安装的apk的dex，比如我们自己写的类。\n\n还有一个是DexClassLoader，和PathClassLoader比，只是构造方法不同，多了一个optimizedDirectory参数，它可以加载指定目录下(不限于内部)的 dex/jar/apk 文件\n\n因为ClassLoader的双亲委派机制，加载流程最后会到BaseDexClassLoader中的findClass方法中，apk中的dex文件也会被解析保存到父类加载器的dexElements的数组中，然后通过遍历数组加载指定的文件。\n\n可说可不说 ——> 像基于类加载的热修复框架就是用的这个原理来完成类目的替换。"
  }, {
    "title": "标记垃圾的算法",
    "content": "主要是可达性分析算法：通过栈中的引用、方法区中的常量和静态变量这些根节点开始向下搜索，当没有被这个引用链相关联，也就是从GC Roots到这个对象不可达时，则证明对象是不可用的。\n\n了解  --->引用计数算法：对象有一个引用，就增加一个计数，删除一个引用，就减少一个计数。垃圾回收时，只回收计数为0的对象。此算法无法处理循环引用的对象。"
  }, {
    "title": "清除垃圾的算法",
    "content": "1、标记清除法：第一阶段从根节点标记所有引用对象，第二阶段遍历整个堆，对未做标记的对象进行清除。缺点此算法会暂停整个应用，stop the world，而且会产生内存碎片。老年代\n\n2、复制算法：此算法把内存划为两个相等的区域，每次只使用其中一个区域，垃圾回收时，把正在使用的对象复制到另外一个区域，算法可以整理相应的内存，缺点是需要2倍的区域。一般用于年轻代。\n\n3、标记整理：第一阶段从根节点标记所有引用对象，第二阶段清除未标记对象，然后把堆中的存活对象向一端按顺序存放。一般用于老年代\n\n4、分代收集：是一种划分的策略，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法"
  }, {
    "title": "垃圾收集器介绍下",
    "content": "JVM1.5以上支持CMS垃圾收集器，最新JDK9之后默认使用的是G1收集器，\n\nCMS使用的是标记-清除算法，会有内存碎片，适用于老年代，它需要与Serial收集器和Parallel New收集器搭配使用。\n\n而G1采用适用于整个堆区，有两个优点：\n\n第一点：G1会压缩空闲内存使之足够紧凑，是通过用regions代替细粒度的空闲列表进行分配，减少内存碎片的产生。\n\n第二点：G1的STW更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。而CMS只能是尽量减少STW为目的，时间不可控\n\n\nSerial收集器串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩\n\nParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩"
  }]
}]