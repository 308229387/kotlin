[
  {
    "name": "java基础",
    "data": [
      {
        "title": "string在使用时会创建几个对象",
        "content": "String str1 = \"abc\"; // 在常量池中，如果有不需要创建  1个\n\nString str2 = new String(\"abc\"); // 在堆上 str2 常量池中“abc” abc如果有不需要创建   1或2个\n\nString str = \"abc\" + \"def\"; //在编译时已经被合并成“abcdef”字符串，因此，只会创建1个对象。\n\nString str = \"abc\" + new String(\"def\"); //“abc”和“def”，堆中对象new String(\"def\")和“abcdef”。还会创建一个StringBuilder来进行字符串的拼接\u2028  字符串、new、builder"
      },
      {
        "title": "抽像类与接口的差别",
        "content": "抽象类是对整个类进行抽象，包括属性和方法，是一种模板设计。我们可以有选择地重写需要用到的方法。而接口是对行为的抽象，实现接口的一定要实现接口里定义的所有方法，里面不能有私有的方法或变量，是用于让别人使用的。还有就是一个具体类只能extends一个抽象类，可以implements多个接口。\n\n还有些就是定义上的区别，比如抽像类可以有构造器，但接口没有，访问修饰符抽像类可以有public protected  default等，但接口默认修饰符是public，不可以用其他修饰符。"
      },
      {
        "title": "介绍下String，为什么要设计成不可变的？以及StringBuffer、StringBuilder",
        "content": "String并不是基础类型，是final修饰的java类，之所以被设计成不可变主要是为了保证数据不被污据，方法区中的字符串池，当一个字符串已经被创建并且该字符串在池中，该字符串的引用会立即返回给变量，而不是重新创建一个字符串再将引用返回给变量。如果字符串不是不可变的，那么改变一个引用（如:string2）的字符串将会导致另一个引用（如:string1）出现脏数据。\n\nstring不是基本数据类型，那么一个string的内存位置是什么呢？一共有两种情况：\n　　1、string直接赋值：\n　　　　String s = \"haha\";\n　　　　s的引用存在栈内存中，引用指向的haha存在方法区的常量池中（先判断常量池中是否有一个haha，存在则直接指向）\n　　2、string对象new创建\n　　　　String s = new String(\"haha\");\n　　　　s的引用存在于栈内存中，引用指向的haha对象，存在堆内存中（每new一次，在堆中创建一个新的haha对象）\n\n和String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象\n\nStringBuffer是线程安全的，可以在多线程操作字符串\nStringBuilder是非线程安全的，性能会比StringBuffer好些"
      },
      {
        "title": "Java 中的 final, finally 和 finalize?",
        "content": "final：对基本类型而言，你不能改变其数值，对于引用，你不能将其指向一个新的引用，即用final关键字修饰方法，它表示该方法不能被覆盖重写，但是可以被重载，用final修饰的类是无法被继承的\nfinally：是异常处理中进行收场处理的代码块，比如配合lock使用，在finally里面关闭锁。关闭一个数据库连接，清理一些资源占用的问题。不管有没有异常被捕获，finally子句中的代码都会被执行。\nfinalize：finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，定位bug"
      },
      {
        "title": " == 和 equals() 有什么区别？",
        "content": "1、对于==，比较的是值是否相等\n\n如果作用于基本数据类型的变量，则直接比较其存储的 值是否相等，\n\n如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等。\n\n\n2、equals()方法不能作用于基本数据类型的变量，在没有重写equals()的类中，调用equals()方法其实和使用==的效果一样，也是比较的是引用类型的变量所指向的对象的地址\n\n不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。"
      },
      {
        "title": " hashCode()与equals()",
        "content": "hashCode也是Object类的一个方法。返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。\n\n如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。\n\n如果两个对象不equals，他们的hashcode有可能相等。\n\n如果两个对象hashcode相等，他们不一定equals。\n\n如果两个对象hashcode不相等，他们一定不equals。"
      },
      {
        "title": " 重载和重写的区别",
        "content": "重载：方法签名相同，参数列表不同（与返回值无关）\n\n重写：同名同参同返回，前面的权限修饰符不能比父类的更封闭，抛出的异常不能更宽泛。重载：方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。\n\n重写：是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。如果父类的方法有异常声明，那么子类重写这个方法时候，所要声明的异常不应该比父类的大。只能是小等，或者可以没有\n\n可否重写父类的静态方法\n\n静态方法，是在运行时，虚拟机已经认定此方法属于哪个类。 静态方法的调用不需要实例化， \"重写\"只能适用于实例方法.不能用于静态方法.对于静态方法,只能隐藏... "
      },
      {
        "title": " java三大特性",
        "content": "1、对于==，比较的是值是否相等\n\n如果作用于基本数据类型的变量，则直接比较其存储的 值是否相等，\n\n如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等。\n\n\n2、equals()方法不能作用于基本数据类型的变量，在没有重写equals()的类中，调用equals()方法其实和使用==的效果一样，也是比较的是引用类型的变量所指向的对象的地址\n\n不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。"
      },
      {
        "title": " == 和 equals() 有什么区别？",
        "content": "封装：将类的属性和方法细节隐藏起来，只对外提供访问和修改接口\n\n\n继承：一个类可以使用另一个类的部分属性与方法，比如子类继承父类后，除了private子 类不可见，其他属性与方法都可以使用\n\n\n多态：一种类形具有表现多种形态的能力，多态的作用就是消除类型之间的耦合关系，它的三个必要条件是继承、重写、父类引用指向子类对象。这样可以提高程序的扩展力，是一种面向抽象编程的思想。"
      },
      {
        "title": " 介绍下 泛型、反射",
        "content": "泛型：\n在集合中存储对象并在使用前进行类型转换是很不方便的，并且容易出错，为了防止这种情况，泛型产生。泛型提供了编译期的类型安全，确保我们只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException（类型转换异常）\n\n反射：就是动态加载一个指定的类，并获取该类中的所有的内容，比如有些第三方的JAR文件中的资源，我们没法直接调用，就可以用反射这种比较原始的方法来调用。\n\n1、获得Class对象，就是获取到指定的名称的字节码文件对象。\nClass c = Class.forName(className);\n\n2、实例化对象，获得类的属性、方法或构造函数。\n\u2028Field[] fields = c.getDeclaredFields();\u2028\u2028for (int i = 0; i < fields.length; i++) {\n\n// 打印属性的 修饰符 类型 名称\nSystem.out.println(Modifier.toString(fields[i].getModifiers()) + \" \" + fields[i].getGenericType() + \" \"+ fields[i].getName());}\n\n\n\n3、访问属性、调用方法、调用构造函数创建对象。"
      },
      {
        "title": "java引用类型",
        "content": "强引用：当我们使用new创建对象时，被创建的对象就是强引用，如Object object = new Object()，其中的object就是一个强引用了。如果一个对象具有强引用，JVM就不会去GC它，JVM宁可会报OOM来终止程序，也不回收该对象。\n\n软引用: 如果一个对象只具备软引用，如果内存空间足够，那么JVM就不会GC它，如果内存空间不足了，就会GC该对象。\n\n弱引用: 如果一个对象只具有弱引用，只要JVM的GC线程检测到了，就会立即回收。弱引用的生命周期要比软引用短很多。不过，如果垃圾回收器是一个优先级很低的线程，也不一定会很快就会释放掉软引用的内存。\n\n虚引用：如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行GC。\n\n\n软引用一般用于图片缓存，场景，图片编辑bitmap，用法类似于SoftReference<String> sr = new SoftReference<String>(new String(\"hello\")); System.out.println(sr.get());\nWeakReference<Car> weakCar = new WeakReference<Car>(car); if(weakCar.get()!=null)，虚引用可以解决一些内存泄漏的问题，如Handler之类的。"
      },
      {
        "title": "ReferenceQueue的使用与作用",
        "content": "ReferenceQueue queue = new ReferenceQueue();\n\nSoftReference ref = new SoftReference( aMyObject , queue );\n\n\n当软引用对象被GC之后，虽然这个SoftReference对象指向的对象已不存在,但这个SoftReference对象本身还占用内存，如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法。ReferenceQueue的poll()方法来检查是否有它所关心的非强引用对象被回收。作用就是通知处理"
      },
      {
        "title": "什么是注解",
        "content": "注解就是一种类似注释的机制，用来将信息或元数据与程序元素(类、方法、成员变量等)进行关联，为程序加以说明。\n\n原理：注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象 Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用 AnnotationInvocationHandler 的 invoke 方法。该方法会从 memberValues 这个 Map 中索引出对应的值。而 memberValues 的来源是 Java 常量池。\n\n系统内置标准注解：Override、Deprecated、SuppressWarnnings\n\n注释：元数据是指用来描述数据的数据，更通俗一点，就是描述代码间关系，或者代码与其他资源(例如数据库表)之间内在联系的数据。"
      },
      {
        "title": "cas机制",
        "content": "也是乐观锁的一种吧，先取当前值i，然后计算结果值j，再从主内存的值与初始值比较，如果相等，就把结果值赋值。这里还会涉及个ABA的问题，我在取值计算的过程中，有别的线程把内存的值改动了，然后又改回去了，但CAS却无法辨别。"
      },
      {
        "title": "常见的运行时错误",
        "content": "1、NullPointerException - 空指针引用异常\n\n2、ClassCastException - 类型强制转换异常。\n\n3、IndexOutOfBoundsException - 下标越界异常\n\n4、IllegalArgumentException - 传递非法参数异常。\n\n5、ArithmeticException - 算术运算异常\n6、ArrayStoreException - 向数组中存放与声明类型不兼容对象异常\n7、NegativeArraySizeException - 创建一个大小为负数的数组错误异常\n8、NumberFormatException - 数字格式异常\n9、SecurityException - 安全异常\n10、UnsupportedOperationException - 不支持的操作异常"
      }
    ]
  },
  {
    "name": "系统架构",
    "data": [
      {
        "title": "B端项目架构",
        "content": "我们的项目整体来看，还是采用的分层的架构思想，其目的是层次的解耦，提高项目的可维护性、可扩展性。\n\n最底层，也是支持业务流转的最核心数据，包括店铺的本地数据、用户的账密、提醒记录，后期可能还会有数据流的本地存储、持久化的使用\n\n在其上层，主要是业务的流转、指令的派发、还数据解析之类的行为操作\n\n那为他们来做支撑的，是通过组件化形式接入的第方工具库，像 Retrofit + RxJava ，还有Gson、Glide、Eventbus等等\n\n除此之外，还有需要用到的第三方服务，它主要是逻辑行为的延伸，比如支付、性能分析、推送。。。。\n\n最上层的，也就是业务功能了，是通过模块化来进行管理的，比如店铺相关的创建店铺、详情信息、地理位置，还有二手市场相关的电子、物品、用品等等，其他还有房屋租赁、生活服务等等。\n\n最后还有通用模块，会贯穿整个项目线，比如检测登陆、Utils、落地页、setting"
      },
      {
        "title": "生活圈降级方案",
        "content": "这个项目维护了七八年了，业务复杂，经手多次，很多老旧代码，和重复的功能都共存着。\n我们是分了三步，\n\n第一步是项目的瘦身优化、因为这个无关业务逻辑，也效果是立竿见影的。\n像图片压缩、无用资源清除、保留单套图等，先把它大致的体积减下来。我们当时是从160多M减到了70M\n\n第二步是对工具控件的整合，比如统一项目中的请求框架，原来volle、OKhttp这些都有，很多回调导致阅读性很差。我们从简单的页面开始替换，都换成了比较流行的rx+retrofit。这一步稍微麻烦点，花了三四天，基本都替换完成了。还有就是对一些工具类进行管理 ，增加了butterknife，消除样板代码，对弹窗、SP、Toast的统一。这一步完成后，常规的页面就会整洁很多了。但还有一些，比如像列表页，这种逻辑交错的，还是比较臃肿。\n\n第三步，就是对这些页面进行重构，这些页面之前采用的是MVC，但这个Activity角色比较模糊，什么都有，我们是把model层独立了出去，同时添加了本地缓存（file  FileInputStream  FileOutputStream）。还加了懒加载的逻辑，以保证它的流畅性。"
      },
      {
        "title": "Assets目录与res目录的区别",
        "content": "res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即可，assets文件夹下的文件不会被映射到R文件中，访问的时候需要AssetManager类。\n\nres/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹。"
      },
      {
        "title": "android版本特性",
        "content": "6.0增加运行时权限\n\n7.0分屏多任务、夜间模式\n\n8.0画中画android:supportsPictureInPicture=ture，调用接口、指纹手势\nTextView 字体自动适配\n\n9.0“刘海”屏幕支持，可以通过windowInsets.getDisplayCutout()、增加ImageDecoder替换BitmapFactory，代码更优雅\n\n10支持可折叠设备、5G 网络、应用使用黑色主题\n\n11、增加了应用间的可见性，最小化用户权限。更好地支持瀑布屏，即无边框的全面屏\n提供了适用于不同运营商的各种5G图标显示解决方案  可以通过API修改显示"
      },
      {
        "title": "介绍下Android架构",
        "content": "android架构有四层（application程序层、framework程序框架层、libraris程序运行库层、linux核心层），framework处于第二层，也叫应用程序框架层，主要是为应用层的开发者提供API各种服务的。\n该层包括活动管理器、窗口管理器、内容提供者、视图系统、包管理器、电话管理器、资源管理器、位置管理器、通知管理器和 XMPP 服务十个部分。\n\nFramework框架包含了3个主要部分：服务端、客户端、Linux驱动。\n\n像AMS（ActivityManagerService）WMS（WindowManagerService）这些都是常接触到的系统服务（这些系统服务都是以一个线程的方式存在于SystemServer进程中。）\n\n客户端：ActivityThread、Activity、PhoneWindow、WindowManager这些也算是常接触到的客户端类\n\nLinux驱动和Framework相关的主要包含两部分，分别是SurfaceFlingger(SF)和Binder。\n每一个窗口都对应一个Surface, SF驱动的作用是把各个Surface显示在同一屏幕上。Binder驱动的作用是提供跨进程（IPC)的消息传递机制。"
      },
      {
        "title": "简述Android系统的基本架构",
        "content": "Android 系统架构分从下往上为 Linux 内核层、系统运行库层、应用程序框架层 和 应用程序层，各层的功能为：\n\nLinux 内核层负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能；\n\n系统运行库层通过一些 C/C++ 库来为 Android 系统提供主要的特性支持；\n\n应用程序框架层提供构建应用程序时可能用到的各种 API，开发人员主要是使用该层封装好的 API 进行快速开发；\n\n应用程序层提供一些核心应用程序包。"
      },
      {
        "title": "与SDK中的依赖重复",
        "content": "可以使用gradle中的packagingOptions，常见的设置项有4种\n\npackagingOptions {\n        ………\n}\n\n1. exclude，过滤掉某些文件或者目录不添加到APK中，作用于APK，不能过滤aar和jar中的内容。\n\n exclude 'lib/arm64-v8a/libmediaplayer.so'\n\n2. pickFirst，匹配到多个相同文件，只提取第一个，作用于APK，不能过滤aar和jar中的文件。\n\npickFirst \"lib/armeabi-v7a/libaaa.so\"\n\n3. doNotStrip，可以设置某些动态库不被优化压缩。\n\ndoNotStrip \"*/armeabi/*.so\"\n\n4. merge，将匹配的文件都添加到APK中，和pickFirst有些相反，会合并所有文件。\n\nmerge '**/LICENSE.txt'\n\n\n如果是一些JAR包，可以在项目gradle中添加 compile.exclude ，这样默认使用高版本，过滤重复依赖。\n\nconfigurations {  \n    compile.exclude module: 'okhttp'\n    compile.exclude module: 'fastjson'\n    compile.exclude module: 'glide'\n}\n\n\n或是通过将任意一个Module中的jar依赖为compile files(‘your jar name’)，其他需要依赖的地方改为provided files(‘your jar name’)并且删除compile fileTree(include: [‘*.jar’], dir: ‘libs)。\n\ncompile \u2028compile是对所有的build type以及favlors都会参与编译并且打包到最终的apk文件中。\nProvided \u2028Provided是对所有的build type以及favlors只在编译时使用，类似eclipse中的external-libs,只参与编译，不打包到最终apk。\n"
      },
      {
        "title": "修改jar中class",
        "content": "1、通过AAPT对资源文件进行映射，生成R文件\n\n2、对aidl文件进行整合，生成java接口文件\n\n3、再用java compiler 生成 class文件\n\n4、再用dx工具，把class文件转成dex文件\n\n5、通过apkbuilder把dex与resources等合并成APK\n\n6、对包进行签名\n\n7、利用zipalign工具对apk进行字节对齐优化操作\n\n签名原理：\n\n计算摘要\u2028通过Hash算法提取出原始数据的摘要；\n\n计算签名\u2028再通过基于密钥（私钥）的非对称加密算法对提取出的摘要进行加密，加密后的数据就是签名信息；\n\n写入签名\u2028将签名信息写入原始数据的签名区块内。\n"
      },
      {
        "title": "Android打包流程",
        "content": "1、通过AAPT对资源文件进行映射，生成R文件\n\n2、对aidl文件进行整合，生成java接口文件\n\n3、再用java compiler 生成 class文件\n\n4、再用dx工具，把class文件转成dex文件\n\n5、通过apkbuilder把dex与resources等合并成APK\n\n6、对包进行签名\n\n7、利用zipalign工具对apk进行字节对齐优化操作\n\n签名原理：\n\n计算摘要\u2028通过Hash算法提取出原始数据的摘要；\n\n计算签名\u2028再通过基于密钥（私钥）的非对称加密算法对提取出的摘要进行加密，加密后的数据就是签名信息；\n\n写入签名\u2028将签名信息写入原始数据的签名区块内。\n"
      },
      {
        "title": "国际化方案",
        "content": "一、语言\n\n1、一种是安卓系统自己根据手机选择的语言加载values文件夹下相对应strings文件\n通过file选项，创建 recource directory，创建韩国values文件夹并添加strings文件。这样操作后，android系统就会根据手机系统语言进行加载\n\nfile   —  recource directory  —  选择Locale  —  选择语言  —  然后把整理好的各国语言的 strings.xml 放到对应的目录下即可\n\n\n2、一种是通过手动设置实现，重点是设置后不会立即生效，需要关闭当前页面，再次进入才会生效。\n\nResources resources = getResources();\nDisplayMetrics dm = resources.getDisplayMetrics();\nConfiguration config = resources.getConfiguration();\n// 应用用户选择语言\nconfig.locale = Locale.US;\nresources.updateConfiguration(config, dm);\n\n\n二、界面适配\n\n和语言处理相似，也是在相应国家的values下，创建dimens，来做适配，还有color什么的，都一样。\n\nAndroid App国际化的工作并没有太多的技术难度，更多的是一些繁琐的文本处理。"
      }
    ]
  },
  {
    "name": "四大组件",
    "data": [
      {
        "title": "四大组件",
        "content": "Activity【活动】：用于表现功能。 \nService【服务】：后台运行服务，不提供界面呈现。 \nBroadcastReceiver【广播接收器】：用来接收广播。 \nContent Provider【内容提供商】：支持在多个应用中存储和读取数据，相当于数据库。\n"
      },
      {
        "title": "Activity生命周期及跳转",
        "content": "onCreate:create表示创建\nonStart:start表示启动\nonResume:resume表示继续、重新开始\nonPause:pause表示暂停\nonStop：stop表示停止\nonDestroy：destroy表示销毁\nonRestart：restart表示重新开始\n\n当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume，最后才执行A的onStop!!!\n\n当B按下返回键，B先执行onPause，然后是A再执行onRestart -> onStart -> onResume，最后才是B执行onStop  -> onDestroy\n\n如果B是dialog或透明的，A只会执行onPause，不会执行onStop。当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume。（注意：A的 onStop 不会执行）\n\n当B按下返回键，B先执行onPause，然后是A只会执行 onResume，最后 B 执行onStop  -> onDestroy。\n\n Activity弹出 Dialog 对生命周期\n生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响"
      },
      {
        "title": "Activity启动模式",
        "content": "standard 模式:这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。\n\nsingleTop 模式:如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的\n\nsingleTask 模式:如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建\n\nsingleInstance 模式：在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再启动该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。\n\n\nsingleInstance模式加载activity时，无聊从哪个任务栈中启动该activity，只会创建一个activity实例，并且会使用一个全新的任务栈来装载该activity实例\n\n\n1、设置启动模式的位置在 AndroidManifest.xml 文件中 Activity 元素的 Android:launchMode 属性。2、通过intent跳转时，给intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)"
      },
      {
        "title": "activity横纵向切换，或页面发生改变时",
        "content": "程序在运行时，一些设备的配置可能会发生改变，如：横竖屏切换、键盘的可用性等这样的事情发生的时候，activity在没有配置android:configChanges属性时会重新启动\n生命周期：onSaveInstanceState-->onPause-->onStop-->onDestroy-->onCreate-->onStart-->onRestoreInstanceState-->onResume\n\n但如果给configChanges配置了orientation|keyboardHidden|screenSize这些属性后，再发生屏幕改变会调用onConfigurationChanged方法，我们可以通过Configuration里的orientation属性判断是横向还是纵向。\n\n onNewIntent 什么时候调用\n 如果此次启动不创建该Activity的新实例,则系统会调用原有实例的onNewIntent()方法来处理此intent"
      },
      {
        "title": "setContentView过程",
        "content": "待处理"
      },
      {
        "title": "fragment生命周期",
        "content": "onAttach() 在Fragment 和 Activity 建立关联是调用（Activity 传递到此方法内）\n\nonCreate()\n\nonCreateView() 当Fragment 创建视图时调用\n\nonActivityCreated() 在相关联的 Activity 的 onCreate() 方法已返回时调用。\n\nonStart() ：Fragment对用户可见的时候调用，前提是Activity已经started。\n\nonResume()：Fragment和用户之前可交互时会调用，前提是Activity已经resumed。\n\nonPause()：Fragment和用户之前不可交互时会调用。\n\nonStop()：Fragment不可见时会调用。\n\nonDestroyView() 当Fragment中的视图被移除时调用\n\nonDestroy()\n\nonDetach() 当Fragment 和 Activity 取消关联时调用。"
      },
      {
        "title": "fragment切换时生命周期的变化",
        "content": "1、用replace替换后Fragment都是销毁重新创建的,生命周期全走。加了回退栈的，只是销毁视图onDestroyView() -> 重新创建视图onCreateView()。这种方法会消耗流量和性能\n\n2、add hide show------onHiddenChange()，使用hide() show()方法切换fragment 不会走任何的生命周期 无法通过生命周期进行刷新，需要监听onHiddenChanged方法，来判断fragment显示与否。add 与 remove，会走正常创建与销毁周期。"
      },
      {
        "title": "fragment与Activity通信",
        "content": "第一种：setArguments  bundle\n\nactivity:\nMyFragment myFragment = new MyFragment();\nBundle bundle = new Bundle();\nbundle.putString(\"DATA\",values);//这里的values就是我们要传的值\nmyFragment.setArguments(bundle);\n\nFragment:\nBundle bundle = getArguments();\n        if(bundle!=null){\n            titles = bundle.getString(\"title\");\n        }\n\n\n第二种：接口,编写接口，定义方法，在fragment中的attach方法中获取到宿主activity并赋值\nif(activity instanceof FragmentBackListener ) {\n    listener = (FragmentBackListener )activity; // 2.2 获取到宿主activity并赋值\n} \n\n//fragment按钮点击时\nlistener.dosomething()\n\n\n第三种：直接调用，上下文强转\n  @Override\n       public void onAttach(Context context) {\n           super.onAttach(context);\n           titles = ((MainActivity)getActivity()).getTitles();\n\t}\n\n\n第四种：广播和eventbus"
      },
      {
        "title": "support包 fragment懒加载方法",
        "content": "1、viewpager+fragment场景时，主要的方法是Fragment中的setUserVisibleHint()，此方法会在onCreateView(）之前执行。使用setUserVisibleHint() 可以返回fragment是否可见状态。  通过在setUserVisibleHint中判断显示与否，再进行异步初始化，初始化后显示正常UI。\nonCreateView—> lazyLoad()异步初始化方法\nsetUserVisibleHint—>if (isVisibleToUser)—>lazyLoad()异步初始化方法\n\n    override fun setUserVisibleHint(isVisibleToUser: Boolean) {\n        super.setUserVisibleHint(isVisibleToUser)\n        this.isVisibleToUser = isVisibleToUser\n        judgeLazyInit()\n    }\n\n2、add+show+hide场景时，我们可以利用onHiddenChanged 来完成懒加载机制,它里面会返回个boolean，相当于onPause、onResume\n\nprivate var isLoaded = false //控制是否执行懒加载\n\noverride fun onHiddenChanged(hidden: Boolean) {\n        super.onHiddenChanged(hidden)\n        isVisibleToUser = !hidden\n        judgeLazyInit()\n    }\n\n\n3、当add+hide+show和viewpager+fragment 嵌套组合时，也可以配合setUserVisibleHint+onHiddenChanged来进行懒加载，但需要设置些变量来管理状态"
      },
      {
        "title": "Androidx下 fragment懒加载方法：",
        "content": "1、ViewPager+Fragment，在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有behavior字段的构造函数，当mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT后，只有显示的fragment才会调用onResume我们只需要在onResume中，来进行懒加载就可以了。可以加个标识，防止多次加载。\n\n  public FragmentPagerAdapter(@NonNull FragmentManager fm,\n            @Behavior int behavior) {\n        mFragmentManager = fm;\n        mBehavior = behavior;  //BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT\n    }\n\n2、add+show+hide在add fragment时仅把要显示的fragment通过setMaxLifecycle设置为只有显示的fragment调用resume，其他fragment均设置为STARTED。\n在show、hide切换显示的fragment时仅把show的fragment通过setMaxLifecycle设置为只调用onResume，其他hide的fragment再还原成STARTED\n\nprivate fun showHideFragmentTransaction(fragmentManager: FragmentManager, showFragment: Fragment) {\n    fragmentManager.beginTransaction().apply {\n        show(showFragment)\n        setMaxLifecycle(showFragment, Lifecycle.State.RESUMED)\n\n        //获取其中所有的fragment,其他的fragment进行隐藏\n        val fragments = fragmentManager.fragments\n        for (fragment in fragments) {\n            if (fragment != showFragment) {\n                hide(fragment)\n                setMaxLifecycle(fragment, Lifecycle.State.STARTED)\n            }\n        }\n    }.commit()\n}\n\n3、复杂嵌套\n当fragment嵌套fragment等复杂情况下，只要父fragment回调onresume生命周期函数那被嵌套的所有同级子fragment都会回调onresume，所以我们需要再加上fragment是否隐藏的标识，来判断是否要进行懒加载\n\nViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法,可以通过setOffscreenPageLimit（）传入Int,来控制两侧要加载的数量\n\n解释：懒加载，只有显示时才执行onResume(),viewpager 的适配器构造行数里有个字段，可以控制是否是运行完全周期，还是显示后才只调用onResume"
      },
      {
        "title": "Service生命周期",
        "content": "startService方式\nonCreate()：创建  \nonStartCommand()：运行\nonDestroy() ：停止\n\nbindService方式\nonCreate()：创建\nonBind()：运行\nonUnbind()：取消绑定 \nonDestroy() ：停止"
      },
      {
        "title": "service两种启动方式",
        "content": "两种启动方式：\n\n通过StartService启动Service：startService(new Intent(this, NormalService.class));\n\n通过bingService启动Service:bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);"
      },
      {
        "title": "两种启动的区别",
        "content": "主要是生命周期不同\n\nstartService一旦服务开启跟开启者就没有任何关系\n\n而bindService可以通过unBindService来停掉Service。而且调用者挂了，服务也会跟着挂掉。\n\n"
      },
      {
        "title": "如何停止service",
        "content": "终止的话使用stopSelf()或stopService(intent)\n\n混合启动如何停止：同时使用 startService 与 bindService Service 的终止，需要unbindService与stopService同时调用，才能终止 Service。不管 startService 与 bindService 的调用顺序"
      },
      {
        "title": "activity与service通信",
        "content": "一、通过Intent，startService（intent）来启动Service，在intent中放入数据，在Service的onStartCommant()中接收通过intent传过来的值。（性能差）\n\n二、binder+回调\n在Activity中实现ServiceConnection，在onServiceConnected()中获取Service的实例，通过这个实例就能调用Service的方法和变量了。通过回调可以将Service主动将变化通知Activity。\n\n三、Broadcase方式\n在Service中需要通知更新UI的地方，发送广播，在Activity中注册广播，在BroadcaseRecever中接受广播，更新UI。\n\n四、EventBus"
      },
      {
        "title": "介绍下IntentService",
        "content": "IntentService其本质上是一个Service，因为它是继承至Service，所以开启IntentService和普通的Service一致。\n\n 但是他和普通的Service不同之处在于它可以处理异步任务，在任务处理完之后会自动结束。\n\n另外，我们可以启动多次IntentService，而每一个耗时任务会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且是串行执行。\n\n其实IntentService的内部是通过HandleThread和Handle来实现异步操作的。\n1、新建service类并继承自IntentService\n2、实现service的构造方法\n3、在manifast.xml中注册服务\n4、在服务的onHandleIntent方法中实现业务逻辑\n\nonHandleIntent处理任务以后，会调用stopSelf (在onHandleIntent方法中)，这也就是为什么IntentService完成任务以后，会自动退出。\n\npublic class WorkService extends IntentService {\n    public WorkService() {\n        //必须实现父类的构造方法\n        super(\\\"WorkService\\\");\n    }\n\n    @Override\n    protected void onHandleIntent(@Nullable Intent intent) {\n                .......\n\t\n    }}\n"
      },
      {
        "title": "什么是ContentProvider",
        "content": "ContentProvider为存储和获取数据提供了统一的接口，供外部调用\n\n外部应用通过getContentResolver().delete(uri,String,String[])(直接调不用继承和实现ContentResolver)"
      },
      {
        "title": "介绍下ContentResolver",
        "content": "是数据调用者，ContentProvider将数据发布出来，通过ContentResolver对象结合Uri进行调用\\n\" + \"\\n\" + \"通过ContentResolver对象可以调用ContentProvider的增删改查"
      },
      {
        "title": "创建自定义ContentProvider的步骤",
        "content": "1.使用SQLite技术，创建好数据库和数据表\n\n2.新建类继承ContentProvider\n\n3.重写6个抽象方法 onCreate、delete、insert、query、update、getType\n\n4.创建UriMatcher，定义Uri规则，Uri（通用资源标识符 Universal Resource Identifer），代表数据操作的地址，每一个ContentProvider发布数据时都会有唯一的地址。\n\n5.在Manifest中注册provider\n\n6.ContentResolver对ContentProvider中共享的数据进行增删改查操作"
      },
      {
        "title": "有序广播与无序广播的区别",
        "content": "无序广播：通过 sendBoradcast()方法发送的广播，普通广播对于接收器\n来说是无序的，没有优先级，每个接收器都无需等待即可以接收到广播，接收\n器之间相互是没有影响的，这种广播无法被终止，即无法阻止其他接收器的接收动作。\nBroadcastReceiver 无法使用 setResult系列 ， getResult系列 及 abort系列API\n\n有序广播：通过 sendOrderedBroadcast()方法发送的广播，是通过 Context.sendOrderedBroadcast 来发送。所有的receiver依次执行。BroadcastReceiver可以使用setResult系列函数来结果传给下一个BroadcastReceiver，通过getResult系列函数来取得上个BroadcastReceiver返回的结果，并可以abortBroadcast()函数来截断广播，使用该广播不再传送到别的BroadcastReceiver。\n\n如果BroadcastReceiver是代码中注册的话，且其intent-filter 拥有相同 android:priority 属性 的话，先注册的将先收到广播。\n\n有序广播，即从优先级别最高的广播接收器开始接收，接收完了如果没有丢弃，就下传给下一个次高优先级别的广播接收器进行处理，依次类推，直到最后。级别数值是在 -1000 到 1000 之间 , 值越大 , 优先级越高\n\n可以通过在 intent-filter 中设置 android:priority 属性来设置receiver的优先级。优先级相同的receiver其执行顺序不确定。\n\n//静态广播设置优先级示例\n<receiver android:name=\".SmsReceiver\" >\n   <intent-filter android:priority=\"100\">\n    <action android:name=\"android.provider.Telephony.SMS_RECEIVED\" />                    \n   </intent-filter>\n</receiver>\n\n\n//动态设置优先级\n    private void initReceiver1() {\n        MyReceiver myReceiver = new MyReceiver();\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.setPriority(200);\n        intentFilter.addAction(ACTION);\n        registerReceiver(myReceiver, intentFilter);\n    }\n\n\nget、setResult(修改广播中intent数据)与abortBroadcast()中断广播\n\n  private class EndReceiver extends BroadcastReceiver{\n\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            Bundle bundle = getResultExtras(true);\n            String name = bundle.getString(KEY);\n            Log.i(TAG, \"EndReceiver onReceive:\"+name);\n        }\n    }\n\n    public class MyReceiver extends BroadcastReceiver {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            Log.i(TAG, \"MyReceiver onReceive\");\n            Bundle bundle = new Bundle();\n            bundle.putString(KEY,\"优先级高的广播存入数值\");\n            setResultExtras(bundle);\n        }\n    }\n\n    public class MyReceiver2 extends BroadcastReceiver {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            Bundle bundle = getResultExtras(true);\n            String name = bundle.getString(KEY);\n            Log.i(TAG, \"MyReceiver2 onReceive:\"+name);\n        }\n    }\n\nMyReceiver onReceive\nEndReceiver onReceive:优先级高的广播存入数值\nMyReceiver2 onReceive:优先级高的广播存入数值"
      },
      {
        "title": "动态注册广播",
        "content": "动态注册：创建Receiver类，重写onReceiver，在代码中再创建一个IntentFilter添加action，通过registerReceiver（Receiver实例，IntentFilter实例）完成注册\n\n//    动态广播接收器\n    class DynamicReceiver extends BroadcastReceiver {\n\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            Toast.makeText(context,intent.getStringExtra(\"dynamicInfo\"), Toast.LENGTH_SHORT).show();\n        }\n    }\n\n\n//设置广播接收器参数并注册\n @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n//        实例化动态广播所需IntertFilter\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(\"dynamic\");\n        dynamicReceiver = new DynamicReceiver();\n//        动态注册广播\n        registerReceiver(dynamicReceiver, intentFilter);\n    }\n\n\n//完成以上两步就可以发送广播了\n    Intent intent = new Intent();\n    intent.setAction(\"dynamic\");\n    intent.putExtra(\"dynamicInfo\", \"动态广播\");\n    sendBroadcast(intent);\n\n"
      },
      {
        "title": "静态注册广播",
        "content": "1、清单文件中注册广播接收器，2、代码中定义接收器，重写onReceive方法。3、发送广播\n\n8.0中，静态注册的广播接收者将无法接受 隐式 广播\n\n//注册广播\n<receiver\n    android:name=\".MyReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"false\">\n       <intent-filter>\n           <action android:name=\"test.example.com\" />\n       </intent-filter>\n</receiver>\n\n\n//定义接收器\npublic class MyReceiver extends BroadcastReceiver {\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // TODO: This method is called when the BroadcastReceiver is receiving\n        // an Intent broadcast.\n        Toast.makeText(context,\"收到广播了~\",Toast.LENGTH_LONG).show();\n        //throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n\n//隐式广播:隐式意图不直接指定应该调用的Android组件,只是指定要执行的操作\n//Intent intent=new Intent(\"test.example.com\");  \n\n//显式广播:将使用这些类型的意图,明确知道您要启动哪个组件.\nIntent intent=new Intent(MainActivity.this,MyReceiver.class); \nsendBroadcast(intent);"
      },
      {
        "title": "本地广播和全局广播的差别",
        "content": "BroadcastReceiver是针对应用间、应用与系统间、应用内部进行通信的一种方式\n\nLocalBroadcastReceiver仅在自己的应用内发送接收广播，也就是只有自己的应用能收到，数据更加安全广播只在这个程序里，而且效率更高。\n\nBroadcastReceiver 使用\n\n制作intent（可以携带参数）\n使用sendBroadcast()传入intent;\n制作广播接收器类继承BroadcastReceiver重写onReceive方法（或者可以匿名内部类啥的）\n在java中（动态注册）或者直接在Manifest中注册广播接收器（静态注册）使用registerReceiver()传入接收器和intentFilter取消注册可以在OnDestroy()函数中，unregisterReceiver()传入接收器\n\n\nLocalBroadcastReceiver 使用\n\nLocalBroadcastReceiver不能静态注册，只能采用动态注册的方式。在发送和注册的时候采用，LocalBroadcastManager的sendBroadcast方法和registerReceiver方法"
      },
      {
        "title": "BaseActivity作用",
        "content": "主要就是作一些样式的统一，仿IOS侧滑finish页面实现、沉浸式状态栏、还有横竖屏切换之类的，然后还可以用一个list来管理Activity，最后退出的时候统一销毁。\n\n0、用途的就是存一个栈，最后退出的时候统一销毁。\n1、屏幕横竖屏切换，AndroidManifest中将不用再写android:screenOrientation=\"portrait\"\n2、ButterKnife绑定页面\n3、沉浸式实现\n4、携带数据的页面跳转\n5、应用被强杀检测\n6、标题栏统一实现\n7、仿IOS侧滑finish页面实现\n8、Loading页面统一实现（可替换成骨架图）\n9、点击Edittext弹出软键盘，点击空白区域让软键盘消失\n10、结合MVP模式下的BaseActivity"
      }
    ]
  },
  {
    "name": "Handler",
    "data": [
      {
        "title": "Handler四大组件",
        "content": "Message\nMessage是在线程之间传递的消息，它可以在内部携带信息，用于在不同线程之间交换数据。\n\nHandler\n处理者，它主要用来发送和处理消息。发送消息一般是使用Handler的sendMessage()方法，消息经过处理后，最终传递到Handler的handlerMessage()方法中。\n\nMessageQueue\n消息队列，它主要用来存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理。每个线程只有一个Messgequeue\n\nLooper\n是每个线程中MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，每当发现MessageQueue中存在一条消息，就会将其取出传递到Handler的handleMessage()方法当中。注意：每个线程中只会有一个Looper对象。"
      },
      {
        "title": "Handler的使用",
        "content": "Handler异步消息处理流程：\n首先在UI线程我们创建了一个Handler实例对象，重写handleMessage方法，我们可以通过这个方法的参数msg来实现接受消息过后Ui线程的逻辑处理。\n\n在子线程中需要更新UI的时候，可以通过obtain获取一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理。\n\nLooper会不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法\n\n\n先是message的callback，然后是handler的callback，最后再是handleMessage方法来接收 "
      },
      {
        "title": "子线程中创建handler",
        "content": "子线程中创建Handler的方法：需要调用Looper.prepare()创建一个looper,并调用looper.loop来启动循环\n\n一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？\n一个Thread只能有一个Looper，一个MessageQueen，可以有多个Handler。\n\n以一个线程为基准，他们的数量级关系是：Thread(1) : Looper(1) : MessageQueue(1) : Handler(N)。"
      },
      {
        "title": "为什么Looper.loop不会卡死",
        "content": "looper.loop()是个死循环，但并不是所有的死循环都会卡死进程的，如果我们的程序运行完就结束了，那我们的应用也就没法使了。\n\n所以我们的应用还需要依赖死循环一直执行下去。真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume里的耗时操作\n\n而looper.loop在没有事务要处理的时候，便阻塞在messagequeue中的nativePollOnce()方法里。\n\n这是个本地代码，会通过Linux epoll监听文件描述符的写入事件来实现阻塞，直到有新事务要处理的时候，才会调用nativeWake方法，通过往pipe管道写入数据来唤醒主线程工作。\n\n在这期间，主线程是处于休眠状态的，并不会消耗大量CPU资源，所以looper.loop本身不会导致应用卡死。"
      },
      {
        "title": "延迟消息处理",
        "content": "Handler会先在sendMessageAtTime这个方法里去计算消息被处理的时间，也就是当前时间加上延迟时间\n\n然后再把消息在enqueueMessage这个方法当中，按时间msg.when的时间先后顺序插入到消息队列中去\n\nhandler每次插入message都会唤醒线程，通过next()方法，依次拿到队首消息，先判断屏障消息，如果不是的话\n\n再判断当前时间是否小于消息的执行时间，如果小于就是消息还没准备好发送，就会设置一个超时时间，给到nextPollTimeoutMillis，然后通过调用nativePollOnce本地方法进行阻塞\n\n等到时间后，再通过pipe管道写入数据来唤醒线程，判断时间到后，发送消息"
      },
      {
        "title": "message分发的顺序",
        "content": "先是message的callback，然后是handler的callback，最后再是handleMessage方法来接收"
      },
      {
        "title": "Handler同步屏障",
        "content": "屏障消息是用来挡住普通消息来保证异步消息优先处理的。在next()方法中，判断下队首消息的的target是否为空，如果为空的话，说明是同步屏障消息，那它就会寻找队列中的下一个异步消息优先处理。\n\nHandler有个构造方法，可以传入async标志为true，这样构造的Handler发送的消息就是异步消息，优先级高于普通消息，优先发送\n\n还可以通过message.setSynchronus();把本条消息设成异步消息。\n\n同步屏障是通过MessageQueue的postSyncBarrier方法插入到消息队列的。\n\n移除屏障可以通过MessageQueue的removeSyncBarrier方法：\n\n屏障消息和普通消息的区别在于屏障没有tartget，普通消息有target是因为它需要将消息分发给对应的handler，而屏障不需要被分发，"
      }
    ]
  },
  {
    "name": "JVM相关问题",
    "data": [
      {
        "title": "JVM模型",
        "content": "虚拟机栈\nJava 方法执行的内存模型，每个方法执行的时候，都会创建一个栈帧用于保存局部变量表，操作数栈，动态链接，方法出口信息等。一个方法调用的过程就是一个栈帧从 VM 栈入栈到出栈的过程。VM 栈主要用于存储方法包含的信息如，基本数据类型、局部变量等，VM 栈也是线程私有的\n\n堆区\n所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象都在这分配内存。Java 堆是线程共享的。\n\n方法区\n存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。这部分区域包含「运行时常量池」，所以这个区域主要存储常量。方法区是线程共享的\\n\"\n\n本地方法栈\n执行 Native 方法的栈，与 VM 栈发挥的作用非常相似，VM 栈执行Java 方法（字节码）服务，Native 方法栈执行的是 Native 方法服务。Native 栈也是线程私有的\n\n程序计数器\n一块较小的内存空间，是字节码解释器的行为指示器。程序执行的过程中会有分支、循环、跳转、异常处理、线程恢复等基础功能，也就是程序运行碰到了关键字或特殊行为，字节码解释器就需要进行特殊处理，而字节码需要怎么做正是由程序计数器去通知。程序计数器是线程私有的"
      },
      {
        "title": "简述GC机制",
        "content": "Java 中的堆是用于存放实例对象的，堆被划分成年轻代 ( Young )、老年代 ( Tenured)。\n\n年轻代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。配比是8：1：1。大多数刚被创建的对象会存放在伊甸园空间，当空间不足时，会触发MinorGC，MinorGC采用复制算法。首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域，清空Eden和ServicorFrom中的对象，再把ServicorTo和ServicorFrom互换。将在指定次数回收后仍然存在的对象移动到老年代中,MinorGC执行完后，会得到一个空的可用的年经代。\n\n在年轻代经历多次垃圾回收后仍然存活的对象，会被放到老年代，老年代空间不足时会触发Full GC，所采用的是标记-清除算法，或者标记整理算法。\n首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。\n\n老年代触发Full GC的频率要比年轻代低，耗时要长。\n\n之前还有持久代，用于存放静态文件，如今Java类、方法等，JAVA8 开始持久代也已经被彻底删除了。现在取代它的是方法区。"
      },
      {
        "title": "GC root 对象",
        "content": "1.虚拟机栈(栈帧中的本地变量表)中引用的对象\n2.方法区中类静态属性引用的对象\n3.方法区中常量引用的对象\n4.本地方法栈中 JNI(一般说的 Native 方法)引用的对象"
      },
      {
        "title": "JVM预定义有三种类加载器",
        "content": "1是根类加载器bootstrap classloader，他主要加载JDK/lib目录下的rt、resources等jar包和class等核心类库，他底层是由C++代码来编写的。\n\n2是扩展类加载器，Extention ClassLoader，可以加载ext目录下的jar包和class文件\n\n3是系统类加载器，App ClassLoader，加载当前应用的classpath下的所有类"
      },
      {
        "title": "类加载机制、流程",
        "content": "类加载指的是将类的class文件动态的加载到内存中，最终可以被虚拟机直接使用， 这些工作是通过加载器来完成的\n\nJVM采用的是双亲委派加载，也就是有任务会先委派给父加载器，这样从下到上逐层委派，最终会给到根类加载器，如果父类无法加载，子类才会自己尝试加载。双亲委派机制的好处一是可以避免重复加载，二是防止核心API被随意篡改。\n\n整体加载流程也可以叫生命周期有七步：\n1、加载：把class文件加载到内存里，转换成二进制字节流\n2、验证：格式、字节码等验证，保证符合虚拟机要求\n3、准备：在方法区为类变量分配内存设默认值\n4、解析：把虚拟机常量池中的符号引用转换为直接引用也就是内存地址\n5、初始化：为类的静态变量赋初值\n6、使用：\n7、卸载：执行完成\n\n解析这一步是不固定的，有可能会放在初始化之后，为了支持JAVA语言的动态绑定"
      },
      {
        "title": "Android类加载机制",
        "content": "在Android中，类加载最上层是ClassLoader这个抽象类，它有两个子类\n\nBootClassLoader：用于加载Android Framework层class文件。\n\n还有个BaseDexClassLoader，也就是我们常用的父类加载器，它有两个子类，\n\n一个是PathClassLoader用于加载程序中已安装的apk的dex，比如我们自己写的类。\n\n还有一个是DexClassLoader，和PathClassLoader比，只是构造方法不同，多了一个optimizedDirectory参数，它可以加载指定目录下(不限于内部)的 dex/jar/apk 文件\n\n因为ClassLoader的双亲委派机制，加载流程最后会到BaseDexClassLoader中的findClass方法中，apk中的dex文件也会被解析保存到父类加载器的dexElements的数组中，然后通过遍历数组加载指定的文件。\n\n可说可不说 ——> 像基于类加载的热修复框架就是用的这个原理来完成类目的替换。"
      },
      {
        "title": "标记垃圾的算法",
        "content": "主要是可达性分析算法：通过栈中的引用、方法区中的常量和静态变量这些根节点开始向下搜索，当没有被这个引用链相关联，也就是从GC Roots到这个对象不可达时，则证明对象是不可用的。\n\n了解  --->引用计数算法：对象有一个引用，就增加一个计数，删除一个引用，就减少一个计数。垃圾回收时，只回收计数为0的对象。此算法无法处理循环引用的对象。"
      },
      {
        "title": "清除垃圾的算法",
        "content": "1、标记清除法：第一阶段从根节点标记所有引用对象，第二阶段遍历整个堆，对未做标记的对象进行清除。缺点此算法会暂停整个应用，stop the world，而且会产生内存碎片。老年代\n\n2、复制算法：此算法把内存划为两个相等的区域，每次只使用其中一个区域，垃圾回收时，把正在使用的对象复制到另外一个区域，算法可以整理相应的内存，缺点是需要2倍的区域。一般用于年轻代。\n\n3、标记整理：第一阶段从根节点标记所有引用对象，第二阶段清除未标记对象，然后把堆中的存活对象向一端按顺序存放。一般用于老年代\n\n4、分代收集：是一种划分的策略，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法"
      },
      {
        "title": "垃圾收集器介绍下",
        "content": "JVM1.5以上支持CMS垃圾收集器，最新JDK9之后默认使用的是G1收集器，\n\nCMS使用的是标记-清除算法，会有内存碎片，适用于老年代，它需要与Serial收集器和Parallel New收集器搭配使用。\n\n而G1采用适用于整个堆区，有两个优点：\n\n第一点：G1会压缩空闲内存使之足够紧凑，是通过用regions代替细粒度的空闲列表进行分配，减少内存碎片的产生。\n\n第二点：G1的STW更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。而CMS只能是尽量减少STW为目的，时间不可控\n\n\nSerial收集器串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩\n\nParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩"
      },
      {
        "title": "直接内存",
        "content": "直接内存是在java堆外的，直接向系统申请内存区间，通过DriectByteBuffer操作native内存。\n\n读写文件，需要和磁盘交互，需要由用户态切换到内核态，\n\n直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认是和堆的最大值-Xmx参数一致。"
      }
    ]
  },
  {
    "name": "进程",
    "data": [
      {
        "title": "应用内多进程的目的、优点",
        "content": "1、让一个组件运行在单独的进程中，可以减少主进程所占用的内存，降低被系统杀死的概率。\n\n2、如果子进程因为某种原因崩溃了，不会直接导致主程序的崩溃，可以降低我们程序的崩溃率。\n\n3、即使主进程退出了，我们的子进程仍然可以继续工作"
      },
      {
        "title": "应用内多进程的方法",
        "content": "实现：只需要添加 android:process 的属性即可，属性名可以自定义，相同的属性名的进程在同一个里面运行。\n\n1 . 如果android:process的值以冒号开头，“:”的含义是要在当前进程名前面加上包名，那么该进程就是私有进程，其他应用的组件不可以和它跑在同一个进程中。\n\n2 . android:process=“xxx.xxx.xxxx.xxx” 完整的命名方式，或点开头的，属于全局进程，其它应用通过ShareUID方式可以和它跑在同一个进程中。\n\nShareUserId的作用，数据共享、调用其他程序资源。在manifest里可以配置android:sharedUserId=\"com.mythou.share\""
      },
      {
        "title": "多进程的通信",
        "content": "名称 优点 缺点 使用场景   \n\nBundle 简单易用 只能传输Bundle支持的数据类型 四大组件的进程间通信\n\nAIDL 功能强大，支持一对多的并发通信，支持实时通信 使用较复杂，需要处理好线程同步 一对多通信且有RPC需求\n\nMessenger 功能一般，支持一对多的穿行通信，支持实时通信 不能很好处理并发现象，不支持RPC，只能传输Bundle支持的数据类型 低并发的一对多即时通信，无RPC需求\n\nContentProvider 数据访问方面功能强大，支持一对多并发数据共享 受约束的AIDL，主要提供数据源的CRDU操作 一对多的进程间的数据共享\n\n文件共享 简单易用 不适合高并发场景，无法做到进程间的及时通信 没有并发的情形，交换简单的数据\n\nSocket 功能强大，可通过网络传输字节流，支持一对多的并发实时通信 繁琐，不支持直接的RPC 网络数据交换\n\n\nRPC：Remote Procedure Call (远程过程调用) \nIPC：Inter-Process Communication (进程间通信)\nAIDL：Android Interface Definition Languag(Android接口定义语言)   "
      },
      {
        "title": "应用内多进程的问题",
        "content": "问题1：Application的多次重建，会初始化两回\n解决：判断是否为主进程，只有主进程的时候才执行下面的操作\nString processName = this.getProcessName();\nprocessName.equals(this.getPackageName())\n\n问题2：静态成员和单例失效，设置了process属性后，产生了两个隔离的内存空间，一个内存空间里值的修改并不会影响到另外一个内存空间。所以就算是静态成员也是两个不同的成员值。\n\n问题3：文件共享问题，多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等，即便上锁，排队等机制，对多进程也较难实现\n解决：解决方法就是统一由主进程来处理，子进程通知主进程来操作。\n\n问题4：调试断点，调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试。\n解决：临时去掉process标签，统一在一个进程里调试，结束后再还原标签"
      },
      {
        "title": "介绍下Binder机制",
        "content": "因为Linux 内核与用户空间是隔离的，所以为了支持用户程序之间通讯，Android系统通过添加一个内核模块运行在内核空间，也就是LKM，用户程序就可以通过这个模块来作为桥梁，完成通信。\n\nBinder 通信采用 C/S 架构，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务\n\n首先需要服务端向 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表中插入服务端的信息，并缓存到 ServiceManager 中去，这样就有了服务端。\n\n有了服务端，客户端就可以通过 ServiceManager 拿到服务端的信息，并通过Binder驱动与服务端进程通信；"
      },
      {
        "title": "进程和线程的区别",
        "content": "首先是定义：进程是执行中的一段程序，一个应用至少有一个进程，而线程是用来执行任务的。他们之间是包含关系，一个进程中能有一个或多个线程。\n\n二是进程可以拥有系统分配的资源，但线程只涉及运行栈和程序计数器。\n\n还有就是开销上，线程要比进程小很多，主要就是这三点。\n\n（每当有线程被创建的时候，JVM就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。）\n"
      },
      {
        "title": "aidl",
        "content": "AIDL是进程间通讯的一种方式，一般会与Service、Binder共同完成交互通信。\n\n首先服务端需要先创建AIDL接口文件，定义自己所需要的方法，配置好后build项目，生成aidl JAVA文件，里面会自动生成一个静态的抽像类Stub，继承了Binder，而且还实现了自己所定制aidl接口\n\n然后客户端需要先配置一个与服务端相同的aidl-java文件，并与服务端通过BindService的方式启动一个远程服务，服务端在onBind方法中，传给客户端一个stub代理对象，客户端在ServiceCnection的回调中得到了这个stub代理对象，就可以通过stub里定义好的接口进行通信了。\n\n客户端向服务端：直接用ServiceCnected里返回的bind调用就可以了。\n服务端向客户端：通过接口回调，在客户端ServiceCnected里注册个callback，然后进行通信。"
      },
      {
        "title": "Aidl支持的数据类型及大小",
        "content": "Aidl传输大小取决于Binder内存大小是不到1M的 \n1*1024*1024 - 4096*2\n\nJava基本类型\nString\nList，Map内的元素必须是AIDL支持\nCharSequence 字符序列 character strings\nList,  List接收方必须是ArrayList\nMap Map接收方必须是HashMap\n其他AIDL定义的AIDL接口 传递的是引用\n实现Parcelable的类"
      },
      {
        "title": "aidl的注意事件",
        "content": "客户端调用远程请求时客户端当前的线程会被挂起，直到服务端进程返回数据，所以不能在UI线程中发起远程请求，需要我们开启一个子线程然后再去进行远程调用。\n\n客户端的onServiceConnected和onServiceDisconnected方法都运行在UI线程中，不可以在里面直接调用服务端的耗时方法\n\n服务端的Binder方法运行在Binder线程池中，所以Binder方法不管是否耗时都应该采用同步的方式去实现\n\n同上面一点，服务端的Binder方法需要处理线程同步的问题，上面的例子中CopyOnWriteArrayList支持并发读写，自动处理了线程同步\n\nAIDL中能够使用的List只有ArrayList，但AIDL支持的是抽象的List。因此虽然服务端返回的是CopyOnWriteArrayList，但是在Binder中会按照List的规范去访问数据并最终形成一个新的ArrayList传递给客户端"
      }
    ]
  },
  {
    "name": "线程",
    "data": [
      {
        "title": "为什么非 UI 线程不能更新 UI",
        "content": "因为一旦多线程抢着更新UI，那么界面将会乱套更新了，所以在Android中规定必须在主线程更新UI。\n\n他的原理是在根视图ViewRootImpl源码中的requestLayout方法中有个checkThread()方法，他在那做了个检测，如果非UI线程调用会报错。（ViewRootImpl对象是在onResume方法回调之后才创建）\n\nSurfaceView是一个特例。\nSurfaceView是存在于独立UI线程的，它拥有surface(表面)的canvas，在绘制时，可以通过加锁和解锁来绘制，所以当界面如果更新操作时间较长，而且数据量较大的话，一般采用SurfaceView方式更新屏幕，而少用View"
      },
      {
        "title": "线程有几种状态",
        "content": "在 Thread 类里有一个枚举类型 State，定义了线程的几种状态，分别有：\n\nNew: new 一个实例出来，线程就进入了初始状态。\n\nRunnable: 就绪状态，像调用start() 、sleep（）结束、他线程 join() 结束都会进入runnable。线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态\n\nBlocked： 没有获取到锁被阻塞的状态\n\nWAITING： 处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n\nTIMED_WAITING： 处于这种状态的线程不会被分配 CPU 执行时间，在达到一定时间后它们会自动唤醒。\n\nTERMINATED： 当线程的 run() 方法完成时，或者主线程的 main() 方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。"
      },
      {
        "title": "如何让线程按顺序执行",
        "content": "可以用线程类的join()方法，join()方法的作用，是等待这个线程结束；在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕.\n\nnewSingleThreadExecutor()方法创建的线程池是一个基于FIFO先进先出的队列，也就是说，当我们依次将thread1，thread2，thread3加入队列中时，实际在就绪状态的只有thread1这个线程，thread2，thread3则会被添加到队列中等待，当thread1执行完毕后，则会按进入队列的先后顺序执行队列中的其他线程。"
      },
      {
        "title": "postInvalidate和Invalidate的区别",
        "content": "一般来说，如果View确定自身不再适合当前区域，比如说它的LayoutParams发生了改变，需要父布局对其进行重新测量、布局、绘制这三个流程，往往使用requestLayout。而invalidate则是刷新当前View，使当前View进行重绘，不会进行测量、布局流程，因此如果View只需要重绘而不需要测量，布局的时候，使用invalidate方法往往比requestLayout方法更高效\n\npostInvalidate\n这个方法与invalidate方法的作用是一样的，都是使View树重绘，但两者的使用条件不同，postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。"
      },
      {
        "title": "HandlerThread",
        "content": "HandlerThread继承自Thread，因此HandlerThread其实就是一个线程。他和优点就是，HandlerThread的run方法里就调用了Looper.preper()，和looper.loop()方法，为我们创建好了消息Looper.可以直接拿来用。使用场景就是，在子线程中执行耗时的、可能有多个任务的操作。比如说多个网络请求操作，或者多文件 I/O 等等。使用 HandlerThread 的典型例子就是 IntentService\n\n\nHandlerThread handlerThread = new HandlerThread(\"handlerThread\");\nhandlerThread.start(); \n\n创建Handler\nHandler mCheckMsgHandler = new Handler(mHandlerThread.getLooper()){\n     @Override\n     public void handleMessage(Message msg){\n         // 进行耗时操作\n     }\n};"
      },
      {
        "title": "线程创建方式",
        "content": "创建线程主要有种方式，最后都是start();\n\n一、继承Thread类，覆写run方法。\n\nclass ThreadA extends Thread{\n        @Override\n        public void run() {\n           …..\n        }}}\n\nThreadA t = new Thread;  \nt.start();  \n\n\n二、实现Runnable接口，重写run方法\n\nclass runnable implements Runnable {\n         @Override\n         public void run() {\n  …..\n         }}\n\nMyRunnable runnable = new MyRunnable();\nnew Thread(runnable).start();\n\n\n\n3、还有一种是实现 Callable 接口， Callable接口是Runnable接口的增强版本，需要利用TaskFutrue来创建有返回线程\nclass CallableThread implements Callable<String> {\u2028 @Override\u2028 public String call() throws Exception {\u2028  ….\u2028 }}\n\nCallableThread ct1 = new CallableThread();\nFutureTask<String> task1 = new FutureTask<String>(ct1);\nThread thread1 = new Thread(task1);  //创建第一个线程\u2028thread1.start(); //启动第一个线程\u2028System.out.println(\"task1 get value: \"+task1.get())\u2028"
      },
      {
        "title": "终止线程",
        "content": "1、使用boolean标志位终止线程，让线程自己完成运行，要用volatile声明。\npublic class MyThread extends Thread {\n    public volatile boolean exit = false; \n        public void run() { \n        while (!exit){\n            //do something\n        }\n    } \n\n\n2、使用Interrupte方法标记停止，然后while循环和isInterrupted判断是否被中断，并添加中断逻辑。\n\n static class MyThread extends Thread {\n        @Override\n        public void run() {\n            while (!isInterrupted()){ //非阻塞过程中通过判断中断标志来退出\n                try{\n                    Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出\n                }catch(InterruptedException e){\n                    e.printStackTrace();\n                    System.out.println(\"ThreadSafe:run()\"+e.getMessage());\n                    break;//捕获到异常之后，执行break跳出循环。\n                }\n            }\n        }\n    }\n\n public static void main(String[] args) throws Exception {\n        Thread thread = new ThreadSafe();\n        thread.start();\n        thread.interrupt();\n\n        System.out.println(\"线程已经退出!thread.is\" + thread.isAlive());\n    }\n\n\n3、是已经过时的stop方法。不推荐STOP的原因：线程被杀掉，马上被别的线程上锁，数据写还一半就被别的线程上锁，连清理的机会都没有，拿到异常数据，一定会出问题。\""
      },
      {
        "title": "interrupt(),interrupted() 和 isinterrupted() 的区别",
        "content": "interrupt方法主要作用是将线程的中断状态设置为true，如果遇到被阻塞的线程会抛出InterruptedException异常（同时中断状态为false）。\n\ninterrupted()用来清除当前线程的中断状态，还会返回当前线程的状态，如果线程已中断，则返回true，否则返回false。而且会清除当前Thread的中断状态，置为false。\n\nisInterrupted是用来获取调用线程的中断状态的，但不会重置中断状态\n\n一般interrupt会和isInterrupted，配合while循环、try、catch一起来使用\n"
      },
      {
        "title": "线程的切换",
        "content": "切换方法：join()、yeild()、wait()notify、reentraintLock和condition的await()、singin()\n\nsleep()使当前线程进入停滞状态(阻塞当前线程)，让出CUP的使用，不释放锁\n\nwait() 方法 暂停线程，释放 cpu 控制权，同时释放对象锁的控制\n\nyield() 只是给相同优先级的线程让出 cpu 资源，如果没有相同优先级的线程，那么它还是会得到执行\n\njoin()可以放参数，表示等多久，也可以线程来调，谁调谁先执行   下面代码表示  thread1先执行     join (0) 等价于 join ()无限等待\n    private val thread1 = Thread{\n        Thread.sleep(1000)\n        println(join1)\n    }\n    private val thread2 =Thread{\n        thread1.join()\n        println(join2)\n    }\n\ncondition Condition与Lock配合完成等待通知机制\n\n        public static ReentrantLock lock = new ReentrantLock();\n        public static Condition condition = lock.newCondition();\n\n        lock.lock();//事前加lock，保证线程同步，相当于Synchronized作用\n        conditionA.await();//进入等待，需要被通知才能继续运行下面代码，绑定conditionA对象\n        conditionA.signalAll();//选择性地通知唤醒所有绑定conditionA的对象"
      },
      {
        "title": "线程安全",
        "content": "主要是保证线程中途不被其他线程干扰，可以通过synchronized或使用lock来保证线程同步\n\n还可以使用ThreadLocal来维护变量\n\n还可以保证内存可见性，可以使用volatile修饰变量\n\n比较特殊的情况还可以使用Atomic原子操作类，比如1000个线程同时对变量做+1操作。用原子操作类他的结果就始终是1000，因为可以保证原子性。\n\nfor (int i = 0; i < 1000; i++) {\n      atomicInteger.incrementAndGet()\n}\n"
      },
      {
        "title": "ThreadLocal原理",
        "content": "ThreadLocal可以存数据其实是依赖ThreadLocalMap来实现的，它是个静态的内部类，每个线程都维护了一个ThreadLocal.ThreadLocalMap类型的对象，它其中有一个table数组，元素是Entry。\n\n我们通过threadLocal.set(value) 来存值，其实就是把ThreadLocal当成key，我们set的值作为value，将这个键值对封装成Entry对象，存放ThreadLocalMap中的table数组中去，下标是通过threadLocal的hashkey算出来的。\n\nget方法也是委托给了ThreadLocalMap，从它的数组中取出对应的Entry对象，来获取最终的值。\n\n\n每个线程下的ThreadLocalMap\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\n\n把entry放入table数组\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    table = new Entry[INITIAL_CAPACITY];\n    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n    table[i] = new Entry(firstKey, firstValue);\n}\n\n\n使用示例代码：\nprivate ThreadLocal<String> mThreadLocal = new ThreadLocal<>();\n\nmain(){\n\tmThreadLocal.set(\"thread_main\");\n\tLog.i(\"tmp\", \"result-1=\" + mThreadLocal.get());\n\n \tThread thread_1 = new Thread() {\n          @Override\n         public void run() {\n              super.run();\n             mThreadLocal.set(\"thread_1\");\n             Log.i(\"tmp\", \"result-2=\" + mThreadLocal.get());\n         }\n     };\n     thread_1.start();\n     //该句表示thread_1执行完后才会继续执行\n     thread_1.join();\n\n     Thread thread_2 = new Thread() {\n         @Override\n         public void run() {\n             super.run();\n             Log.i(\"tmp\", \"result-3=\" + mThreadLocal.get());\n         }\n     };\n     thread_2.start();\n}\n\n打印结果：\nresult-1=main-thread\nresult-2=thread_1\nresult-3=null"
      },
      {
        "title": "AsyncTask的使用",
        "content": "public class AsyncTaskTest extends AsyncTask<>{\n\nprotected void onPreExecute() {…准备…}\n\nprotected Long doInBackground(String... params) {…后台执行…}\n\nprotected void onProgressUpdate(Object... values) {…更新中…}\n\n protected void onPostExecute(Long aLong) {…完成…}\n\n}\n\n然后在activity中调用 new AsyncTaskTest().execute()"
      },
      {
        "title": "AsyncTask原理",
        "content": "内部是Handler和两个线程池实现的，Handler用于将线程切换到主线程，两个线程池一个用于任务的排队，一个用于执行任务\n\n当AsyncTask执行execute方法时会封装出一个FutureTask对象，将这个对象加入队列中，如果此时没有正在执行的任务，就执行它，执行完成之后会通过scheduleNext()继续执行队列中下一个任务，也就是通过这种方式来串行完成任务的，执行完成通过Handler将事件发送到主线程。\n\nAsyncTask必须在主线程初始化，\n主要是为了在主线程更新UI，因为内部的Handler是一个静态对象，在AsyncTask类加载的时候他就已经被初始化了，如果在子线程中就会使用子线程的looper，也就把消息给到了子线程。\n\n在Android3.0开始，execute方法串行执行任务的，一个一个来，3.0之前是并行执行的。如果要在3.0上执行并行任务，可以调用executeOnExecutor方法"
      },
      {
        "title": "AsyncTask提供的4个核心方法",
        "content": "1、onPreExecute():该方法在主线程中执行，在执行异步任务之前会被调用，一般用于一些准备工作。\n \n2、doInBackground(String... params):这个方法是在线程池中执行，此方法用于执行异步任务。在这个方法中可以通过publishProgress方法来更新任务的进度，publishProgress方法会调用onProgressUpdate方法，另外，任务的结果返回给onPostExecute方法。\n \n3、onProgressUpdate(Object... values):该方法在主线程中执行，主要用于任务进度更新的时候，该方法会被调用。\n \n4、onPostExecute(Long aLong)：在主线程中执行，在异步任务执行完毕之后，该方法会被调用，该方法的参数及为后台的返回结果。"
      }
    ]
  },
  {
    "name": "线程池",
    "data": [
      {
        "title": "线程池创建方法",
        "content": "创建线程池的方式一般有两种：\n\n1、通过Executors工厂方法创建\n\n2、 通过ThreadPoolExecutor构造函数创建。\n\nnewThreadPoolExecutor(intcorePoolSize, intmaximumPoolSize, longkeepAliveTime,TimeUnitunit,BlockingQueue<Runnable>workQueue)自定义创建"
      },
      {
        "title": "Executors API提供的4种线程池",
        "content": "Executors.newSingleThreadExecutor()：单线程的线程池，只有一个线程在工作，任务按顺利执行\n\nExecutors.newFixedThreadPool(3)：构建固定线程数的线程池，默认情况下，空闲线程不会被回收\n\nExecutors.newCachedThreadPool():创建一个会根据需要创建新线程的线程池，线程数随着任务量而变动，空闲线程超过60秒将被回收\n\nExecutors.newScheduledThreadPool(空或int):创建定时线程任务的线程池，可以通过传参设置固定数量，它的实例可以调用\n\nscheduleAtFixRate(runnable,第一次执行延迟时间，每隔多久执行，时间单位)来周期性执行任务。"
      },
      {
        "title": "ThreadPoolExecutor 线程池构造函数的七个参数",
        "content": "1、corePoolSize 线程池核心线程大小\n\n2、maximumPoolSize 线程池最大线程数量\n\n3、keepAliveTime 空闲线程存活时间\n\n4、unit 空闲线程存活时间单位\n\n5、workQueue 工作队列，JDK提供了四种\n\n6、threadFactory 线程工厂\n\n7、handler 拒绝策略，JDK提供了四种"
      },
      {
        "title": "线程池相关",
        "content": "线程池任务提交过程,核心流程其实就是走的ThreadPoolExcutor类中的execute(runnable)方法：\n\na. 首先判断核心线程池中的线程是否已经满了，如果没满，则创建一个核心线程执行任务，否则进入下一步\n\nb. 判断工作队列是否已满，没有满则加入工作队列，否则执行下一步\n\nc. 判断线程数是否达到了最大值，如果不是，则创建非核心线程执行任务，否则执行饱和策略，默认抛出异常  \n\n\n线程池如何实现线程的复用？有任务的时候就被派去执行任务，没有任务就处于阻塞状态, 被挂起了"
      },
      {
        "title": "如何关闭线程池",
        "content": "1. shutdown() 不接收新任务,会处理已添加任务\n\n2. shutdownNow() 不接受新任务,不处理已添加任务,中断正在处理的任务"
      },
      {
        "title": "工作队列 wordQueue",
        "content": "SynchronousQueue:无缓冲等待队列.从队列中取和放都是阻塞方法,如果队列满了再往里放,会进入阻塞.如果队列中没有任务在往出取也会进入阻塞.类似于生产者与消费者模式那种的.这个队列只能装一个任务.\n\nLinkedBlockingQueue:无界缓存队列. 长度是Integer.MAX_VALUE,当执行的线程数量等于核心线程数量的时候,剩余的任务会在阻塞队列中等待.所以在使用这个队列的时候,最大线程数的参数相当于无效了.\n\nArrayBlockingQueue:有界缓存队列可以定义队列的长度.\n\nPriorityBlockingQueue（具有优先级的无界阻塞队列，优先级通过参数Comparator实现）\n\n注意\n1. 当workQueue使用的是无界限队列时，maximumPoolSize参数就变的无意义了，比如new LinkedBlockingQueue(),或者new ArrayBlockingQueue(Integer.MAX_VALUE);\n\n2. 使用SynchronousQueue队列时由于该队列没有容量的特性，所以不会对任务进行排队，如果线程池中没有空闲线程，会立即创建一个新线程来接收这个任务。maximumPoolSize要设置大一点。\n\n3. 核心线程和最大线程数量相等时keepAliveTime无作用."
      },
      {
        "title": "非核心线程的回收",
        "content": "工作线程启动后，会进入一个runWorker的方法里。\n\n里面是一个while循环，循环判断任务是否为空，若不为空，执行任务；若取不到任务，或发生异常，退出循环，执行processWorkerExit(w, completedAbruptly);\n\n在这个方法里把工作线程移除掉。"
      },
      {
        "title": "线程池的拒绝策略",
        "content": "CallerRunsPolicy：不抛弃线程 调用线程池的线程帮助执行，如果线程池已经shutdown，则直接抛弃任务。\n\nAbortPolicy：该策略下，直接丢弃任务，并抛出\n\nRejectedExecutionException异常\n\nDiscardPolicy：该策略下，直接丢弃任务，什么都不做。\n\nDiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列"
      },
      {
        "title": "阻塞队列的原理",
        "content": "阻塞队列实际上是使用了Condition来模拟线程间协作，调用Condition的await()和signal()方法也都是上锁的，原理就是类似于Looper，那种生产者与消费者的场景，当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程会被唤醒，就可insert了"
      },
      {
        "title": "线程池中的CPU密集与IO密集型区别",
        "content": "CPU密集指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，所以线程数一般只需要cpu核数的线程就可以了\n\nIO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，所以通常就需要cpu核心的两倍的线程。"
      }
    ]
  },
  {
    "name": "锁",
    "data": [
      {
        "title": "volatile原理",
        "content": "一、volatile可见性的实现就是借助了CPU的lock指令，通过在写volatile的机器指令前加上lock前缀，使写volatile具有以下两个原则：\n\n1、写volatile时处理器会将缓存写回到主内存。\n\n2、一个处理器的缓存写回到内存会导致其他处理器的缓存失效。\n\n\n二、正常new对象顺序1.分配对象内存空间 2.初始化对象 3.赋值给引用   JVM在执行过程中为了保证效率等因素可能会进行重排序，如顺序变为132。\n\n禁止指令重排序是通过加内存屏障来实现的。JMM为volatile加内存屏障有以下4种情况：写volatile与后面的写操作重排序、写volatile与后面的读操作重排序，读volatile与后面的读操作重排序、防止读volatile与后面的写操作重排序。\n\n在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。\n\n在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。\n\n在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。\n\n在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序。"
      },
      {
        "title": "什么是死锁？死锁的四个条件，如何避免死锁",
        "content": "死锁：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程都处于阻塞状态，无法继续。\n\n\n四个条件\n1、互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。\n\n2、请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n\n3、不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。\n\n4、循环等待条件:若干进程间形成首尾相接循环等待资源的关系\n\n\n如何避免\n\n1、合理分配资源，做好解耦工作，避免线程交叉竞争\n\n2、锁的范围尽可能的要小，能用同步代码块就别用方法锁和类锁\n\n3、避免多次上锁，注意加锁顺序\n\n4、使用锁时，可以多考虑些可操作的锁，比如可中断锁，以及在上锁前判断下上锁状态等。\n"
      },
      {
        "title": "sleep、wait、notify、notifyAll区别",
        "content": "sleep、wait最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。\n\n1. sleep是Thread类的静态方法,wait是Object类中定义的方法\n2. Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁,而wait 会释放当前线程锁\n3. Thread.sleep需要设定休眠时间.Object.wait也可以设定wait时间,或者通过线程执行notify/notifyAll进行唤醒\n\nnotify与notifyAll\n\n1. notify唤醒一个线程,如果有多线程在wait,可能是随机一个\n\n2. notifyAll唤醒所有在等待的线程,\n\n3. 使用中尽量使用notifyAll,因为notify容易导致线程死锁(nofity只唤醒一个,其他等待的线程没有唤醒)"
      },
      {
        "title": "sleep(0)的作用",
        "content": "在线程中，调用sleep（0）可以释放cpu时间，让线程马上重新回到就绪队列而非等待队列，sleep(0)释放当前线程所剩余的时间片（如果有剩余的话），这样可以让操作系统切换其他线程来执行，提升效率。"
      },
      {
        "title": "volatile特性",
        "content": "Volatile关键字可以修饰变量，用于多线程的访问。它能保证内存的可见性和有序性，但不能保证原子性\n\n内存可见性：如果对变量加上volatile关键字修饰的话，它可以保证当有线程对变量值做了变动之后，会立即刷回到主内存中，所有线程都能读到相同的值\n\n有序性：JVM为了保证执行上的效率，可能会对指令进行重排序，而加上volatile关键字修饰后，在指令间插入一个屏障点，就告诉JVM和CPU，不能进行重排优化。其实volatile有序性是通过内存屏障实现的\n\n不保证原子性：有个例子，1000个线程同时去对被volatile修饰过的变量进行+1操作，但值确肯定不是1000，也就是说volatile并不能保证一个线程执行完，另一个线程才开始执行，不能保证操作并不是不可分割的。"
      },
      {
        "title": "synchronized原理",
        "content": "在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。所有锁都是存储在 Java 对象头里的。jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。\n\n如果是方法级的同步，JVM会从方法表结构 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。如果是的话，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。\n\n代码块的同步是利用 monitorenter 和 monitorexit 这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当 jvm 执行到 monitorenter 指令时，当前线程试图获取 monitor 对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器 + 1；当执行 monitorexit 指令时，锁计数器 - 1；当锁计数器为 0 时，该锁就被释放了。如果获取 monitor 对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。"
      },
      {
        "title": "lock 原理",
        "content": "lock的存储结构：一个是表示（锁）状态的int变量、一个是双向链表的队列（用于存储等待中的线程）。\n\n线程A取得了锁，把 state原子性+1,这时候state被改为1，这时线程B请求锁，线程B无法获取锁，生成节点进入排队\n\n只有线程A把此锁全部释放了，状态值减到0了，其他线程才有机会获取锁。当A把锁完全释放后，会通知队列唤醒B线程节点，使B可以再次竞争锁。如果是公平锁，就是按照链表顺序唤醒，如果是非公平锁，就会有竞争。获取锁成功后，会将该线程的节点从队列中删除"
      },
      {
        "title": "volatile与synchronized区别",
        "content": "1、volatile本质上是直接从主内存中读取值，无法保证同步\n\n2、volatile只能实现变量的修改可见性，并不能保证原子性；而synchronizedl则因为能保证线程安全，可以保证变量的修改可见性和原子性。\n\n3、volatile只能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。\n\n4、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。"
      },
      {
        "title": "锁的作用范围",
        "content": "作用在方法上：\n\n实例方法：被锁的是该类实例对象\npublic synchronized void method(){}\n\n表态方法：锁住的是类的所有对象\npublic static synchronized void method(){}\n\n\n\n作用在代码块上：\n\n实例对象：被锁的是类的实例对象\nsynchronized(this){}\n\nClass对象：被锁的是类的所有对象\nsynchronized(Demo.class){}\n\n任意实例对象Object\nString a = “”;\nsynchronized(a){}\n\n\n总结下，除了静态方法和锁class，其他的都是作用在实例上。"
      },
      {
        "title": "实锁的种类",
        "content": "1、synchronized\n\n2、lock  lock里又可以细分ReentrantLock、ReentrantReadWriteLock是一个读写锁，如果读的线程比写的线程要多很多的话，那可以考虑使用它。它使用state的变量高16位是读锁，低16位是写锁\n\n3、ReadWriteLock读写锁，需要读和写是互斥的，写和写是互斥的，但是读和读是不需要互斥的\n\nReadWriteLock rwl = new ReentrantReadWriteLock();\nrwl.writeLock().lock();// 取到写锁  \nrwl.writeLock().unlock();// 释放写锁\nrwl.readLock().lock();// 取到读锁 \nrwl.readLock().unlock();// 释放读锁"
      },
      {
        "title": "虚锁的种类",
        "content": "有很多并不是指实际的锁，是根据锁的特性起的名字，比如公平锁、可重入锁、独享锁、乐观锁、自旋锁之类的\n\n1、公平锁：先来先得，按顺利获得锁。非公平锁：有可能后申请的线程比先申请的线程优先获取锁，随机性.ReentrantLock 默认采用非公平锁，除非在构造方法中传入参数 true 。\n\npublic ReentrantLock(boolean fair) \n\n2、可重入锁：递归锁也算。同一个线程在进入内层方法会自动获取锁，可重入锁的一个好处是可一定程度避免死锁。场景：一个synchronized方法需要调用另一个synchronized方法时。\n\n3、 独享锁/共享锁：独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。\n\n4、乐观锁/悲观锁：乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度，悲观锁：悲观的认为，不加锁的并发操作一定会出问题。乐观锁：乐观的认为，不加锁的并发操作是没有事情的\n\n5、分段锁\n分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。\n\n6、偏向锁/轻量级锁/重量级锁\n这三种锁是指锁的状态，并且是针对Synchronized\n\n偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。\n\n轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。\n\n重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。\u2028\n7、自旋锁\n自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。\n"
      },
      {
        "title": "可重入锁",
        "content": "在JAVA环境下ReentrantLock和synchronized都是可重入锁。\n\nsynchronized是一个可重入锁。在一个类中，如果synchronized方法1调用了synchronized方法2，方法2是可以正常执行的，这说明synchronized是可重入锁。否则，在执行方法2想获取锁的时候，该锁已经在执行方法1时获取了，那么方法2将永远得不到执行。\n\n可重入锁主要用在线程需要多次进入临界区代码时，需要使用可重入锁。具体的例子，比如上文中提到的一个synchronized方法需要调用另一个synchronized方法时。"
      },
      {
        "title": "lock的使用",
        "content": "private Lock lock = new Lock();// 锁对象  \n\n1、lock.lock();// 线程输出方法\n\n2、lock.unlock();// 释放锁\n\n3、lock.tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；\n\n4、tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；"
      },
      {
        "title": "synchronized和Lock的区别、适用场景",
        "content": "区别：\n1、定义和使用：synchronized是java的关键字，可以作用于类、函数、对象，但lock是接口，需要线程去持有使用实现lock的对象来使用。\n\n2、操作性：synchronized加锁和解锁都是自动进行的，易于操作，但lock（或实现接口的reentrantlock）都需要手动上锁解锁，最好还要配合try-finaly来使用，防止死锁\n\n3、灵活性：最重要的，synchronized的是不可终断锁，等待锁过程是固定的，等不到就会一直等，但lock可以trylock尝试上锁，而且能够拿到锁定与否的状态(boolean=lock.trylock())，会有更多的选择，可以提高多个线程进行读操作的效率。\n\n4、性能：如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized\n\n\n适用场景：少量线程同步适合用synchronized，大量线程适合用lock"
      }
    ]
  },
  {
    "name": "数据类型与存储",
    "data": [
      {
        "title": "HashMap原理",
        "content": "HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表的表头，由 Node 内部类完成存储，Node类实现了 Map.Entry<K,V>接口。\n\n当存储对象时，将 K/V 键值传给 put() 方法：首先会计算出Key的hash值，如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞\n\n如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对，如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）"
      },
      {
        "title": "ConcurrentHashMap 原理",
        "content": "在JDK 1.7中，ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成的。使用的是分段锁技术(ReentrantLock)，然后给每一段数据配一把锁（segment），当一个线程占用一把锁（segment）访问其中一段数据的时候，其他段的数据也能被其它的线程访问，默认分配16个segment，效率要比hashtable要高很多。\n\nJDK1.8中ConcurrentHashMap取消了segment分段锁，而采用CAS(原子操作)和synchronized来保证并发安全。数据结构跟HashMap很像，数组+链表/红黑二叉树。\nsynchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升了很多。"
      },
      {
        "title": "hashtable原理",
        "content": "Hashtable 与 HashMap 类似，也是一个存储键值对的散列表，Hashtable 继承自 Dictionary 类，实现了 Map、Cloneable、Serializable 接口\n\ntable是一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表的\"key-value键值对\"都是存储在Entry数组中的。\n\nput方法的整个处理流程是：计算key的hash值，根据hash值获得key在table数组中的索引位置，然后迭代该key处的Entry链表（我们暂且理解为链表），若该链表中存在一个这个的key对象，那么就直接替换其value值即可，否则在将改key-value节点插入该index索引位置处。"
      },
      {
        "title": "如何计算hash值的？",
        "content": "采用高位16位组成的数字与源哈希值取异或而生成的哈希值作为用来计算的\n\n为什么要用异或？减少碰撞。可以将高低位二进制特征混合起来\n\n异或：两个值相同结果为0，不同结果为1"
      },
      {
        "title": "HashMap是如何计算下标的",
        "content": "当我们put的时候，会根据key获取对应的hash值，然后无符号右移16位（>>> 16）,在与原本的hash值进行异或^计算，然后再与table.length-1进行与&计算，最终得出需要放入的位置\n\ntable下标i=(table.length- 1) & ((h = key.hashCode()) ^ (h >>> 16))\n\n1、与（&）：两个数都数为1，则该位结果为1，否则为0。\n2、非（~）：数为1，结果为0；数为0，结果为1。\n3、或（|）：两个数至少一个1，则运算结果为1；否则结果为0。\n4、异或（^）：两个数相同则结果为0，不同则为1。"
      },
      {
        "title": "HashMap与HashTable的区别",
        "content": "最大的不同是hashtable是线程安全的，里面方法是synchronized，而HashMap是非线程安全的。所以HashMap性能更好些。也正是因为HashTable性能弱些，所以它用的是头插法，否则还要遍历到链表的尾部插入。\n\nHashtable中，key和value都不允许出现null值。HashMap中key和value都可以为null\n\n另外他们初始容量不一样，HashTable是11，但HashMap是16，而且HashTable没有红黑数支持，HashMap它数组到64，链表长度到8就会转成红黑数，还有扩容，HashTable是2倍+1，而HashMap是变为2位。\n\n再有就是哈希值的计算不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值(高16位异或低16位)，并且HashMap 支持key 为null 就是在这里的"
      },
      {
        "title": "ArrayList和LinkedList的区别，以及应用场景",
        "content": "Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中后面的所有数据。最差情况是ON\n\nlinkedList是基于双链表的，他的特点就是插入和删除非常快，只需要改变相邻节点的指针就可以了，但他如果用来查询就很慢了，最差情况是ON，因为他需要一个一个去找。\n\n除此之外像ArrayList是数组结构，所以他的起始容量是10，当数组需要增长时，就会新增一个为原来1.5倍容量的新数组，然后把原数组的数据原封不动的复制到新数组中，再把新数组赋值给原来的数组对象就完成了。所以会有空间浪费的情况\n\n一般情况下，LinkedList的占用空间更大，因为每个节点要维护指向前后地址的两个节点，但也不是绝对，如果刚好数据量超过ArrayList默认的临时值时，ArrayList占用的空间也是不小的，因为扩容的原因会浪费将近原来数组一半的容量\n"
      },
      {
        "title": "数组和链表的区别",
        "content": "数组：是将元素在内存中连续存储的；它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效率比较高；它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低。\n\n链表：是动态申请内存空间，不需要像数组需要提前申请好内存的大小，链表只需在用的时候申请就可以，根据需要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）"
      },
      {
        "title": "扩容机制",
        "content": "HashMap的初始容量16，默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。\n\nArrayList初始是10，每次扩容是原来得1.5倍。数组进行扩容时，会将老数据中得元素重新拷贝一份道新的数组中，负载因子1\n\n\n初始容量 负载因子 扩容增量\nArrayList 10 1 0.5倍\nVector 10 1 1倍\nHashSet 16 0.75 1 倍\nHashMap 16 0.75 1 倍"
      },
      {
        "title": "介绍下SP",
        "content": "SP作为Android存储数据方式之一，它是轻量级存储，只支持java基本数据类型，且在进程内可以进行数据共享。 \n\n之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会一次性把整个文件全部加载进内存，如果SharedPreference文件比较大，会导致阻塞线程、产生大量临时对象引起GC、key和value会占用大量内存，非常消耗资源\n\n commit会立即并同步保存数据。\n\napply则异步保存数据，从而提高了性能。如果你不关心它的返回类型，则apply优先于commit"
      },
      {
        "title": "SP内部工作原理",
        "content": "1、调用getSharedPreferences（）；创建一个SharedPreferences对象，其中会先判断是否存在对应xml文件\n\n2、如果对应的xml不存在则重新创建一个对应xml文件，如果存在则会把xml文件解析后存入一个map对象中(通过I/O流操作和xmlUtil，map为ArrayMap)。\n\n3、EditorImpl的putXXX方法，主要是将数据保存在一个Map中，这些数据是存储在内存中，只有调用了commit()或apply()方法之后，才会同步到磁盘中。"
      },
      {
        "title": "使用SP保存key-values的步骤",
        "content": "1）使用activity类的getSharedPreferences方法获得SharedPreference对象\n\n2）使用SP接口的edit获得Sharedpreferences.Editor对象\n\n3）通过sharedpreferences.editor接口的putXxx方法保存键值对，\n\n4）通过Sharedpreferences.editor接口的commit（）方法保存键值对"
      },
      {
        "title": "SP是否安全？",
        "content": "SharePreferences是线程安全的 里面的方法有大量的synchronized来保障 \n\n在进程间是不安全的。原因是系统对SharedPreferences的读写有一定的缓存策略，即内存中有一份SharedPreferences文件的缓存\n\n在多进程模式下，系统对它的读写变的不可靠，当面对高并发的读写访问，SharedPreferences很很大几率会造成数据丢失\n\n所以，不建议在进程通信中使用SharedPreferences。"
      },
      {
        "title": "Serializable和Parcelable的区别",
        "content": "所谓的序列化指的是把对象转换成字节流的过程，可以保存到文件中，也可以用来网络传输数据。\n反序列化既是相反的过程，可以从我们的文件中把字节流读出来，转换为对象供我们使用。\n\n序列化有两个方法，一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，但在序列化的时候会产生大量的临时变量，内部会执行大量的i/o操作，效率很低。而实现Parcelable接口稍微复杂一些，但效率更高，不过有个插件，Parcelable Code Generator，一键生成，也挺好用的。另外在内存中读写，但对象不能保存到磁盘中，因为Parcelable在对数据做持久化上不是太好，或是在外界有变化的情况下不能很好的保证数据的持续性，或是多版本版本兼容问题\n\nParcelable用法\n\n1）implements Parcelable\n2）实现接口中的两个方法，一个是描述内容的，返回0就行。还有个是重写writeToParcel方法，将你的对象序列化为一个Parcel对象，把属性都写入Parcel对象中\n4）实例化静态内部对象CREATOR实现接口Parcelable.Creator，实例化CREATOR时要实现其中的两个方法，其中createFromParcel的功能就是从Parcel中读取我们的对象（另一个是供外部类反序列化本类数组使用）\n\n\n调用方法\n\n存：bundle.putParcelable(\"book\", book);intent.putExtras(bundle);\n\n取：Bundle bundle = intent.getExtras();Book book = bundle.getParcelable(\"book\");"
      },
      {
        "title": "红黑数",
        "content": "待解"
      }
    ]
  },
  {
    "name": "网络",
    "data": [
      {
        "title": "网络通信一共有几层",
        "content": "OSI模型，也就是开放式系统互联通信参考模型。这个模型把网络通信的工作分为7层，分别是\n物理层,\n数据链路层,\n网络层,\n传输层,\n会话层，\n表示层\n和应用层。\n\n1至4层被认为是低层，这些层与数据移动密切相关。5至7层是高层，包含应用程序级的数据。每一层负责一项具体的工作，然后把数据传送到下一层"
      },
      {
        "title": "Http与Https的区别",
        "content": "主要有3点不同\n1、安全性：HTTPS不是明文传输的，会通过SSL数据加密、TLS验证身份，以及数据完整性保护（收方或非法者不能伪造、篡改报文，运营商加广告）而HTTP是明文传输无状态的（比较独立，服务器与客户端都不会记录信息），所以安全性要高于HTTP\n2、HTTPS需要申请CA证书，而HTTP不需要\n3、用的端口也不一样，HTTP是80，HTTPS是443"
      },
      {
        "title": "Https传输流程",
        "content": "HTTPS流程\n\n1、客户端向服务端发送通信请求，明确好需要确信的信息，像ssl协议的版本、支持的加密算法，压缩方法等。\n\n2、服务端收到请求，会确认客户端传来的信息，如果协议版本不对，会关闭加密通信。同时服务端还会向客户端传送自己的公钥证书\n\n3、客户端收到证书后，首先会进行验证合法性，是否过期、发行机构、域名是否匹配等。验证通过之后，就会生成一个随机的对称密钥（session key），再使用证书中的公钥进行加密，然后传递给服务器端\n\n4、服务器收到使用公钥加密的内容，使用私钥解密后，拿到客户端值过来的随机值，然后把内容通过该值进行对称加密，传给客户端。\n\n5、客户端再用之前生成的随机值来解密，拿到内容\n\n整体过程就是先确认信息，然后是非对称加密传输对称加密的密钥，再拿对称密钥加密解密。\n"
      },
      {
        "title": "tcp、http、socket的区别",
        "content": "tcp协议属于传输层协议。建立一个TCP连接需要三次握手，断开一个TCP连接需要四次挥手。\n\nhttp协议，简称超文本传输协议(Hypertext Transfer Protocol)，http协议在tcp协议上面，属于应用层协议。\n\nsocket套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。常用的方法socket（）  bind()"
      },
      {
        "title": "Tcp握手过程",
        "content": "TCP三次握手：\n\n1：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；\n\n2：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n\n3：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\n四次挥手：\n1、主动关闭方会发一个长度为0的数据包以及FIN关闭标识。\n\n2、被动方收到FIN后，会发一个ACK确认包，确认序号+1。\n\n3、确认无需要发送数据后，被动关闭方也会发一个FIN包，告诉主动关闭方，我也不会再发数据了。\n\n4主动关闭方发ACK确认，确认序号+1。\n\n两次不行，为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。\n\n确认号要加1，因为报文不一定会按发送的时序到达目标，为了区分所以要加1\n\n出现大量的close_wait是因为被动关闭方没有发送FIN包确认关闭，是程序的问题。\n如果是server主动关闭链接,那么Client则有可能进入CLOSE_WAIT,如果Client不发送FIN包，该关不关,那么client就一直会处在CLOSE_WAIT状态\n\n为什么是4次握手，因为被动方收到FIN后，需要先确认，防止主动方因等待时间过长再发FIN，被动方处理完数据后再发FIN"
      },
      {
        "title": "TCP、UDP协议的区别",
        "content": "UDP：面向无连接，速率快。不可靠\n\nTCP：在传递数据之前先建立连接，数据传输结束后还要释放资源。可靠但传输速率相对慢。\n\nTCP的可靠性体现在：在传递数据之前建立握手连接，在数据传递时，通过确认、窗口、重传、拥塞机制来保证数据传输的可靠性。\n\n适用场景：UDP：适用于实时应用（IP电话、视频会议、直播等）。TCP:适用于要求可靠传输的应用，例如文件传输\n\n\n了解：\n校验和：TCP在计算校验和时，会在TCP首部加上12byte的伪首部，如果不一致会丢弃，重新发送\n\n确认应答与序列号：TCP将每个数据包都进行了编号，像ack有确认序号，数据包也有序号\n\n重传：当报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传\n\n流量控制：TCP支持根据接收端的处理能力，来决定发送端的发送速度。在TCP报文段首部中有一个16位窗口长度，当接收端接收到发送方的数据后，在应答报文ACK中就将自身缓冲区的剩余大小，放入16窗口大小中\n\n拥塞控制：先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。"
      },
      {
        "title": "输入一个网址的全过程",
        "content": "输入网址后，首先会从浏览器、系统、路由器当中查看是否有缓存，如果有从缓存当中显示页面，没有的话再进行DNS域名解析，把域名转换成IP，然后TCP连接，进行请求，请求成功后再把数据进行解析，页面渲染。"
      },
      {
        "title": "http错误码",
        "content": "1xx   信息性状态码，接受的请求正在处理\n\n2xx\t成功状态码，请求正常\n200： 请求成功。一般用于GET与POST请求\n201 - Created 服务器已经创建了文档，Location头给出了它的URL\n202 - Accepted 已经接受请求，但处理尚未完成\n\n3xx\t重定向状态码\n301 Moved Permanently：永久性重定向\n302 Found：临时性重定向\n\n4xx\t客户端错误状态码\n400：Bad Request 请求出现语法错误\n401 - Unauthorized 访问被拒绝，客户试图未经授权访问受密码保护的页面。\n403 - Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致\n404 - Not Found 无法找到指定位置的资源。这也是一个常用的应答\n\n5xx\t服务端错误状态码\n500 - Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求\n502 - Bad Gateway 服务器用作网关或代理服务器时收到了终端服务器的无效响应\n503 - Service Unavailable 服务不可用，服务器由于维护或者负载过重未能应答\n"
      },
      {
        "title": "charles工作原理，如何防劫持的",
        "content": "第一步， charles向服务器发送请求进行握手， 获取到服务器的CA证书， 用根证书公钥进行解密， 验证服务器数据签名，获取到服务器CA证书公钥。\n\n第二步， charles伪造自己的CA证书， 冒充服务器证书传递给客户端浏览器，客户端做跟charles一样的事。\n\ncharles向服务器冒充是客户端，向客户端又谎称自己是服务器。\n\n解决防劫持，可以下载服务器端公钥证书，然后将公钥证书编译到Android应用中一般在assets文件夹保存，由应用在交互过程中去验证证书的合法性。如果还想使用charls，可以让Charles的CA证书也成为我们证书信任链中的一个"
      },
      {
        "title": "OkHttp工作流程",
        "content": "先创建 OkHttpClient 实例;\n\n构造 Request 实例，传入 url 等相关参数；\n\n通过前两步中的实例对象构建 Call 对象；\n\n异步请求通过 Call#enqueue(Callback) 方法来提交异步请求，同步请求通过 Call#execute() 直接获取 Reponse ;\n\n\nString url = \"http://wwww.baidu.com\";\nOkHttpClient okHttpClient = new OkHttpClient();\nfinal Request request = new Request.Builder()\n        .url(url)\n        .get()//默认就是GET请求，可以不写\n        .build();\nCall call = okHttpClient.newCall(request);\ncall.enqueue(new Callback() {\n    @Override\n    public void onFailure(Call call, IOException e) {\n        Log.d(TAG, \"onFailure: \");\n    }\n\n    @Override\n    public void onResponse(Call call, Response response) throws IOException {\n        Log.d(TAG, \"onResponse: \" + response.body().string());\n    }\n});"
      },
      {
        "title": "OKHttp原理",
        "content": "execute()及enqueue()这两个方法会最终调用RealCall中的getResponseWithInterceptorChain()（重点）方法，从拦截器链中获取返回结果。而返回结果也会再经过上述拦截器依次处理，最后将结果给到调用方。\n\n主要是利用了责任链模式来实现各种拦截器的添加。是一种分层的思想，每一个Interceptor就是一层，每一层只关心这一层的责任，比如CallserverInterceptor,只关心与服务器连接，Cacheinterceptor只关心缓存的拦截就可以了。他把各种复杂的任务拆分成了一个一个具体独立的任务，对未来的扩展很有帮助。"
      },
      {
        "title": "OkHttp中的设计模式",
        "content": "责任链模式：拦截器链\n\nBuilder模式：OkHttpClient的构建过程\n\n外观模式：OkHttpClient封装了很对类对象\n\n工厂模式：Socket的生产\n\n单例模式：线程池\n\n观察者模式：各种回调监听\n\n策略模式：缓存策略"
      },
      {
        "title": "OkHttp拦截器",
        "content": "RetryAndFollowUpIntercepto\n负责重试或请求重定向。\n\nBridgeInterceptor\n对请求头以及返回结果处理。\n\nCacheInterceptor\n负责读取缓存以及更新缓存。\n\nConnectInterceptor\n负责与服务器建立连接\n\nCallServerInterceptor\n负责从服务器读取响应的数据\n\n\n拦截链会调用proceed方法，用递归的方式来遍历整个拦截器列表，当拦截器集合不为空，一个个加进去，拦截器读取完了，再进行请求"
      },
      {
        "title": "retrofit的使用",
        "content": "// 1、创建Retrofit实体类\nRetrofit retrofit = new Retrofit.Builder()\n    .baseUrl(\"https://api.github.com/\")\n    .build();\n\n// 2、创建接口实现类\nGitHubService service = retrofit.create(GitHubService.class);\n\n// 3、通过实现类得到Call实例\n// https://api.github.com/users/octocat/repos\nCall<List<Repo>> repos = service.listRepos(\"octocat\");\n\n// 4、Call发起同步/异步请求\n/*同步请求\ntry {\n    Response<List<Repo>> execute = repos.execute();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n5、通过数据转换器解析服务器返回的数据\n*/\nrepos.enqueue(new Callback<List<Repo>>() {\n    @Override  //6、通过回调执行器切换线程（子线程 ->>主线程）\n    public void onResponse(Call<List<Repo>> call, Response<List<Repo>> response) {\n\n    }\n\n    @Override\n    public void onFailure(Call<List<Repo>> call, Throwable t) {\n\n    }\n});"
      },
      {
        "title": "retrofit原理",
        "content": "Retrofit 通过 java 接口以及注解来描述网络请求，并用动态代理的方式生成网络请求的 request，\n\n然后通过 client 调用相应的网络框架（默认 okhttp）去发起网络请求，\n\n并将返回的 response 通过 converterFactorty 转换成相应的数据 model，\n\n最后通过 calladapter 转换成其他数据方式"
      },
      {
        "title": "retrofit优点",
        "content": "超级解耦 ，接口定义、接口参数、接口回调不在耦合在一起\n\n可以配置不同的httpClient来实现网络请求，如okhttp、httpclient\n\n支持同步、异步、Rxjava\n\n可以配置不同反序列化工具类来解析不同的数据，如json、xml\n\n请求速度快，使用方便灵活简洁"
      },
      {
        "title": "动态代理的优点",
        "content": "一个Java Interface是不可以直接创建一个对象的，动态代理所做的是在运行时生成一个实现了该Interface的类的Class对象。\n\nRetrofit使用动态代理，其实是为了开发者在写代码时方便调用，而真正负责生产Call网络工作对象的，还是Retrofit.create函数中定义的这个InvocationHandler。invoke方法是动态代理类处理的主要方法。\n\n说通俗点，就像你通过网络买东西，把需求制定好下单，就会有快递员帮你去购买跑腿，不需要你亲自动手一个道理。"
      },
      {
        "title": "添加拦截器的作用与区别",
        "content": "作用：1、重写请求：可以添加、移除、替换请求头。2、重写响应：可以重写响应头并转换响应体\n\n Map<String, String> map = new HashMap<>();\n        map.put(\"source\", \"android\");\n        PublicParamInterceptor publicParamInterceptor = new PublicParamInterceptor(map);\n\n        //创建一个主线程的handler\n        mHandler = new Handler(Looper.getMainLooper());\n        mOkHttpClien = new OkHttpClient.Builder()\n                .connectTimeout(5000, TimeUnit.MILLISECONDS)\n                .readTimeout(5000, TimeUnit.MILLISECONDS)\n                .writeTimeout(5000, TimeUnit.MILLISECONDS)\n                //B.添加okhttp的拦截器\n                .addInterceptor(publicParamInterceptor)\n                .build();\n\n在OkHttpClient.Builder的构造方法有两个参数，使用者可以通过addInterceptor 和 addNetworkdInterceptor 添加自定义的拦截器 加拦截器的顺序可以知道 Interceptors 和 networkInterceptors 刚好一个在 RetryAndFollowUpInterceptor 的 前面，一个在后面 责任链调用图可以分析出来，假如一个请求在 RetryAndFollowUpInterceptor 这个拦截器内部重试或者重定向 了 N 次，那么其内部嵌套的所有拦截器也会被调用N次，同样 networkInterceptors 自定义的拦截器也会被调用 N 次。而相对的 Interceptors 则一个请求只会调用一次，所以在OkHttp的内部也将其称之为 Application Interceptor。\n\naddInterceptor（应用拦截器）：\n通过 addInterceptor() 方法添加的拦截器是放在最前面的。\n1，不需要担心中间过程的响应,如重定向和重试.\n2，总是只调用一次,即使HTTP响应是从缓存中获取.\n3，观察应用程序的初衷. 不关心OkHttp注入的头信息如: If-None-Match.\n4，允许短路而不调用 Chain.proceed(),即中止调用.\n5，允许重试,使 Chain.proceed()调用多次.\n\n\u2028addNetworkInterceptor（网络拦截器）：\n添加在 ConnectInterceptor 和 CallServerInterceptor 之间的。\n1，能够操作中间过程的响应,如重定向和重试.\n2，当网络短路而返回缓存响应时不被调用.\n3，只观察在网络上传输的数据.\n4，携带请求来访问连接."
      }
    ]
  },
  {
    "name": "性能优化",
    "data": [
      {
        "title": "卡顿的原因",
        "content": "卡顿最根本原因是因为掉帧，我们手机正常情况下是每秒60帧，也就是16ms一帧。造成卡顿的原因有3点。\n\n一是遍历绘制 View 树计算屏幕数据的时间超过了 16.6ms，也就是过渡绘制；\n\n二是主线程一直在处理其他耗时的消息，导致遍历绘制 View 树的工作迟迟不能开始，从而超过了 16.6 ms 底层切换下一帧画面的时机。\n\n三是内存抖动，导致的jvm频繁GC，引起的STW。\n"
      },
      {
        "title": "卡顿如何解决",
        "content": "这要根据实际情况来做处理了\n\n如果是主线程阻塞的原因，可以用TraceView，它可以看出代码在运行时的一些具体信息，方法调用时长，次数，时间比率，了解代码运行过程的效率问题。\n\n如果是内存引起的卡顿，可以通过leakcanary，看看是不是有内存泄漏啊，或是通过Memory Profiler看看对于一些大图的加载处理，是不是需要优化的。\n\n过度绘制，就直接使用系统的过度绘制检测就可以了，如果是蓝绿一层两层的就可以，红色就需要再优化优化。\n"
      },
      {
        "title": "APK体积优化",
        "content": "在APP中图片就占据了很大的一部分体积，所以图片的优化是我们要关注的重点。\n首先是图片格式，可以把UI同学给的图都过一遍，把png都转换webp(androidstudio自带covert to webp)或是压缩一遍，在不失真的情况下尽量压缩，还有些是可以用.9的图，就用.9来拉伸，这些都是很有效的。\n\n再有就是移除无用资源，可以通过Remove Unused Resources来查找出无用资源，或是用lint也行\n\n在gradle中打开代码压缩(minifyEnabled)、开启混淆压缩\n\n一些SO，也可以酌情精简，比如我们市场上基本都是使用基于armeabi的CPU架构（ABI），像微信、头条，都只保留了一套armeabi的so，所以我们也可以做些精简\n\n再有就是移除国际语言gradle中    defaultConfig{resConfigs 'en’}\n\n通过第三方框架来做资源混淆压缩啊等等（通过微信的开源的AndResGuard，资源混淆的原理是通过修改APK包里的resource.arsc文件，修改文件中的字符串池中的字符串，将其修改为简单短小的字符串，以此来减少文件大小）\n"
      },
      {
        "title": "LeakCanary原理",
        "content": "Leakcanary在初始化时会返回一个refWatcher监听器，他会注册一个callback来监听Activity的onDestroy方法。activity在执行onDestroy后需要被回收，监听机制将Activity包装到WeakReference中，被WeakReference包装过的Activity对象如果被回收，该WeakReference引用会被放到ReferenceQueue中。如果过5秒没有回收，监听机制会手动触发次GC，如果还没有被回收，那就说明Activity可能已经泄露。 这个时候就可以抓取内存dump文件来分析展示了。\n\nfragment监测流程和Activity相似，只不过是通过为FragmentManager注册Fragment生命周期回调，从而全局监听Activity中所有的Fragment的生命周期。"
      },
      {
        "title": "ANR是什么",
        "content": "ANR就是ApplicationNotResponding，应用无响应：\n\n当操作在一段时间内系统无法处理时，会在系统层面会弹出ANR对话框\n\n产生ANR可能是因为5s内无响应用户输入事件、10s内未结束BroadcastReceiver、20s内未结束Service\n\n想要避免ANR就不要在主线程做耗时操作，而是通过开子线程，具体方法比如使用Thread或Runnable接口、还有像AsyncTask、IntentService、HandlerThread都可以"
      },
      {
        "title": "如何监控ANR",
        "content": "可以通过命令，把/data/anr/trace（吹西死）文件pull到当前目录下，无需root权限即可获取，Input dispatching timed out，不过需要root\n\n或是通过继承FileObserver，来监测data/anr目录下文件的变化，但这种方式兼容性比较差，需要root获取系统权限，开发测试阶段还是很好用的\n\n还有一种是，ANR-WatchDog是参考Android WatchDog机制，起个单独线程向主线程发送一个修改变量和状态的操作，自我休眠，休眠过后判断变量是否变更完成，如果未完成则告警。但也无法保证能捕捉所有ANR，比如我的休眠时间和系统时间正好错过，我还没记录你已经报错退出了 ，那就无法捕捉。\n\n线上可以把ANR-WatchDog的阈值改成1秒，当有五次说明有anr发生了，把堆栈信息打下来就可以了，或是直接取4秒的堆栈信息"
      },
      {
        "title": "怎么解决ANR",
        "content": "想要避免ANR就不要在主线程做耗时操作，可以通过开子线程来完成，具体方法比如使用Thread或Runnable接口、还有像AsyncTask、IntentService、HandlerThread都可以"
      },
      {
        "title": "BlockCanary原理",
        "content": "blockcanary利用了主线程的消息队列处理机制\n\n通过就是Looper里setMessageLogging自定义一个 Printer，来获取主线程dispatch这个message的开始和结束时间\n\n并判定该时间超过阈值(如2000毫秒)为主线程卡慢发生，并dump出各种信息，提供开发者分析性能瓶颈。"
      },
      {
        "title": "内存泄漏原因及如何解决",
        "content": "单例造成的内存泄漏：单例生命周期和应用的生命周期一样长，单例对象还持有该对象的引用，就会使得该对象不能被正常回收，替换上下文applicationcontext\n\nHandler造成的内存泄漏:Activity结束时，未处理的消息持有handler的引用，而handler又持有它所属的外部类也就是Activity的引用。将Handler声明为静态内部类。因为静态内部类不会持有外部类的引用，所以不会导致外部类实例出现内存泄露。在Handler中添加对外部Activity的弱引用。用完后记得清空队列removeCallbacksAndMessages\n\n非静态内部类造成的内存泄漏:非静态内部类默认会持有外部类的引用，如果里面再有个静态实例或延时任务，就会出现泄漏\n\n资源未关闭造成的内存泄漏：对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，从而造成内存泄漏\n\n集合容器中的内存泄露:在退出程序之前，将集合里的东西clear，然后置空，让相关对象不再被引用"
      },
      {
        "title": "性能优化",
        "content": "性能优化：Android的性能优化，主要是从以下几个方面进行优化的：\n \n一是稳定性，是否有内存溢出、崩溃的情况\n\n二是流畅性，有没有卡顿，冷启动时间长不长\n\n三是耗损是否严重，耗电、流量多不多啊\n\n四是安装包体积等，有没有冗余可优化空间 \n\n\n内存优化\n1.使用leakcanery先解决程序中内存占用较大的业务模块中的内存泄漏\n2.移除程序中多余的代码和引用，这里使用默认的lint检测再配合shrinkResources来删除无效资源\n3.优化图片，保证图片放置在合理的文件夹，根据View大小加载合适的图片大小，根据手机状态配置bitmap和回收策略\n4.优化对象创建，比如string，使用对象池等\n\nAndroid官方对象池的简单实现：SimplePool，也是用得最多的实现\n原理：使用了“懒加载”的思想。当SimplePool初始化时，不会生成N个T类型的对象存放在对象池中。而是当每次外部调用release()时，才把释放的T类型对象存放在对象池中。要先放入，才能取出来。   这样就避免了内存抖动。\n\nMemory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。\n瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。\n"
      },
      {
        "title": "内存优化",
        "content": "1、可以在Androidmanifest文件中application节点加入android:largeHeap=“true”来增加其dalvik虚拟机中堆的大小\n\n2、解决内存泄漏的问题，像静态引用啊、单例啊什么的\n\n3、如果需要自己处理bitmap，要做好优化措施，比如预加载判断大小再压缩、配置低色彩的质量参数RGB_5665（默认ARGB_8888），将图片放在合理的资源目录下，尽可能保持和屏幕密度一致，放小的里反而多耗内存，不用的及时recycle()\n\n4、 修改对象引用类型，增强GC收回的效率\n\n5、其他还有些细节，比如增加复用，减少不必要的全局变量，少用枚举啊等等"
      },
      {
        "title": "bitmap优化",
        "content": "目前主流的图像加载库（Glide、Fresco等）基本上都不在需要开发者去关心Bitmap内存占用问题。但如果需要自己去处理，需要从适配、压缩、配置、回收等几个方面去关注bitmap的使用\n\n1、使用inJustDecodeBounds预判断Bitmap的大小及使用inSampleSize进行压缩（BitmapFactory.Options）\ninJustDecodeBounds：当 inJustDecodeBounds 为 true 时，执行 decodexxx 方法时，BitmapFactory 只会解析图片的原始宽高信息，并不会真正的加载图片\n\n2、加载Bitmap时，选择低色彩的质量参数（Bitmap.Config），如RGB_5665，这样相比默认的ARGB_8888，占用内存缩小一半。适用于对色彩多样性要求比较低的场景。（BitmapFactory.Options）\n\n3、将图片放在合理的资源目录下，尽可能保持和屏幕密度一致，放小的里反而多耗内存\n\n4、Bitmap自带的inBitmap内存复用机制，需要内存复用的Bitmap不能调用recycle()回收内存， 不用的要及时手动调用recycle()回收Bitmap的内存\n\n注：正确捕获OOM异常catch 的是 OutOfMemoryError，catch Exception是捕获不到OOM异常的\n\n\n\n//返回压缩图片\n public static Bitmap resizeBitmap(Context context, int id, int maxW, int maxH, boolean hasAlpha, Bitmap reusable) {\n\n        Resources resources = context.getResources();\n\n        BitmapFactory.Options options = new BitmapFactory.Options();\n        // 设置为true后，再去解析，就只解析 out 参数\n        options.inJustDecodeBounds = true;\n\n        BitmapFactory.decodeResource(resources, id, options);\n\n        int w = options.outWidth;\n        int h = options.outHeight;\n\n\n        options.inSampleSize = calcuteInSampleSize(w, h, maxW, maxH);\n\n        if (!hasAlpha) {\n            options.inPreferredConfig = Bitmap.Config.RGB_565;\n        }\n\n        options.inJustDecodeBounds = false;\n\n        // 复用, inMutable 为true 表示易变\n        options.inMutable = true;\n        options.inBitmap = reusable;\n\n\n        return BitmapFactory.decodeResource(resources, id, options);\n\n    }\n\n"
      },
      {
        "title": "扩大内存",
        "content": "Android为每个进程分配内存时，采用弹性的分配方式，即刚开始并不会给应用分配很多的内存，而是给每一个进程分配一个“够用”的内存大小。\n\nActivityManager的getLargeMemoryClass()可以获得开启largeHeap最大的内存大小\n通过ActivityManager的MemoryInfo，可以获取到应用最大使用内存大小getLargeMemoryClass()\n\n\n1、创建一个新的进程，那么我们就可以把一些对象分配到新进程的heap上了，从而达到一个应用程序使用更多的内存的目的，建议把一些高消耗但不常用的模块放到独立的进程，不使用的进程可及时手动关闭；void killBackgroundProcesses(String packageName)\n\n2、可以在Androidmanifest文件中application节点加入android:largeHeap=“true”来增加其dalvik虚拟机中堆的大小。开子进程，分担内存"
      },
      {
        "title": "APP启动过程",
        "content": "注（AMS是system_server中的一个进程）\n\n1、Launcher响应用户点击，通知AMS，需要启动一个应用\n\n2、AMS会检查这个应用程序所需要的进程是否存在，不存在就会请求Zygote进程启动需要的应用程序进程\n\n3、Zygote进程接收到AMS请求并通过fock自身创建应用程序进程，并执行ActivityThread的main方法\n\n4、然后App进程，通过Binder IPC向AMS进程发起attachApplication请求；\n\n5、AMS进程在收到请求后，进行一系列准备工作后，再通过Binder IPC向App进程发送handleBindApplication,也就是初始化Application并调用onCreate方法请求，和scheduleLaunchActivity创建启动Activity请求。\n\n6、App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；\n\n7主线程在收到Message后，通过反射机制创建目标Activity，并回调Activity.onCreate()等方法。到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。"
      },
      {
        "title": "App启动中涉及的模块及作用",
        "content": "ActivityManagerService：（AMS）AMS是Android中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。\n\nActivityThread：应用的入口类，通过调用main方法，开启消息循环队列。ActivityThread所在的线程被称为主线程；\n\nApplicationThread：ApplicationThread提供Binder通讯接口，AMS则通过代理调用此App进程的本地方法\n\nApplication：通过反射的方式创建了一个Application对象，并且调用了Appliction的attach()方法，而attach方法又调用了attachBaseContext方法，现在应该明白为什么该方法在Application的onCreate之前调用了。\n"
      },
      {
        "title": "计算启动时间",
        "content": "本地调试的话，直接一个命令就可以了，adb shell am start -W com.example.kotlin/com.example.kotlin.activity.MainActivity，其中有个TotalTime表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，本地用这个就可以了\n\n冷启动：\n在Application.attachBaseContext() 开始的位置记录就可以，因为在这之前 Context 还没有初始化， App 的具体业务逻辑还没开始执行。\n\n结束时间点：\n可以在 Activity.onWindowFocusChanged 记录应用启动的结束时间点，从onWindowFocusChanged被执行起，用户可以与应用进行交互了，真正的visible时间点。如果后面有焦点变化，也会调这个方法，需要区分好。\n\n热启动启动时间点：\n可以在 Activity.onRestart() 中记录起始时间点。\n\n统计线上应用的话，就需要打点了，起始时间点比较容易记录："
      },
      {
        "title": "APP启动优化",
        "content": "1、在application中配置一个theme，在style中定义广告页或默认图，让用户先看默认图。\n\n2、在Application和activity初始化的时候，把耗时操作放到子线程中进行，非必要的功能可以懒加载，还有布局层次也要减少"
      },
      {
        "title": "启动过程中方法调用顺序",
        "content": "-> Application 构造函数\n\n-> Application.attachBaseContext()\n\n-> Application.onCreate()\n\n-> Activity 构造函数\n\n-> Activity.setTheme()\n\n-> Activity.onCreate()\n\n-> Activity.onStart\n\n-> Activity.onResume\n\n-> Activity.onAttachedToWindow\n\n-> Activity.onWindowFocusChanged"
      },
      {
        "title": "程序保活拉活方案",
        "content": "1、创建个1像素activity保活或是创建个前台 Service 保活\n手机关闭屏幕时（注册个广播来监控关闭屏幕ACTION_SCREEN_ON / OFF\n），偷偷创建一个Activity，让应用成为前台进程；打开屏幕时，关闭该Activity。\n\n2、广播拉活\n在开机，网络切换、拍照发生特定系统事件时候，利用系统产生的广播唤醒app，系统会发出广播，通过在 AndroidManifest 中静态注册对应的广播监听器，即可在发生响应事件时拉活。但是从android 7.0开始，对广播进行了限制，而且在8.0更加严格\n\n3、通过守护进程拉活\n两个进程共同运行，如果有其中一个进程被杀，那么另一个进程就会将被杀的进程重新拉起，相互保护，在一定的意义上，维持进程的不断运行。这里还要用到 AIDL， 进行两个进程间的交互。\n\n当onServiceDisconnected方法被调用时，说明对方断开了连接，基本上是对方进程挂了，然后就将其启动起来就行了。如果系统杀死进程所花的时间比你拉活逻辑的时间要久，那你的拉活还是能成功的\n\n4、JobSchedule 机制拉活\nJobSchedule 允许在特定状态与特定时间间隔周期执行任务。我们可以利用它的这个特点来完成保活功能，效果就像开启一个定时器，与普通定时器不同的是其调度由系统来完成。\n\n5、还有根据不同品牌手机，进行账号拉活\n手机系统设置里会有Account帐户一项功能，任何第三方APP都可以通过此功能将我们自己的APP注册到这个Account帐户中，并且将数据在一定时间内同步到服务器中去。系统在将APP帐户同步时，自动将未启动的APP进程拉活，\n\n\n总结：没有一种方式是能够保证你的应用一直存活在内存中的，但是能延长时间也很不错了。\n系统会优先杀死占用内存多的应用，所以想让自己的应用活的更久，还可以从性能上去优化，让其尽可能少的占用内存。"
      },
      {
        "title": "线上卡顿分析",
        "content": "通常有两种方法，可以监控卡顿\n\n一、线下方法，通过使用blockcanary来利用主线程消息列队处理机制，通过setMessageLogging能够得到分发一条消息所花的时间。\n\n监听到发生卡顿之后，dispatchMessage 早已调用结束，已经出栈，此时再去获取主线程堆栈，堆栈中是不包含卡顿的代码的。所以需要在后台开一个线程，定时获取主线程堆栈，将时间点作为key，堆栈信息作为value，保存到Map中，在发生卡顿的时候，取出卡顿时间段内的堆栈信息即可。\n\n带来的问题1、线程频繁获取主线程堆栈，对性能有一定影响，获取主线程堆栈，会暂停主线程的运行。\n带来的问题2、存在字符串拼接，频繁调用，会创建大量对象，造成内存抖动。\n\n\n二、微信Matrix\n还有一种方案就是通过字节码插桩，这种是通过Gradle Plugin+ASM TASK，编译期在每个方法开始和结束位置分别插入一行代码，统计方法耗时，\n\n这种方案体积会略微增长、帧率也会略有下降，适用于灰度体验"
      },
      {
        "title": "线上内存监控",
        "content": "线上监控内存泄漏的话，可以参考快手koom他们提供的一种方案，\nKOOM 提出了 fork dump 的概念，能在 dump 分析内存泄漏的时候而不影响到主进程的应用运行，所以，非常适合使用在线上监控。\n\n首先，监控的触发时机不同，LeakCanary 和 Matrix 都是在 Activity.onDestroy 时触发泄漏检测，KOOM 是用阈值检测法来触发。是一个利用 HandlerThread 不停在轮训监控当前内存状态：\n1、当前已使用内存是否达到最大阈值（变量可配），如果超过的话，则直接触发\n2、还有种策略是如果内存占比持续增大，连续记录3次，也会触发\n\n第二，常规的dump是通过虚拟机提供的 API dumpHprofData实现的，这个过程会 “冻结” 整个应用进程。KOOM 使用 fork dump 操作，从当前主进程 fork 出一个子进程，由于 linux 的 copy-on-write 机制，子进程和父进程共享的是一块内存，那么我们就可以在子进程中进行 dump 堆栈，不影响主进程的运行。"
      },
      {
        "title": "anr watch dog",
        "content": "开启一个线程，死循环，循环中睡眠5s\n\n往UI线程post 一个Runnable，将_tick 赋值为0，将 _reported 赋值为false\n\n线程睡眠5s之后检查_tick和_reported字段是否被修改\n\n如果_tick和_reported没有被修改，说明给主线程post的Runnable一直没有被执行，也就说明主线程卡顿至少5s**（只能说至少，这里存在5s内的误差）**。\n\n将线程堆栈信息输出"
      },
      {
        "title": "webview加载过程",
        "content": "1）Webview初始化。\n\n2）到达新的页面，网络连接，从服务器下载html，css，js，页面白屏。\n\n3）页面基本框架出现，js请求页面数据，页面处于loading状态。\n\n4）出现所需的数据，完成整个页面的渲染，用户可交互。"
      },
      {
        "title": "webview优化",
        "content": "1、第一次加载Webview内核，这是一个重量级的操作，内核是以apk的形式存在我们可以在App生成一个全局webview，并且在启动时初始化，这样在后面使用时通过动态获取这个全局Webview，然后添加到rootview中\n\nWebView mWebView = new WebView(this); //可以放到application中去，用单例的方式去初始化。\n\n\n2、资源本地化，在webview的加载过程中，我们通过重写方法 shouldInterceptRequest 可以拦截到不同的请求，只需要把一些常用的资源如cs、js、还有图片文件使用本地的资源，这样减少了重复请求的时间，优化了webview的加载时间\n\nif (url.endsWith(\"icon.png\")) {\n           InputStream is = appRm.getInputStream(R.drawable.icon);\n           WebResourceResponse response = new WebResourceResponse(\"image/png\",\n             \"utf-8\", is);\n           return response;\n       } else if (url.endsWith(\"jquery.min.js\")) {\n           InputStream is = appRm.getInputStream(R.raw.jquery_min_js);\n           WebResourceResponse response = new WebResourceResponse(\"text/javascript\",\n             \"utf-8\", is);\n           return response;\n       }\n\nappRm为app资源管理器，读取drawable，assets，raw下的资源，都是android系统的一些很简单的函数调用。\n\n\n3、开启WebView的缓存功能可以减少对服务器资源的请求，一般使用默认缓存策略就可以了。如果缓存没过期就使用缓存\n\n//设置 缓存模式 \nwebView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT);  \n// 开启 DOM storage API 功能 \nwebView.getSettings().setDomStorageEnabled(true); \n\n\n4、WebView有一个setBlockNetworkImage(boolean)方法，该方法的作用是是否屏蔽图片的加载。可以利用这个方法来实现图片的延迟加载：在onPageStarted时屏蔽图片加载，在onPageFinished时开启图片加载。\n\n\n5、本地离线包的形式\nwebview 可以加载网络资源，那么也是可以加载本地的资源，在apk 启动的时候，我们可以把整个前端代码文件下载解压到本地的文件路径中，然后通过file：///...index.html 去打开本地的资源\n"
      }
    ]
  },
  {
    "name": "view与显示",
    "data": [
      {
        "title": "屏幕适配方案",
        "content": "1、在布局文件中写view宽高可以多用 wrap_content,match_parent，让view自适应，用权重weight来替代固定值，距离单位用dp，字体单位用sp，\n\n2、自适配图片，也就是在res下的选择相应的dpi，没特殊需求的话推荐xxdpi，1080*1920，这样就可以满足向上向下兼容，节省空间\n\n3、如果有指定需求，可以创建指定的分辨率资源进行适配，手机会根据分辨率去找设定的资源，比如layout的布局，layout-800 * 480，  value-1080*1920\n\n了解 —> 还有一种是修改手机的设备密度 density，他是通过appDisplayMetrics.density动态设置，来使不同分辨率，来实现UI样式统一，不过这种方式只能一刀切的将整个项目进行适配，但适配范围是不可控的，一般不用。"
      },
      {
        "title": "事件分发流程",
        "content": "Android的UI界面由Activity、ViewGroup、View 及其派生类组成，1个点击事件发生后，如果我们没有对控件里面的方法进行重写或更改返回值，而直接用super调用父类的默认实现，该事件会先传到Activity、再传到ViewGroup、最终再传到 View，再从最底层开始往上传，那这个传递模型就类似于一个U型。\n\n其中共涉及3个方法，分发方法dispachTouchEvent、拦截onIntercepteorTouchEvent、处理onTouchEvent。其中分发和处理是三层都有的，拦截方法是ViewGrop独有的。\n\n分发方法不处理会给到下一层或下一个方法处理，而它返回true和false都和处理方法一样，直接消费或是给到上一级的处理方法。\n\n而拦截方法返回true会给到本层的onTouchEvent处理,false和默认方法都不拦截，会向下走。\n\n\nonclick事件中，有两个因素会影响点击，一是onTouch事件返回的结果result，还有就是是否有listener来响应，onTouch方法返回false才会执行onclick"
      },
      {
        "title": "action_move、action_up、cancel",
        "content": "ACTION_DOWN事件在哪个控件消费了（return true）， 不管他是传到底层返上来的，还是直接拦截在这一层消费的，那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）直接传到这一层，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。\n\n在ViewGroup源码中使用了一个全局变量mFirstTouchTarget来记录是否有View处理了Down事件。mFirstTouchTarget默认为null，如果发现了View可以处理，那么就会把mFirstTouchTarget的值设置为对应的View。那么随之而来的Down和Up都会交给该View处理，（mFirstTouchTarget为单链表结构）\n\n\n如果某一个子View处理了Down事件，那么随之而来的Move和Up事件也会交给它处理。但是交给它处理之前，父View还是可以拦截事件的，如果拦截了事件，那么子View就会收到一个Cancel事件，并且不会收到后续的Move和Up事件。"
      },
      {
        "title": "mFirstTouchTarget为什么是链表结构",
        "content": "因为链表结构更适合添加touchTarget\n\n多指触控时。第一根按下的手指触发ACTION_DOWN事件,之后按下的手指触发ACTION_POINTER_DOWN事件。\n\n所以当有多指进行触控的时候，addTouchTarget方法可能会被调用多次，mFirstTouchTarget以链式结构存储对应的view。"
      },
      {
        "title": "滑动冲突解决方案",
        "content": "1、可以考虑从父布局的拦截方法onInterceptTouchEvent来处理，如果需要拦截返回true.\n\n2、如果不修复父布局，可以当前view.getParent().requestDisallowInterceptTouchEvent(true/false);如果传true表示父布局不做处理\""
      },
      {
        "title": "getX、getRawX、getTranslationX区别",
        "content": "getX()是表示触摸点距离自身view左边的距离。\n\ngetRawX()表示的是触摸点距离屏幕左边界的距离\n\nView.getWidth():表示的是当前控件的宽度\n\nView.getTranslationX()计算的是该View在X轴的偏移量。初始值为0，向左偏移值为负，向右偏移值为正。"
      },
      {
        "title": "自定义View的流程",
        "content": "介绍下实现一个自定义View的基本流程\n①.自定义View的属性 编写attr.xml文件 ②.在layout布局文件中引用，同时引用命名空间 ③.在View的构造方法中获得我们自定义的属性 ，在自定义控件中进行读取（构造方法拿到attr.xml文件值） ④.重写onMesure 、onDraw    如果有需要还可以重写onTouchEvent"
      },
      {
        "title": "view的绘制流程",
        "content": "view的绘制是从根视图 ViewRoot 的 performTraversals() 方法开始，从上到下遍历整个视图树，具体操作是分发给 ViewGroup 的，ViewGroup 通过遍历自身所有的子 View，并逐个调用子 View 的 measure、layout、draw 方法实现测量、定位、绘制操作。\n\n如果想自定义View的测量，需要重写onMeasure()方法，我们可以通过mesureSpec获取到view的尺寸，改写过后还需要调用setmeasuredimension方法来配置他的宽高。(布局文件是warp，但我们想改成固定值就可以用onMesure)\n\nlayout的作用就是为整个View树计算实际的位置，他和mesure一样，需要递归的去计算每一个子视图的位置。如果需要重写，可以调用onLayout方法，要传入标识，还有左上右下这4个相对于父view的距离参数。\n\ndraw作用就是绘制View 的背景、子View、还有前景跟滚动条等。还有一个onDraw空方法，自定义View的话需要重写，在里面绘制自己需要添加的内容"
      },
      {
        "title": "介绍下SurfaceView",
        "content": "SurfaceView在单独线程中进行绘图，有独立的绘图表面。适用于界面频繁更新、对帧率要求较高的情况。像相机预览、地图之类的都可以使用。\n\nSurfaceView可以控制刷新频率。\nSurfaceView底层利用双缓存机制，绘图时不会出现闪烁问题。双缓冲技术是游戏开发中的一个重要的技术，主要是为了解决 反复局部刷屏带来的闪烁，surfaceView是通过surfaceHolder.lockCanvas锁定画布，实现下一张图片的绘制，再通过另外的线程刷新界面，绘制图片。\nView是直接在ondraw里绘制图片，刷新界面。\n\nView适用主动更新，SurfaceView 适用被动更新"
      },
      {
        "title": "SurfaceView的使用",
        "content": "首先要继承SurfaceView，实现SurfaceHolder.Callback接口。\n\n重写方法：\nsurfaceChanged：surface大小或格式发生变化时触发，在surfaceCreated调用后该函数至少会被调用一次。\nsurfaceCreated：Surface创建时触发，一般在这个函数开启绘图线程（新的线程，不要再这个线程中绘制Surface）。\nsurfaceDestroyed：销毁时触发，一般不可见时就会销毁。\n\n利用getHolder()获取SurfaceHolder对象，调用SurfaceHolder.addCallback添加回调\n\nSurfaceHolder.lockCanvas 获取Canvas对象并锁定画布，调用Canvas绘图，SurfaceHolder.unlockCanvasAndPost 结束锁定画布，提交改变。"
      },
      {
        "title": "长图的加载",
        "content": "1、Glide+SubsamplingScaleImageView混合加载渲染\n\n2、要是自定义的话，需要用BitmapRegionDecoder来实现对图片的局部加载，重写onTouchEvent，在里面根据用户移动的手势，去更新显示区域的参数，每次更新区域参数后，调用invalidate，onDraw里面去regionDecoder.decodeRegion拿到bitmap，去draw\n\nBitmapRegionDecoder bitmapRegionDecoder =   BitmapRegionDecoder.newInstance(inputStream, false);\nBitmap bitmap = bitmapRegionDecoder.decodeRegion(new Rect(width / 2 - 100, height / 2 - 100, width / 2 + 100, height / 2 + 100), options);\nmImageView.setImageBitmap(bitmap);"
      },
      {
        "title": "activity页面构成",
        "content": "Activity 包含了一个管理窗口的继承至 Window 的 PhoneWindow 对象\n\n而在 PhoneWindow 中创建了一个继承至 FrameLayout 类的 DecorView 对象\n\u2028并且把包含了ActionBar、TitleBar和Content的布局文件通过 addView() 方法添加到了DecorView 中\n\n当开发者定义了layout.xml布局并调用了 setContentView() 方法时，就是将自定义的布局加载到了DecorView 中表示  content 的部分\n\n（setContentView() 部分具体过程同 【setContentView() 方法过程总结】）。"
      },
      {
        "title": "回调中获取view的宽高",
        "content": "View的宽高是在onLayout阶段才能最终确定的，Activity的声明周期与View的绘制流程并不是一一绑定的。通过post，队列中会包含一条询问是否完成布局的消息，而我们的任务通过View#post方法被添加到队列尾部\n\nmButton.post(new Runnable() {\n @Override\u2028  \n     public void run() {\u2028 \n        Log.e(TAG, \"宽度：\" + mButton.getWidth());\u2028\u2028 \n }"
      },
      {
        "title": "如何统计帧率",
        "content": "一、可以利用Choreographer的doFrame方法，我们屏幕的刷新，都会触发这个方法，可以在这个方法中，去做计数统计的逻辑\n\n\n1、实现Choreographer.FrameCallback接口，比如实现类是FrameSkipMonitor\n2、在doFrame中统计两帧绘制的时间，代码与注释如下：\n\n@Override\npublic void doFrame(long frameTimeNanos) {\nif (mLastFrameNanoTime != 0) {//mLastFrameNanoTime 上一次绘制的时间\nlong frameInterval = frameTimeNanos - mLastFrameNanoTime;//计算两帧的时间间隔\n\n\n二、还有一种方法，是通过设置中的GPU呈现模式分析，里面可以通过命令行，导出每一帧的耗时等信息text。"
      }
    ]
  },
  {
    "name": "动画",
    "data": [
      {
        "title": "帧式动画",
        "content": "1、在res/drawable目录下定义一个XML文件，根节点为系统提供的animation-list，然后放入定义更好的图片；\nandroid:oneshot true：只播放一次，false：循环播放。\nandroid:duration=\"100\"：相隔两张图片播放时间间隔。单位/毫秒。\n\u20282、使用AnimationDrawable在代码中调用start()以及stop()开始或停止播放动画。（在layout中，用imageview显示，然后代码中调animationDrawable = (AnimationDrawable) imageView.getBackground()获取实例来控制动画）\n\n<ImageView\n        android:id=\"@+id/img_show\"\n        android:background=\"@drawable/start_show\" />\n\nimageView = findViewById(R.id.img_show);\nanimationDrawable = (AnimationDrawable) imageView.getBackground();\u2028animationDrawable.start();\nanimationDrawable.stop();\n\n缺点就是图片非常占内存，损耗大"
      },
      {
        "title": "补间动画",
        "content": "补间动画有4种类型，平移TranslateAnimation，旋转RotateAnimation，透明度AlphaAnimation，缩放ScaleAnimation。补间动画不会改变View的属性,只会改变显示效果.\n\n可以理解在每一次VSYN到来时 在View的draw方法里面 根据当前时间计算动画进度 计算出一个需要变换的Transformation矩阵 然后最终设置到canvas上去 调用canvas concat做矩阵变换.\n\n\nTranslateAnimation translateAnimation = new TranslateAnimation(0, 200, 0, 0);\ntranslateAnimation.setDuration(2000);\nview.startAnimation(translateAnimation);"
      },
      {
        "title": "属性动画介绍",
        "content": "ValueAnimator是整个属性动画机制当中最核心的一个类，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值。\n\n缺点：就是只能对数值计算。要是想对哪个控件操作，需要监听动画过程（通过 addUpdateListener 的监听方法），在监听中对控件操作。这样使用比较麻烦。\n\n而ObjectAnimator就在 ValueAnimator的基础上又做了一层封装,重写了ofInt() ofFloat() ofObject() ofArgb()等方法，可以直接传入view控件，并传入控件的set对应函数名称，拼装成对应的set函数就能实现动画效果，所以用ObjectAnimator来实现动画会更容易些。"
      },
      {
        "title": "ValueAnimator",
        "content": "主要的三种方法：\n \na) ValueAnimator.ofInt(int values)：估值器是整型估值器IntEaluator\n \nb) ValueAnimator.ofFloat(float values):估值器是浮点型估值器FloatEaluator\n \nc) ValueAnimator.ofObject(ObjectEvaluator, start, end):将初始值以对象的形式过渡到结束值，通过操作对象实现动画效果，需要实现Interpolator接口，自定义估值器  \n\n还有ofArgb()修改颜色的，ofPropertyValuesHolder()自定义封装动画\n\nValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);\nanim.setDuration(300);\nanim.start();\n\n可以传入任意多个参数的比如说将一个值在5秒内从0过渡到5，再过渡到3，再过渡到10，就可以这样写：\n\nValueAnimator anim = ValueAnimator.ofFloat(0f, 5f, 3f, 10f);\n\n我们还可以调用setStartDelay()方法来设置动画延迟播放的时间，调用setRepeatCount()和setRepeatMode()方法来设置动画循环播放的次数以及循环播放的模式，循环模式包括RESTART和REVERSE两种，分别表示重新播放和倒序播放的意思。\n\n期间每次赋值都会调用invalidate()不断刷新视图，即调用onDraw()重新绘制视图；每次绘制视图便实现了动画效果。"
      },
      {
        "title": "ObjectAnimator",
        "content": "ObjectAnimator动画原理：根据属性值拼装成对应的set函数的名字，比如”alpha”的拼接方法就是将属性的第一个字母强制大写后，与set拼接，也就是setAlpha,然后通过反射找到对应控件的setAlpha(float alpha)函数，将当前数字值作为setAlpha(float alpha)的参数将其传入。属性值得首字母大小写都可以，最终都会被强转成大写。View中都已经实现了相关的alpha rotation translate scale相关的set方法。\n\nObjectAnimator的动画设置流程:ObjectAnimator需要指定操作的控件对象，在开始动画时，到控件类中去寻找设置属性所对应的set函数，然后把动画中间值做为参数传给这个set函数并执行它。 \n\nObjectAnimator只负责把当前运动动画的数值传给set函数。至于set函数里面怎么来做，是我们自己的事了。 \n\n如果我们想要将一个TextView在5秒中内从常规变换成全透明，再从全透明变换成常规\n\nObjectAnimator animator = ObjectAnimator.ofFloat(textview, \"alpha\", 1f, 0f, 1f);\nanimator.setDuration(5000);\nanimator.start();\n\n除此之外，还有alpha-透明度，rotation-旋转，translationX-偏移，scaleY-放大"
      },
      {
        "title": "AnimatorSet",
        "content": "AnimatorSet是Animator的子类，实现组合动画功能主要需要借助AnimatorSet这个类,\n\n \nAnimatorSet.play(Animator anim)   ：播放当前动画\n\nAnimatorSet.before(Animator anim) ：  将现有动画插入到传入的动画之前执行\n\nAnimatorSet.with(Animator anim)   ：将现有动画和传入的动画同时执行\n\nAnimatorSet.after(Animator anim)   ：将现有动画插入到传入的动画之后执行\n\nAnimatorSet.after(long delay)   ：将现有动画延迟x毫秒后执行\n\nAnimatorSet.playTogether(animA, animB)   ：AB动画共同执行\n\n\nrotate、fadeInOut、moveIn为ObjectAnimator动画对象使用方法如下:\n\nAnimatorSet animSet = new AnimatorSet();\nanimSet.play(rotate).with(fadeInOut).after(moveIn);\nanimSet.setDuration(5000);\nanimSet.start();"
      },
      {
        "title": "PropertyValuesHolder",
        "content": "PropertyValuesHolder的意义就是保存动画过程中所需要的属性和值，其实ofInt()和ofFloat()的内部实现就是通过封装PropertyValuesHolder实例来保存动画状态的。\n\n可以理解PropertyValuesHolder实例就是一个动画，与view当作参数，共同放进ObjectAnimator.(view,ofPropertyValuesHolder实例)来使用\n\n\nPropertyValuesHolder colorHolder = PropertyValuesHolder.ofInt(\"BackgroundColor\", 0xffffffff, 0xffff00ff, 0xffffff00, 0xffffffff);\nPropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(\"Rotation\", 60f, -60f, 40f, -40f, -20f, 20f, 10f, -10f, 0f);\n\nObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTextView, rotationHolder, colorHolder);\nanimator.setDuration(3000);\nanimator.setInterpolator(new AccelerateInterpolator());\nanimator.start();"
      },
      {
        "title": "TypeEvaluator估值器",
        "content": "TypeEvaluator就是告诉动画系统如何从初始值过度到结束值，比如坐标点的估值器，我们就是通过把初始和结束坐标点转成point对象，然后根据决定值fraction来计算当前动画的x和y的值，最后组装到一个新的Point对象当中并返回\n\n用法：自定义类，实现TypeEvaluator接口并重写了evaluate()方法，\n\n以下代码逻辑，先是将startValue和endValue强转成Point对象，然后同样根据fraction来计算当前动画的x和y的值，最后组装到一个新的Point对象当中并返回\nclass PointEvaluator{\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n        Point startPoint = (Point) startValue;\n        Point endPoint = (Point) endValue;\n        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());\n        float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());\n        Point point = new Point(x, y);\n        return point;\n    }\n}\nValueAnimator.ofObject(new PointEvaluator(), point1, point2)\n"
      },
      {
        "title": "Interpolator插值器",
        "content": "可以通过setInterpolator()   来给动画添加插值器\n\nanim.setInterpolator(new BounceInterpolator());\n\n有线性、加速、减速、周期、弹跳、先加速后减速，其他还有几个是偏移越大，而且速度越快，记不太清了。\n\nLinear Interpolator / 线性插值器\nAccelerate Interpolator / 加速度插值器\nDecelerate Interpolator / 减速插值器\nAccelerate Decelerate Interpolator / 先加速后减速插值器\nBounce Interpolator / 弹跳插值器\nCycle Interpolator / 周期插值器"
      },
      {
        "title": "属性动画监听种类",
        "content": "addListener可以添加四种监听,有开始、重复、取消、结束\n\nanimator.addListener(new AnimatorListener() {\n          @Override\n          public void onAnimationStart(Animation animation) {\n              //动画开始时执行\n          }\n      \n           @Override\n          public void onAnimationRepeat(Animation animation) {\n              //动画重复时执行\n          }\n \n         @Override\n          public void onAnimationCancel()(Animation animation) {\n              //动画取消时执行\n          }\n    \n          @Override\n          public void onAnimationEnd(Animation animation) {\n              //动画结束时执行\n          }\n      });"
      },
      {
        "title": "估值器与插值器的区别",
        "content": "估值器TypeEvalutor，设置动画如何从初始值过渡到结束值的逻辑，以及明确决定值的具体变化数值是多少\n\n插值器Interpolator，辅助动画的运动规律，决定值的变化模式（匀速、加速等）"
      }
    ]
  },
  {
    "name": "第三方控件与框架",
    "data": [
      {
        "title": "介绍下JetPack",
        "content": "Jetpack是Goolge推出的一套组件库，目的是让开发者能够使用标准的架构组件，而不用去纠结架构的方案设计，可以将更多的精力放在自己的业务代码上。 主要包括 4 个方面。\n\n架构（Architecture）常用的有：databinding、lifecycles、viewmodel\n\n界面（UI）常用的有：Animation动画、emoje表情、fragment、layout\n\n行为（behavior）有：AppCompat（依赖库）、mutidex（short类型的范围65535解决方案，DexPathList）\n\n基础（foundation）有：media多媒体、permission权限"
      },
      {
        "title": "如何捕捉异常",
        "content": "Exception分为两类：一种是CheckedException，一种是UncheckedException，如果是CheckedException，可以用try\\catch来捕捉，如果是运行时异常，可以自定义一个工具类，实现UncaughtExceptionHandler接口，然后在application中初始化，用这个工具来捕获unchecked异常。里面需要重写一个uncaughtException方法，在里面完成错误信息收集，发送错误报告等操作"
      },
      {
        "title": "RecyclerView 与 ListView 的区别",
        "content": "一. RecyclerView多了一些LayoutManager工作，但实现了布局效果多样化\n1、ListView 的布局比较单一，只有一个纵向效果。\n2、RecyclerView 可以在LayoutMananger中设置：线性布局（纵向，横向），表格布局，瀑布流布局\n\n二.一些常用功能的api不同，比如 Listview可以通过addHeaderView() 与 addFooterView()来添加头部item与底部item，但RecyclerView需要在Adapter中自己编写。还有Listview有onItemClickListener、onItemLongClickListener(),但RecyclerView需要通过addOnItemTouchListener或在item中实现。其他还有Listview没有局部刷新（notifyItemChanged），setTag()、getTag()等。\n\n三.ViewHolder的编写规范化，ListView是需要自己定义的，而RecyclerView是规范好的\n\n四.RecyclerView有嵌套滚动机制，但Listview没有：\n在事件分发机制中，Touch事件在进行分发的时候，由父View向子View传递，一旦子View消费这个事件的话，那么接下来的事件分发的时候，父View将不接受，由子View进行处理；但是与Android的事件分发机制不同，嵌套滚动机制（Nested Scrolling）可以弥补这个不足，能让子View与父View同时处理这个Touch事件，主要实现在于NestedScrollingChild与NestedScrollingParent这两个接口；而在RecyclerView中，实现的是NestedScrollingChild，所以能实现嵌套滚动机制；"
      },
      {
        "title": "recyclerview复用机制",
        "content": "每次创建ViewHolder的时候，会按照优先级依次查询缓存创建ViewHolder。每次讲ViewHolder缓存到Recycler缓存的时候，也会按照优先级依次缓存进去\n\n一级缓存：返回布局和内容都都有效的ViewHolder\n按照position或者id进行匹配\n\n二级缓存：返回View\n按照position和type进行匹配\n\n三级缓存：返回布局有效，内容无效的ViewHolder\n按照type进行匹配，每个type缓存值默认=5\n"
      },
      {
        "title": "ButterKnife作用及原理",
        "content": "编译代码时，butterKnife会扫描Java代码中所有的ButterKnife注解@Bind、@OnClick、@OnItemClicked这些类，然后ButterKnifeProcessor会帮你生成一个Java类，这个ViewBinder类中包含了所有对应的代码，比如@Bind注解对应findViewById(), @OnClick对应了view.setOnClickListener()等等 。我们会调用ButterKnife.bind(this)，动态注入所有的注解过的View属性和click方法\n\n有个Zelezny插件，可以针对布局所有子view一键声明，很好用，推荐使用\n\n@BindView(R.id.login_btn_login)\nButton btn_login;\n\n@OnClick({R.id.login_btn_login})   \npublic void onViewClicked(View view) {   //xml不需要去写\n        switch (view.getId()) {\n            case R.id.login_btn_login:\n    ……\n                break;\n            default:\n                break;\n        }\n    }\n"
      },
      {
        "title": "Glide优点与原理",
        "content": "glide最大的优势就是对bitmap的管理是跟随生命周期发生改变的。当Activity销毁的时候，之前加载的所有图片的内存都释放了。其它的框架基本都是用Lru算法，当Activity销毁的时候，是不会释放之前加载图片占用的所有内存。\n\n当我们用glide进行加载时，它创建一个无UI的Fragment，并绑定到通过glide.with(context)传进来的Activity上，这样Fragment就可以感知Activity的生命周期了。RequestManager是用来加载、管理图片请求的，它会通过传入的Lifecycle对象，监听到Fragment的生命周期，从而根据生命周期管理让Request做出相对应的处理了。"
      },
      {
        "title": "Glide缓存",
        "content": "内存缓存主要用于防止将重复的图读入内存中，硬盘缓存则用于防止从网络或者其他地方将重复下载和数据读取\n\n\n一、内存\n查找顺序：先从LruResourceCache中查找，找到了移除并添加到activeResources（弱引用 ）中，找不到再从activeResources（弱引用）中查找。\n\n引用逻辑acquired:acquired()方法让其+1，release()方法让其-1，经过acquired()方法使acquired>0在activeResources中存储，然后不再使用调用release()方法使acquired==0被activeResources移除并且put到LruResourceCache中\n\n\n二、磁盘\n优先读取优化后的图片，读取不到再读取原图\nDiskCacheStrategy.RESULT： 表示只缓存转换过后的图片（默认选项）。\n\n\n缓存key：决定缓存key的参数有十几个(包括url，宽，高，signature等等)\n\nandroid 4.4以前是Bitmap复用必须长宽相等才可以复用，而android 4.4及以后是Size>=所需就可以复用，只不过需要调用reconfigure来调整尺寸"
      },
      {
        "title": "类加载方案",
        "content": "虚拟机加载类的时候都需要ClassLoader,ClassLoader有一个子类BaseDexClassLoader，而BaseDexClassLoader下有一个\n \n数组——DexPathList，是用来存放dex文件，当BaseDexClassLoader通过调用findClass方法时，实际上就是遍历数组，\n \n找到相应的dex文件，找到，则直接将它return。而热修复的解决方法就是将新的dex添加到该集合中，并且是在旧的dex的前面，\n \n所以就会优先被取出来并且return返回。\n\nQQ空间超级补丁和Nuwa用的就是这种\n\n微信tinker是新旧apk做diff，得到path.dex再与手机原本的dex合并，生成新的class.dex，然后再反射将此dex放在第一个元素。bsdiff可以得到两个不同文件中的不同信息，旧文件+新文件=差分文件\nbspatch：旧文件+差分文件=新文件\n\n优点：补丁包较小，支持资源替换\n缺点：需要重启才能生效。"
      },
      {
        "title": "底层替换方案",
        "content": "底层替换方法，不会从新加载类，限制较多，不能增减原有类的方法和字段，是及时生效的\n\n原理是直接在native层，通过反射替换方法入口，或者整个方法体。\n\n阿里Andfix用的就是这种方案\n\n优点：立即生效，消耗低。\n缺点：仅支持方法的替换。"
      },
      {
        "title": "instantRun方案",
        "content": "原理是每个类都增加一个静态变量，在每个方法执行前，判断此变量是否发生变化，变化了执行新的类中方法\n\n像美团的Robust为每个class增加了个类型为ChangeQuickRedirect的静态成员，而在每个方法前都插入了使用changeQuickRedirect相关的逻辑，当 changeQuickRedirect不为null时，可能会执行到accessDispatch从而替换掉之前老的逻辑，达到fix的目的。替换的方式也是通过反射将changeQuickRedirect的值赋为补丁对象完成补丁加载操作。\n\n优点：兼容性高，开发透明；实时生效。\n缺点：会增大方法数，影响运行效率，不支持资源替换。\n\n了解 --> 当应用获取到加载补丁后，会创建DexClassLoader加载补丁，每个补丁有被修复的类信息及该类对应的补丁信息。通过被修复的类信息找到该类，反射将changeQuickRedirect的值赋为补丁对象完成补丁加载操作。"
      },
      {
        "title": "RxJava的基础使用",
        "content": "Rxjava的特点，由于其基于事件流的链式调用、逻辑非常简洁，非常适合于复杂异步的问题处理\n\n\n   创建被观察者，产生事件\n设置事件传递过程中的过滤，合并，变换等加工操作。\n订阅一个观察者对象，实现事件最终的处理。\n\nObservable.create(new ObservableOnSubscribe<Integer>() {\n\n    @Override\n    public void subscribe(@NonNull ObservableEmitter<Integer> emitter) throws Throwable {\n        emitter.onNext(1);\n        emitter.onNext(2);\n        emitter.onNext(3);\n        emitter.onComplete();\n    }\n}).subscribe(new Observer<Integer>() {\n    @Override\n    public void onSubscribe(@NonNull Disposable d) {\n        Log.d(TAG, \"onSubscribe:\" + d.getClass().getName());\n    }\n\n    @Override\n    public void onNext(@NonNull Integer integer) {\n        Log.d(TAG, \"onNext: \" + integer);\n    }\n\n    @Override\n    public void onError(@NonNull Throwable e) {\n        Log.d(TAG, \"onError: \" + e.getMessage());\n    }\n\n    @Override\n    public void onComplete() {\n        Log.d(TAG, \"onComplete\");\n    }\n});\n"
      },
      {
        "title": "RxJava线程切换",
        "content": "线程切换\n\nRxJava 默认，事件的发出和消费都是在同一个线程的。\u2028\n在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）\n\nSchedulers.immediate(): 直接在当前线程运行，相当于不指定线程。默认 Scheduler。\nSchedulers.newThread(): 总是启用新线程，并在新线程执行操作。\nSchedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler\nSchedulers.computation(): 计算所使用的 Scheduler。\n另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，\n\nObservable<String> observable = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> e) throws Exception {\n               …\n            }\n        })\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread());"
      },
      {
        "title": "RxJava - map与flatmap区别",
        "content": "map与flatmap区别\n\n结论：\n\nmap适用于一对一转换\nflatmap适用于一对多，多对多的场景\n\n区别：\n\n1、map是通过原始数据类型返回另外一种数据类型，而flatMap是通过原始数据类型返回另外一种被观察者。\n\n2、map被订阅时每传递一个事件执行一次onNext方法，flatmap多用于多对多，一对多，再被转化为多个时，一般利用from/just进行一一分发，被订阅时将所有数据传递完毕汇总到一个Observable然后一一执行onNext方法\n\n3、map只能一对一进行转换，flatmap既可以单一转换也可以一对多/多对多转换。flatMap并不保证数据有序。\n\n4、concatMap与flatMap使用基本一致，它可以保证数据有序\n\n相同点：\n\n1. 都是依赖FuncX(入参，返回值)进行转换（将一个类型依据程序逻辑转换成另一种类型，根据入参和返回值）\n2. 都能在转换后直接被subscribe\n"
      },
      {
        "title": "RxJava相关问题",
        "content": "1、Observer处理完onComplete后会还能onNext吗?\n\nonComplete是用来控制不能发送数据的，也就是不能onNext了，包括onError也是不能再发送onNext数据了，该方法中也是调用了dispose方法\n\n\n2、你还用过其他哪些操作符?\n\n关于其他的操作符比如merge、concat、zip都是合并，interval是周期执行，timer是延迟发送数据。\n\n\n3、Maybe、Single、Flowable、Completable几种观察者的区别，以及他们在什么场景用？\n\n从上面各个对应的observer接口来看，如果只想发一条数据，或者不发数据就用Maybe，如果想法多条数据或者不发数据就用Observable，如果只发一条数据或者失败就用Single，如果想用背压策略使用Flowable，如果不发数据就用Completable。\t\t\n\n\n4、RxJava的subscribeOn只有第一次生效?\n\n最开始调用的subscribeOn返回的observable会把后面执行的subscribeOn返回的observable给覆盖了，因此我们感官的是只有第一次的subscribeOn能生效。\n\n5、RxJava中背压是怎么回事？\n\n由于被观察者发送事件速度太快，而观察者来不及响应处理所有事件，从而导致事件丢失、OOM等异常。\n\n主要是通过Flowable类来实现的，Flowable其实就是被观察者（Observable）的一种新实现\n\n观察者通过Subscription.request获取事件, request决定了观察者能够接收多少个事件, 如设置了s.request(3)，这就说明观察者能够接收3个事件（多出的事件存放在缓存区）\n\nFlowable默认缓冲区的队列大小为128，即存储128个事件，超出会报错。\n"
      },
      {
        "title": "发射器与Disposable",
        "content": " ObservableEmitter:发射器可以分别发出next事件、complete事件和error事件。\n\n Disposable当调用它的dispose()方法时, 上游还会继续发送,但下游将不再接收事件.\n\n Observable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n            emitter.onNext(1);\n            emitter.onNext(2);\n            emitter.onNext(3);\n            emitter.onComplete();\n        }\n    }).subscribe(new Observer<Integer>() {   \n        @Override\n        public void onNext(Integer value) {\n            Log.d(TAG, \"\" + value);\n            new Disposable().dispose();\n        }\n}"
      },
      {
        "title": "常用操作符",
        "content": "创建操作符\n\ncreate:创建1个被观察者对象（Observable）\n\nJust:快速创建 被观察者对象（Observable） & 发送10个以下事件\nObservable.just(“1”, “2”, “3”)\n\nempty() :该方法创建的被观察者对象发送事件的特点：仅发送Complete事件\n\nerror():该方法创建的被观察者对象发送事件的特点：仅发送Error事件，直接通知异常\n\n\n延时操作符：\n\nDelay : 使得被观察者延迟一段时间再发送事件，delay(long delay,TimeUnit unit)\n\nTimer:timer操作符默认运行在一个新线程上，也可自定义线程调度器（第3个参数）：\ntimer(long, TimeUnit, Scheduler)\n\n\n过滤操作符：\n\ntake, takeFirst, takeLast，只发射指定项的数据\nObservable.just(\"Hello\", \"RxJava\", \"Nice to meet you\") .take(2)\n\nskip,发射数据时忽略前N项数据\n\n\n变换操作符\n\nMap:是通过原始数据类型返回另外一种数据类型,适用于一对一转换\n\nObservable.just(\"Hello\", \"RxJava\", \"Nice to meet you\")\n.map(new Func1<String, Integer>() { //泛型第一个类型是原数据类型，第二个类型是想要变换的数据类型\n    @Override\n    public Integer call(String s) {\n        return s.hashCode();        //将数据转换为了int（取得其hashCode值）\n    }\n})\n.subscribe(new Action1<Integer>() {\n    @Override\n    public void call(Integer o) {\n        System.out.println(\"onNext--> \" + o);\n    }\n}\n\n\u2028  \nflaMap: 通过原始数据类型返回另外一种被观察者,适用于一对多，多对多的场景\u2028\nObservable.just(\"Hello\", \"RxJava\", \"Nice to meet you\")\n.flatMap(new Func1<String, Observable<Integer>>() {\n    @Override\n    public Observable<Integer> call(String s) {\n        return Observable.just(s.hashCode());\n    }\n})\n.subscribe(new Action1<Integer>() {\n    @Override\n    public void call(Integer o) {\n        System.out.println(\"onNext--> \" + o);\n    }\n}\n\nconcatMap:与flatMap的区别是，新合并生成的事件序列顺序是有序的\n\n其他还有retry遇到错误重试、repeat重复、marge合并之类的。\n"
      }
    ]
  },
  {
    "name": "组件化",
    "data": [
      {
        "title": "组件化通信原理，打包",
        "content": "组件化使用的是ARouter 核心实现思路是，我们在代码里加入的@Route注解，会在编译时期通过apt生成一些存储path和activityClass映射关系的类文件，然后app进程启动的时候会拿到这些类文件，把保存这些映射关系的数据读到内存里(保存在map里)，然后在进行路由跳转的时候，通过build()方法传入要到达页面的路由地址，ARouter会通过它自己存储的路由表找到路由地址对应的Activity.class(activity.class = map.get(path))，然后new Intent()，当调用ARouter的withString()方法它的内部会调用intent.putExtra(String name, String value)，调用navigation()方法，它的内部会调用startActivity(intent)进行跳转，这样便可以实现两个相互没有依赖的module顺利的启动对方的Activity了。\n\n打包的时候，可以通过gradle中的plugin来切换它是application还是library"
      },
      {
        "title": "ARouter拦截器的处理",
        "content": "自定义拦截器需要实现IInterceptor接口，并且添加@Interceptor的注解，其中priority为拦截器的优先级，值越小，优先级越高；然后实现pocess()和init()方法。\n\n @Override\n    public void process(Postcard postcard, InterceptorCallback callback) {\n        Log.e(\"testService\", Test1Interceptor.class.getName() + \" has process.\");\n        //拦截跳转，进行一些处理\n        if (postcard.getPath().equals(\"/test/test1\")) {\n            Log.e(\"testService\", Test1Interceptor.class.getName() + \" 进行了拦截处理！\");\n        }\n        callback.onContinue(postcard);\n    }\n\n\nif (postcard.getExtra() == ConstantMap.LOGIN_EXTRA) {\n    boolean isLogin = postcard.getExtras().getBoolean(ConstantMap.IS_LOGIN);\n    if (!isLogin) {\n        ARouter.getInstance().build(RouterMap.INTER_MIDDLE_ACTIVITY).navigation();\n    } else {\n        postcard.withString(ConstantMap.IS_LOGIN_EXTRA, \"登录了!\");\n        callback.onContinue(postcard);\n    }\n}\n"
      },
      {
        "title": "ARouter的使用",
        "content": "path的规则：/group/child…至少两个“/”；和Activity的@Route注解值匹配，Route主要有两个属性，path和group，在RouteProcessor中处理这个注解，在注解处理的方法中会根据注解的类型创建上面使用过的RouteMeta\n\n// 标准路由\nARouter.getInstance().build(\"/home/main\").navigation();\n\n// 标准分组路由\nARouter.getInstance().build(\"/home/main\", \"ap\").navigation();\n\n// Uri跳转\nARouter.getInstance().build(uri).navigation();\n\n// startActivityForResult  在navigation后加入\nARouter.getInstance().build(\"/home/main\", \"ap\").navigation(this, 5);\n\n跳转activity的时候，但凡涉及activity的任务栈，必须使用navigation(context)并且context只能是activity。建议，如果当前可以获取activity，最好传了。\n\n// 使用方式同Activity，navigation()方法会返回要跳到的对象实例，跳转Fragment可以拿到Fragment实例操作。\nFragment fragment = (Fragment) ARouter.getInstance().build(\"/test/fragment\").navigation();\nfragmentList.add(fragment);\n\n\n直接传bundle\t\t.with(bundle)\n\n指定flag\t\t\t.withFlags();\n\n传对象\t\t\t.withObject(\"key\", new Obj(“”))\n\n转场动画\t\t\t.withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)\n\n还提供了int、long、short等基本变量和String、Object、Serializable、Parcelable和对应的数组、List\n"
      },
      {
        "title": "组件化跳转流程及关键类",
        "content": "1、获取ARouter实例\n2、构造路由信息的容器postcard\n3、如果需要拦截，就进行拦截器的处理，否则就调用_navigation方法。\n\n所有的Url/Intent跳转信息都使用Postcard邮戳进行信息封装。\n\n\nWarehouse\u2028存储跳转Path所对应的activity/fragment/url/provider，通过APT解析出来的映射关系存储在Warehouse中。\n\nLogisticsCenter\u2028负责解析注解并构造Postcard。以懒加载的方式从Warehouse中获取信息，包括class/url/extras/params等跳转信息。构造Postcard的信息储存对象为HashMap形式的RouteMeta。\n\n_ARouter\u2028负责根据Postcard进行页面跳转。Native采用startActivity形式。\n"
      },
      {
        "title": "组件化资源冲突",
        "content": "在app模块引用greet字符串就会出现资源冲突问题。就是给每个子模块给资源名添加前缀，然后在子模块的build.gradle文件的android块内添加resourcePrefix “资源名前缀”。AS会约束我们定义资源。\n\nresourcePrefix \"me_\""
      },
      {
        "title": "组件化通信及跳转原理",
        "content": "ARouter 是在代码里加入的@Route注解，会在编译时期通过apt生成一些存储path和Class映射关系的类文件，然后app进程启动的时候，把保存这些映射关系的数据读到内存里(保存在map里)，\n\n在进行路由跳转的时候，通过build()方法传入要到达页面的路由地址，ARouter会通过它自己存储的路由表找到路由地址对应的Activity.class(activity.class = map.get(path))来进行跳转。\n\n传参的话，可以调用ARouter的withString()、withInt()、withBoolean()\n方法它的内部会调用intent.putExtra(String name, String value)，调用navigation()方法，它的内部会调用startActivity(intent)进行跳转，这样便可以实现两个相互没有依赖的module顺利的启动对方的Activity了。\n\n并通过javapoet动态生成路由表"
      }
    ]
  },
  {
    "name": "开发模式",
    "data": [
      {
        "title": "介绍下MVC及优缺点",
        "content": "MVC特点是设计简单，适用于更新频率不太高，改动不大的项目，但因为它的view和model是可见的，外加它的Controller也就是Activity角色比较模糊，当业务越来越复杂时，就会变的十分臃肿了，不容易维护。\n\n优点：对model进行了隔离\n缺点：activity会变得臃肿\n\nController <— —> View <— —> Model\n\nController —> Model\n\nView层：一般由XML布局文件充当。\nModel层：一些数据处理的工作，比如网络数据请求、数据库操作等。\nController层：通常由Activity、Fragment充当，并在其中进行界面、数据相关的业务处理。"
      },
      {
        "title": "介绍下MVP",
        "content": "model 数据以及数据相关的逻辑操作\nview是由xml与Activity来承担的\nPresenter 用来承担业务逻辑与操作view与model的\n\n引用了presenter，interface是用来管理presenter能控制view的哪些功能\n\n在activity中，负责创建presenter，接口有activity来实现，由presenter来调用。presenter构造函数把view（Activity）做为参数传入，接口单独创建。activity实现接口，并负责响应些事件，交给presenter。在presenter中，创建model，并通过view与model的一些方法，来对两边进行更新与通信。\n\n优点：基于MVC做了进一步的解耦合\n缺点：接口部分开发与维护比较繁琐\n\n\nView <— —> Presenter <— —> Model\n"
      },
      {
        "title": "介绍下MVVM及优缺点",
        "content": "待解决"
      },
      {
        "title": "LifeCycle",
        "content": "使用Lifecycle在Activity里面就一句lifecycle.addObserver(mPresenter),就可以达到管理生命周期，Lifecycle观察者的角色。Activity需要继承AppCompatActivity；是通过在上层的SupportActivity，通过attached一个无界面ReportFragment，来感知生命周期的变化 的。当Activity调用生命周期OnPause时，会触发ReportFragment的OnPause，这时调用dispatch(Lifecycle.Event event)来进行向下分发。\n\ninterface IPresenter : LifecycleObserver{}\n\nclass CustomPresenter :IPresenter{\n    override fun onCreate(owner: LifecycleOwner) {\n        Log.d(\"BasePresenter\",\"onCreate()\")\n    }\n\n    override fun onDestroy(owner: LifecycleOwner) {\n        Log.d(\"BasePresenter\",\"onDestroy()\")\n    }\n}\n\n mPresenter = CustomPresenter(this)\n getLifecycle().addObserver(mPresenter)\n\n这里需要注意的两点：\n1，这里的Activity需要继承AppCompatActivity；\n2，这里的demo使用的java 7 写IPresenter接口的时候需要实现LifecycleObserver通过注解的方式来接收生命周期的变化，而在java8里面只需要去实现DefaultLifecycleObserver，然后重写里面的生命周期方法即可。"
      },
      {
        "title": "LiveData",
        "content": "LiveData 是一个可感知生命周期的可观察类 (Observable)。 通过订阅LiveData中当前Name数据变化，当数据发生变化时，onCreat中的观察者就会收到数据改变的回调。其优点包括：\n\n1、生命周期感知性：LiveData 与 Android 生命周期结合运行的效果良好。它仅会当 UI 被显示时才把数据往前端传递。\n2、与 Room 无缝整合：LiveData 可被设为 Room 的回调类。\n3、可与 ViewModel 和 Data Binding 混合使用，建立反应式 UI 。\n4、提供基本数据转换方法，例如 switchMap 和 MediatorLiveData。\n\n使用方法：\n\nActivity在onCreate()方法中通过LiveData.observe()方法添加观察者，当数据变化时会通过回调方法通知观察者，在lambda表达式中更新当前姓名和打印姓名列表。\n \npublic class NameViewModel extends ViewModel{\n    // 创建一个String类型的LiveData\n    private MutableLiveData<String> mCurrentName;\n\n    public MutableLiveData<String> getCurrentName() {\n        if (mCurrentName == null) {\n            mCurrentName = new MutableLiveData<>();\n        }\n        return mCurrentName;\n    }\n}\n\n\n// 订阅LiveData中当前Name数据变化，以lambda形式定义Observer\n  mNameViewModel.getCurrentName().observe(this, new Observer<String>() {\n            @Override\n            public void onChanged(String name) {\n                mTvName.setText(name);\n                Log.d(TAG, \"currentName: \" + name);\n            }\n        });\n\n// 当数据发生变化时，onCreat中的观察者就会收到数据改变的回调\nonClick(){\n    mNameViewModel.getCurrentName().setValue(\"Jane\");\n}"
      }
    ]
  },
  {
    "name": "kotlin相关",
    "data": [
      {
        "title": "Kotlin优点",
        "content": "Kotlin相比较Java优点还是比较明显的，它完全兼容JAVA，AS就提供了JAVA项目转Kotlin的功能。首先它是空指针安全的，对于非空引用类型，Kotlin在编译时就会进行检测，如果值是null，会编译失败。如果想要允许为null，我们需要在变量的类型后面加上一个?号，表明它是可空类型。\n\n再有就是扩展函数，我们可以不通过继承、不修改源码等方式，给对象类增加属性和方法，比如一个TextView，我们只是用扩展属性调用的方式就可以给它进行加粗操作。最后还有像智能转换，支持lamda等比较快捷的特性\n\n还有协程，省去了传统 Thread 多线程并发机制中的性能损耗，还可以顺序调用异步代码，避免回调地狱。\n\n还有就是数据类 Data Class，它们可以自动生成样板，像equals，hashCode，toString，getter / setter等可以直接使用等。\n\n"
      },
      {
        "title": "介绍下Kotlin Coroutines(协程)",
        "content": "协程可以理解是轻量级的线程，它依赖于线程，但不像线程，切换或阻塞的开销都比较大，协程挂起时不需要阻塞线程，还有就是一个线程中可以创建任意个协程。\n\n另外它不需要多次回调，有点类似rxjava，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样（协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来）\n\nfun main(args: Array<String>) {\n    launch(CommonPool) {\n        delay(1000L) \n        println(\"World!\") \n    }\n    println(\"Hello,\")\n    Thread.sleep(2000L)\n}\n\n/* \n运行结果: (\"Hello,\"会立即被打印, 1000毫秒之后, \"World!\"会被打印)\nHello, \nWorld!\n*/"
      },
      {
        "title": "async与launch 创建的区别",
        "content": "launch - 创建协程\nasync - 创建带返回值的协程，返回的是 Deferred 类\n\n在概念上，async 就类似于 launch。它启动了⼀个单独的协程，这是⼀个轻量级的线程并与其它所有的 协程⼀起并发的⼯作。不同之处在于 launch 返回⼀个 Job 并且不附带任何结果值，⽽ async 返回 ⼀个 Deferred⼀个轻量级的⾮阻塞 future，这代表了⼀个将会在稍后提供结果的 promise。你可 以使⽤ .await() 在⼀个延期的值上得到它的最终结果\n（runBlocking单元测试用）"
      },
      {
        "title": "async 的使用",
        "content": "用于开启一个新的子协程，与 launch 函数一样可以设置启动模式，不同的是它的返回值为 Deferred，Deferred是Job的子类，但是通过Deferred.await()可以得到一个返回值，简单理解的话，这就是一个带返回值的 launch 函数\n\n\n\n//串行执行\nlaunch(UI) {                             \n    prograssBar.isVisible = true\n \n    val token = async { getToken() }\n    val profile = async { loadProfile(token.await()) }.await()\n    nameText.text = profile.name\n    \n    prograssBar.isVisible = false\n                                                \n}\n\n//并行执行\nlaunch(UI) {                                            \n    prograssBar.isVisible = true\n \n    val profile = async { loadProfile() }\n    val articles = async { loadArticles() }\n    show(profile.await(), articles.await())\n    prograssBar.isVisible = false\n                                              \n}"
      },
      {
        "title": "cancel()与join()",
        "content": "cancel代码取消协程的执行，join意思是阻塞等待协程结束。也就是说cancel执行后会马上返回，执行后续的代码，但是这个时候协程不一定结束。再调用join方法，这里表示阻塞等待协程结束。确保协程结束之后才执行后续的代码。我们也可以调用job.cancelAndJoin()\n\n协程的取消操作是协作完成的，也就是协程必须协作才能取消。假如协程正在执行任务，如果没有检查协程是否是处于取消状态的话，则无法取消协程的执行。\n\nsuspend fun main() {\n    //构建作用区域\n    coroutineScope {\n        var job = launch {\n            var time = System.currentTimeMillis()\n            var i = 0\n            while (i < 5) {\n                if (System.currentTimeMillis() >= time) {\n                    println(\"这是第 \/${++i} 次\")\n                    time += 500\n                }\n            }\n        }\n        //非阻塞等待1300毫秒\n        delay(1300)\n        println(\"我已等待结束....\")\n        job.cancel()\n        job.join()\n        // job.cancelAndJoin()\n    }\n}\n\n这是第 1 次\n这是第 2 次\n这是第 3 次\n我已等待结束....\n这是第 4 次\n这是第 5 次\n"
      },
      {
        "title": "协程体、挂起函数",
        "content": "当程序执行到requestDataAsync内部时, 通过async启动了另外一个新的子协程去拉取数据, 启动这个新的子协程后, 当前的父协程就挂起了, 此时requestDataAsync还没有返回.\n\n\n子协程一直在后台跑, 过了一段时间, 子协程把数据拉回来之后, 会恢复它的父协程, 父协程继续执行, requestDataAsync就把数据返回了.\n\nfun main(...) {\n    launch(Unconfined) {  // 请重点关注协程里是如何获取异步数据的\n        val data = requestDataAsync()  // 异步回来的数据, 像同步一样return了\n        println(\"data is \/$it\")\n    }\n\n    Thead.sleep(10000L) // 请不要关注这个sleep\n}\n\nsuspend fun requestDataAsync() { // 请注意方法前多了一个suspend关键字\n    return async(CommonPool) { // 先不要管这个async方法, 后面解释\n        // do something need lots of times.\n        // ...\n        data  // return data, lambda里的return要省略\n    }.await()\n}"
      },
      {
        "title": "如何停止任务中的协程",
        "content": "1.使用isActive使计算代码可以取消\n var job = launch {\n      while (isActive) {\n                if (System.currentTimeMillis() >= time) {\n                    println(\"这是第 \/${++i} 次\")\n                    time += 500\n                }\n            }\n\n\n2.使用yield()使计算代码可以取消\n var job = launch {\n while (i<5) {\n                yield()\n                if (System.currentTimeMillis() >= time) {\n                    println(\"这是第 \/${++i} 次\")\n                    time += 500\n                }\n            }\n\n\n3.使用 finally 关闭资源\nvar job = launch {\n            try {\n                repeat(1000){\n                    println(\"这是一次打印\")\n                    delay(500)\n                }\n            }\n            finally {\n                println(\"finally\")\n            }\n        }\n\n\n4.可以使用withTimeoutOrNull\ncoroutineScope {\n        withTimeoutOrNull(2000) {\n            launch {\n                repeat(1000) {\n                    println(\"这是一次打印\")\n                    delay(500)\n                }\n            }\n\n        }\n    }\n"
      },
      {
        "title": "协程是如何实现异步的",
        "content": "编译器对挂起函数的CPS（续体传递风格）变换，变换后的函数多了一个 Continuation<T> 类型的参数，这个就是协程在挂起之后应该继续执行的代码，也就是续体。\n\n除了这个还会有一个ContinuationInterceptor。续体拦截器负责拦截协程在恢复后应执行的代码（即续体）并将其在指定线程或线程池恢复。\n\n协程在编译挂起函数时会将函数体编译为状态机，成员变量 label 代表了当前状态机的状态，每一个续体都各自对应了一个状态，当函数运行到每个挂起点时，label 的值都受限会发生改变，有点类似于swatch选择，是通过状态流转再通过函数回调来传递结果值，实现异步的\n\nGlobalScope.launch {\n    val a = a()\n    val y = foo(a).await() // 挂起点1\n    b()\n    val z = bar(a, y).await() // 挂起点2\n    c(z)\n}\n\n上面的代码块被编译成一个匿名内部类，该类有一个方法来实现状态机，有一个成员变量来标志当前状态机的状态。最终通过函数回调来传递结果"
      },
      {
        "title": "kotlin操作符",
        "content": "let：使用it替代object对象去访问其公有的属性 & 方法\n\nalso类似let函数，但区别在于返回值：let只反最后一行变量给result，also把=号后面整体返给result\n\nwith：需要调用同一个对象的多个方法 / 属性\n\nrun结合了let、with两个函数的作用，调用同一个对象的多个方法 / 属性时，统一做判空处理\n\napply与run函数类似，但区别在于返回值：run函数返回最后一行的值 / 表达式，apply函数返回传入的对象的本身\n\nout T  等价于 ? extends T\nin T  等价于  ? super T  \n\n\nList<? extends Animal> list1 = new ArrayList<>()\nlist1.add(new Dog())  // Dog是Animal的子类，编译器不然通过，\n\n**************\n\nlet\n// 作用1：使用it替代object对象去访问其公有的属性 & 方法\nobject.let{\n   it.todo()\n}\n// 作用2：判断object为null的操作\nobject?.let{//表示object不为null的条件下，才会去执行let函数体\n   it.todo()\n}\n\n*************\n\nalso类似let函数，但区别在于返回值：\nvar result = mVar.let {\n               it.function3()\n               999\n}\n// 最终结果 = 返回999给变量result\n\nvar result = mVar.also {\n               it.function1()\n               999\n}\n// 最终结果 = 返回一个mVar对象给变量result\n\n**************\n\nwith需要调用同一个对象的多个方法 / 属性\nval people = People(\"carson\", 25)\nwith(people) {\nprintln(\"my name is \/$name, I am \/$age years old\")\n}\n\n**************\n\nrun结合了let、with两个函数的作用，调用同一个对象的多个方法 / 属性时，统一做判空处理\nval people = People(\"carson\", 25)\npeople?.run{\n    println(\"my name is \/$name, I am \/$age years old\")\n}\n\n*************\n\napply与run函数类似，但区别在于返回值：run函数返回最后一行的值 / 表达式，apply函数返回传入的对象的本身\n\nval people = People(\"carson\", 25)\nval result = people?.run{\n    println(\"my name is \/$name, I am \/$age years old\")\n    999\n}\n// 最终结果 = 返回一个people对象给变量result"
      },
      {
        "title": "扩展函数",
        "content": "kotlin中的扩展函数，实际上是在自己的类中添加了一个static final方法，将需要扩展的类，在使用的时候作为第一个参数传入方法中，然后利用这个对象就可以访问这个类中的成员属性和方法了，并且最后返回一个这个接收者类型对象本身\n\n\n   public static final TextView isBold(@NotNull TextView \/$receiver) {//扩展函数isBold对应实际上是Java中的静态函数，并且传入一个接收者类型对象作为参数\n\n      Intrinsics.checkParameterIsNotNull(\/$receiver, \"\/$receiver\");\n\n      \/$receiver.getPaint().setFakeBoldText(true);//设置加粗\n\n      return \/$receiver;//最后返回这个接收者对象自身，以致于我们在Kotlin中完全可以使用this替代接收者对象或者直接不写。\n   }\n}\n\n\n使用：\n\n//扩展函数定义\nfun TextView.isBold() = this.apply { \n paint.isFakeBoldText = true\n}\n\n//扩展函数调用\nactivity.find<TextView>(R.id.course_comment_tv_score).isBold()\n\n扩展属性实际上就是提供某个属性访问的set,get方法，这两个set，get方法是静态函数，同时都会传入一个接收者类型的对象，然后在其内部用这个对象实例去访问和修改对象所对应的类的属性。\n"
      }
    ]
  }
]