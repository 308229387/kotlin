package com.example.kotlin.data

/**
 * Author: sym
 * Date: 2021/7/13 8:11 PM
 * Describe:
 */
 class AlgorithmQA{

    companion object {
        const val task_1 = "剑指offer算法题"
        const val task_2 = "每天5道复习算法题"
        const val task_3 = "完成剩余QA"
        const val task_4 = "架构思想整理"
        const val task_5 = "flutter问题整理"
        const val task_6 = "单例模式"
        const val task_7 = "自我介绍"
        const val task_7_answer = "最近一家公司是在一点资讯，主要负责生活圈C 端与B端的开发工作，使用的语言java与kotlin都有，有过独立项目开发经验，我除了业务支持、版本迭代、跨端沟通这些基础能力外，对于动画、性能优化还有热门框架，都能熟练使用，也参与过Unity 3D和安卓的嵌套混合开发，\n" + "\n" + "这家公司呆的时间也不久，近期公司受国家政策影响，新闻资讯类app受到管控，公司业务收缩的比较利害，所以出来看看机会。"


        const val reverse_list = "递归反转链表"
        const val reverse_list_answer = "class Solution {\n" + "    public ListNode reverseList(ListNode head) {\n" + "        if(head == null||head.next == null){\n" + "            return head;\n" + "        }\n" + "        ListNode cur = reverseList(head.next);\n" + "        head.next.next = head;\n" + "        head.next = null;\n" + "        return cur;\n" + "    }\n" + "}\n" + "\n" + "链表反转是用递归来实现，共有六步\n" + "第1步写方法reverseList，传入节点head，返回节点ListNode\n" + " public ListNode reverseList(ListNode head)\n" + "\n" + "第2步：先做一层判断，触发终止时结束递归，并返回最后的节点head\n" + " if(head == null||head.next == null){\n" + "            return head;\n" + "  }\n" + "\n" + "第3步：然后创建一个要返回的节点，递归调用reverseList，传入下一个head.next，这里假设传1-2-3-4-5，那这一步会递归的执行5回\n" + " ListNode cur = reverseList(head.next);\n" + "\n" + "/** 从这步向下的三行代码，递归传入的会一轮一轮反执行回来 */\n" + "\n" + "第4步：比如4的next 是5，那4的next的next等于4，意思是让5指向4\n" + "head.next.next = head;\n" + "\n" + "第5步：现在head已经是4了，5已经指向4了，要把4指向5的置null\n" + "head.next = null;\n" + "\n" + "第6步：返回节点cur\n" + "return cur;\n" + "\n" + "\n" + "时间复杂度：O(n)其中n是链表的长度。需要遍历链表一次。\n" + "空间复杂度：O(1)反转指针而已"
        const val reverse_list_iteration = "迭代反转链表"
        const val reverse_list_iteration_answer = "核心思想：pre与cur是类似于拼音一样在listNode上方，指向Node，先设个备用next节点指向next，因为cur.next = prv会断开原来指向next的指针。然后执行cur.next = prv这一步是反转的关键，然后再把上方两个拼音同时后移。最后prv为尾节点返回。\n" + "\n" + "class Solution {\n" + "    public ListNode reverseList(ListNode head) {\n" + "        ListNode pre = null,cur = head;\n" + "        while(cur!=null){\n" + "            ListNode next = cur.next;\n" + "            cur.next = pre;\n" + "            pre = cur;\n" + "            cur = next;\n" + "        }\n" + "        return pre;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度：O(n)，其中 n是链表的长度。需要遍历链表一次。\n" + "空间复杂度：O(1)。"
        const val has_cycle = "链表是否有环"
        const val has_cycle_answer = "核心思想：判断链表是否有环，核心思想是创建一快一慢两个指针，慢的走1步，快的走2步，然后在while循环中两个一起向前走，如果两节点相待了，那就说明有环，否则就没有。共有六步\n" + "\n" + "class Solution {\n" + "    public boolean hasCycle(ListNode head) {\n" + "        ListNode slow = head,fast = slow;\n" + "        while(true){\n" + "            if(fast == null||fast.next == null){\n" + "                return false;\n" + "            }\n" + "            slow = slow.next;\n" + "            fast = fast.next.next;\n" + "            if(slow == fast) return true;\n" + "        }\n" + "    }\n" + "}\n" + "\n" + "第一步：创建方法hasCycle，参数为节点head，返回值为boolean\n" + "public boolean hasCycle(ListNode head)\n" + "\n" + "第二步：创建一慢一快两指针，slow等于节点，fast等于slow\n" + "ListNode slow = head,fast = slow;\n" + "\n" + "第三步：写一个while循环，条件是true，一直跑\n" + "while(true){\n" + "\n" + "第四步：如果fast全等于null，或fast.next全等于null，说明到头了，还没有相等相遇，没有环返回false\n" + "if(fast == null||fast.next == null){\n" + "    return false;\n" + "}\n" + "\n" + "第五步：slow节点前移一步，fast节点前移两步\n" + "slow = slow.next;\n" + "fast = fast.next.next;\n" + "\n" + "第六步：判断，如果slow全等于fast，说明相遇了有环，返回true\n" + "\n" + "时间复杂度：O(N)，其中 N 是链表中的节点数。\n" + "空间复杂度：O(1)。我们只使用了两个指针的额外空间。"
        const val merge_two_lists = "合并两个有序链表"
        const val merge_two_lists_answer = "class Solution {\n" + "    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n" + "        ListNode dum  = new ListNode(0),cur = dum;\n" + "        while(l1 !=null&&l2 !=null){\n" + "            if(l1.val<l2.val){\n" + "                cur.next = l1;\n" + "                l1 = l1.next;\n" + "            }else{\n" + "                cur.next = l2;\n" + "                l2 = l2.next;\n" + "            }\n" + "            cur = cur.next;\n" + "        }\n" + "        cur.next = l1!=null?l1:l2;\n" + "        return dum.next;\n" + "    }\n" + "}\n" + "\n" + "链表l1,l2是递增的，因此核心思想是使用双指针l1和l2通过while循环遍历两链表，根据l1.val和l2.val的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。\n" + "\n" + "第一步：创建方法mergeTwoLists，返回节点ListNode，参数是l1、l2两个节点\n" + "public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n" + "\n" + "第二步：创建伪头部dum，还需要再创建一个cur，做为移动指针\n" + "ListNode dum  = new ListNode(0),cur = dum;\n" + "\n" + "第三步：创建while循环，条件是l1不等于null并且l2也不等于null\n" + "while(l1 !=null&&l2 !=null){\n" + "\n" + "第四步：比较l1的val值与l2的val值大小，如果l1的val小，把l1添加到cur后面，l1向后移一位\n" + "if(l1.val<l2.val){\n" + "    cur.next = l1;\n" + "    l1 = l1.next;\n" + "}\n" + "\n" + "第五步：如果l2的val小，把l2添加到cur后面，l2向后移一位\n" + "else{\n" + "    cur.next = l2;\n" + "    l2 = l2.next;\n" + "}\n" + "\n" + "第六步：指针cur向后移一位\n" + "cur = cur.next;\n" + "\n" + "第七步：有一方为null结束后，看还剩下谁，把不为null的放在cur后面\n" + "cur.next = l1!=null?l1:l2;\n" + "\n" + "第八步：返回伪头部后面的链表\n" + "return dum.next;\n" + "\n" + "\n" + "时间复杂度 O(M+N)O(M+N) ： M、N分别为链表 l1 、 l2 的长度，合并操作需遍历两链表\n" + "空间复杂度 O(1) ： 节点引用 dum , cur 使用常数大小的额外空间。\n" + "\n"
        const val k_th_from_end = "链表倒数第K个节点"
        const val k_th_from_end_answer = "\n" + "核心思想：创建一前一后双指针，快的先前进K步，然后启动一个while循环，同步前进，当快的到头后，慢的就是倒数第K个节点。\n" + "\n" + "常错点：仔细看题，是返回，不是删除\n" + "\n" + "class Solution {\n" + "    public ListNode getKthFromEnd(ListNode head, int k) {\n" + "        ListNode former = head, latter = head;\n" + "        for(int i = 0; i < k; i++){\n" + "            former = former.next;\n" + "        }\n" + "        while(former != null) {\n" + "            former = former.next;\n" + "            latter = latter.next;\n" + "        }\n" + "        return latter;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： N 为链表长度；总体看， former 走了 N 步， latter 走了 (N-k)步。\n" + "空间复杂度 O(1) ： 双指针 former , latter 使用常数大小的额外空间。"
        const val delete_node = "删除链表的节点"
        const val delete_node_answer = "核心思想：建两个指针，当前指针cur与后指针pre，启动一个while循环，条件就是当前指针不为null，并且当前指针val与目标val不等，然后当前指针前移，后继指针跟上。遇到相待的cur，把后节点指向前节点的下一位，返回haed就行了\n" + "\n" + "常错点：上来就要判断头部就是目标值的情况，另外prev是等于head的，不是prve.next = head。\n" + "\n" + "class Solution {\n" + "    public ListNode deleteNode(ListNode head, int val) {\n" + "        if(head.val == val) return head.next;\n" + "        ListNode pre = head,cur = pre.next;\n" + "        while(cur!=null&&cur.val!=val){\n" + "            pre = cur;\n" + "            cur = cur.next;\n" + "        }\n" + "        if(cur.val == val) pre.next = cur.next;\n" + "        return head;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： N 为链表长度，删除操作平均需循环 N/2 次，最差 N 次。\n" + "空间复杂度 O(1) ： cur, pre 占用常数大小额外空间。"
        const val merge_num = "合并两个有序数组(Arrays.sort())"
        const val merge_num_answer = "class Solution {\n" + "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "        for (int i = 0; i < n; ++i) {\n" + "            nums1[m + i] = nums2[i];\n" + "        }\n" + "        Arrays.sort(nums1);\n" + "    }\n" + "}\n" + "\n" + "核心思想：将数组2内元素通过for循环添加到数组1中，再通过Arrays的sort方法，把num1进行排序\n" + "\n" + "第一步：创建方法merge，无返回参数，入参是两个数组和他们的长度\n" + "public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "\n" + "第二步：启动for循环，执行次数与数组2和长度相同\n" + "for (int i = 0; i < n; ++i) {\n" + "\n" + "第三步：循环内，在数组1后面逐个添加数组2的元素\n" + "nums1[m + i] = nums2[i];\n" + "\n" + "第四步：通过Arrays.sort()方法，把num1进行排序\n" + "Arrays.sort(nums1);\n" + "\n" + "\n" + "时间复杂度：O((m+n) log(m+n))。\n" + "排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n) log(m+n))。\n" + "\n" + "空间复杂度：O( log(m+n))。\n" + "排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O( log(m+n))。"
        const val merge_num_traverse = "合并两个有序数组（遍历）"
        const val merge_num_traverse_answer = "class Solution {\n" + "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "        int k = m + n - 1;\n" + "        while (n > 0 && m > 0) {\n" + "            if (nums1[m - 1] < nums2[n - 1]) {\n" + "                nums1[k] = nums2[n - 1];\n" + "                n--;\n" + "            } else {\n" + "                nums1[k] = nums1[m - 1];\n" + "                m--;\n" + "            }\n" + "            k--;\n" + "        }\n" + "        for (int i = 0; i < n; i++) {\n" + "            nums1[i] = nums2[i];\n" + "        }\n" + "    }\n" + "}\n" + "\n" + "核心思想：先得到双数组之和的辅助下标k，然后再把数组1与数组2的的最后一位元素一一比较，从大到小，从后到前，反向放入nums1中。当有一组放完后，再把剩余一组，通过for循环逐个放入。\n" + "\n" + "第一步：创建方法merge，无返回参数，入参是两个数组和他们的长度\n" + "public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "\n" + "第二步：算出两数组总长的辅助下标k，为放入数组1做准备\n" + "int k = m + n - 1;\n" + "\n" + "第三步：启动个while循环，条件是m与n都大于0，开始准备遍历数组1与数组2\n" + "while (n > 0 && m > 0) {\n" + "\n" + "第四步：如果数组1最后一位小于数组2的最后一位，那把数组2的最后一位放到数组1的k下标上，并执行n--，下次比较下一位。\n" + "if (nums1[m - 1] < nums2[n - 1]) {\n" + "     nums1[k] = nums2[n - 1];\n" + "     n--;\n" + "}\n" + "\n" + "第五步：反之，则把数组1的最后一位放到数组1的k下标上，并执行m--，下次比较下一位。\n" + "else {\n" + "   nums1[k] = nums1[m - 1];\n" + "   m--;\n" + "}\n" + "\n" + "第六步：肯定有一方还有值，直接启动个for循环，把数组2的值搬过来，如果数组2没值，就跳过了。\n" + "for (int i = 0; i < n; i++) {\n" + "   nums1[i] = nums2[i];\n" + "}\n" + "\n" + "\n" + "时间复杂度：O(M + N)\n" + "空间复杂度：O(1)"
        const val string_add = "字符串相加"
        const val string_add_answer = "class Solution {\n" + "    public String addStrings(String num1, String num2) {\n" + "        StringBuilder res = new StringBuilder(\"\");\n" + "        int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n" + "        while(i >= 0 || j >= 0){\n" + "            int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;\n" + "            int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n" + "            int tmp = n1 + n2 + carry;\n" + "            carry = tmp / 10;\n" + "            res.append(tmp % 10);\n" + "            i--; j--;\n" + "        }\n" + "        if(carry == 1) res.append(1);\n" + "        return res.reverse().toString();\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建个两个长度-1的光标，还有个临时进位变量carry。启动个while循环，通过字符串指令，从最后一位把值取出转换成int，两值还有上一次的carry相加，并算出本次进位carry，把值放进result里。最后把余下的carry拼入Stringbuffer，返回to.Stirng。\n" + "\n" + "第一步：创建方法addStrings，返回String类型两数之和，参数是两个String数字\n" + "public String addString(String num1, String num2){\n" + "\n" + "第二步：创建一个StringBuider，用作拼接参数并返回\n" + "StringBuilder res = new StringBuiLder(\"\");\n" + "\n" + "第三步：创建两个移动光标i与j，分别等于两数之长-1\n" + "int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n" + "\n" + "第四步：启动一个while循环，条件是i与j都>=0\n" + "while( i>=0&&j>=0){\n" + "\n" + "第五步：把num1与num2的最后一位，通过字符串方法num1.charAt(i) - ‘0’转成数字，如果其中一个数的下标为负了，就取0就可以\n" + "int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;\n" + "int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n" + "\n" + "第六步：创建一轮相加数之和，变量tem，值为n1+n2+carry\n" + "int tmp = n1 + n2 + carry;\n" + "\n" + "第七步：计算本轮carry,值为tmp/10，十进制除10\n" + "carry = tem /10;\n" + "\n" + "第八步：把本轮个位数拼接到StringBuilder中，结束一轮计算，光标i与j减一位。\n" + "res.append(tmp % 10);\n" + "\n" + "第九步：当两数都加完后，如果carry还有值，则需在builder中再拼接个1\n" + "if(carry == 1) res.append(1);\n" + "\n" + "第十步：把拼接结果反转后，转成String，返回结果\n" + "return res.reverse().toString();\n" + "\n" + "\n" + "时间复杂度：O(max(len1,len2))，其中len1=num1.length ，len2=num2.length。竖式加法的次数取决于较大数的位数。\n" + "空间复杂度：O(1)。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 StringBuffer，故 Java 解法的空间复杂度为 O(n)。"
        const val first_show_char = "第一个只出现一次的字符"
        const val first_show_char_answer = "class Solution {\n" + "    public char firstUniqChar(String s) {\n" + "        HashMap<Character, Boolean> dic = new HashMap<>();\n" + "        char[] sc = s.toCharArray();\n" + "        for(char c : sc)\n" + "            dic.put(c, !dic.containsKey(c));\n" + "        for(char c : sc)\n" + "            if(dic.get(c)) return c;\n" + "        return ' ';\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建一HashMap，把字符串转成charArray数组，再把其中的每个字节当成key，通过HashMap的containsKey方法，把是否包含K当val，如果不包含，就返回true。再通过if语句，把符合val值为true的字节返回。\n" + "\n" + "第一步：创建方法getUniqChar，返回char类型，参数字符串s\n" + "public char firstUniqChar(String s) {\n" + "\n" + "第二步：创建HashMap，要加泛型，不然下面没法直接判断val为boolean类型。把封装类Character和Boolean当做key和value。\n" + "HashMap<Character, Boolean> dic = new HashMap<>();\n" + "\n" + "第三步：把字符串转成char数组\n" + "char[] sc = s.toCharArray();\n" + "\n" + "第四步：写个for循环，然后把字节c当Key，是否不包含当成value存入hashmap。\n" + "for(char c : sc)\n" + "dic.put(c, !dic.containsKey(c));\n" + "\n" + "第五步：再写个for循环，把value值做为条件，把为true的返回\n" + "for(char c : sc)\n" + "if(dic.get(c)) return c;\n" + "\n" + "第六步：最后，如果没有单独的，就返回个空字节\n" + "return ' ';\n" + "\n" + "\n" + "时间复杂度 O(N)： N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；HashMap 查找操作的复杂度为 O(1) ；\n" + "空间复杂度 O(1) ： 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用O(26)=O(1) 的额外空间。\n"
        const val replace_space = " 替换空格"
        const val replace_space_answer = "核心思想：创建个StringBuilder，然后把目标String转换成字节数组charArray，然后通过for循环，遍历每个字节，如果是空格，就把目标值放入StringBuilder中，否则就把字节放入builder。最后再返回Stringbuilder.toString();\n" + "\n" + "class Solution {\n" + "    public String replaceSpace(String s) {\n" + "        StringBuilder dic = new StringBuilder(\"\");\n" + "        for(char c : s.toCharArray()){\n" + "            if(c == ' '){\n" + "                dic.append(\"%20\");\n" + "            } \n" + "            else{\n" + "                dic.append(c);\n" + "            }\n" + "        }\n" + "        return dic.toString();\n" + "    }\n" + "}\n" + "\n" + "第一步：创建方法replaceSpace，返回结果String格式，参数为String s。\n" + "public String replaceSpace(String s){\n" + "\n" + "第二步：创建StringBuilder res，用来拼接字节，最后返回用\n" + "StringBuilder res = new StringBuilder(\"\");\n" + "\n" + "第三步：创建for循环，遍历字符串中的每一个字节\n" + "for(char c : s.toCharArray()){\n" + "\n" + "第四步：判断字节c是为空，如果为空，替换为目标值“%20”，拼入StringBuilder，否则把字节直接拼入StringBuilder。\n" + "if(c == ' '){\n" + "    dic.append(\"%20\");\n" + "} else{\n" + "        dic.append(c);\n" + "}\n" + "\n" + "第五步，把StringBuilder转成String返回\n" + "return dic.toString();\n" + "\n" + "时间复杂度 O(N)： 遍历使用 O(N)，每轮添加（修改）字符操作使用 O(1)；\n" + "空间复杂度 O(N)： Python 新建的 list 和 Java 新建的 StringBuilder 都使用了线性大小的额外空间。"
        const val two_sum = "两数之和求数组下标"
        const val two_sum_answer = "class Solution {\n" + "    public int[] twoSum(int[] nums, int target) {\n" + "        HashMap<Integer,Integer> map = new HashMap();\n" + "        for(int i = 0;i<nums.length;i++){\n" + "            if(map.containsKey(target - nums[i])){\n" + "                return new int[]{map.get(target-nums[i]),i};\n" + "            }\n" + "            map.put(nums[i],i);\n" + "        }\n" + "        return new int[0];\n" + "    }\n" + "}\n" + "\n" + "核心思路：通过for循环，把数组的值存入HashMap中的key，把下标当作val存入。然后再利用hashmap的contaionsKey方法，找出相应的下标，然后返回其下标。如果没有，返回new int[0]。\n" + "\n" + "第一步：创建方法twoSum，返回参数int[]数组，参数是数组加目标值taget。\n" + "public int[] twoSum(int[] nums, int target) {\n" + "\n" + "第二步：创建HashMap，泛型int+int，用来承接计算数组中的数。\n" + "HashMap<Integer,Integer> map = new HashMap();\n" + "\n" + "第三步：启动一个for循环，执行次数与数组长度一致\n" + "for(int i = 0;i<nums.length;i++){\n" + "\n" + "第四步：判断map中是否包含与num[i]相加为taget的key，如果有，返回该key的值与i下标。\n" + "if(map.containsKey(target - nums[i])){\n" + "    return new int[]{map.get(target-nums[i]),i};\n" + "}\n" + "\n" + "第五步：把数组的值存入HashMap中的key，把下标当作val存入map。\n" + "map.put(nums[i],i);\n" + "\n" + "第六步：如果不存在就返回空数组\n" + "return new int[0];\n" + "\n" + "\n" + "时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)地寻找 target - x。\n" + "空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。"
        const val reverse_print_recursive = "从尾到头打印链表（递归）"
        const val reverse_print_recursive_answer = "class Solution {\n" + "    ArrayList<Integer> tmp = new ArrayList<Integer>();\n" + "    public int[] reversePrint(ListNode head) {\n" + "        recur(head);\n" + "        int[] res = new int[tmp.size()];\n" + "        for(int i = 0; i < res.length; i++)\n" + "            res[i] = tmp.get(i);\n" + "        return res;\n" + "    }\n" + "    void recur(ListNode head) {\n" + "        if(head == null) return;\n" + "        recur(head.next);\n" + "        tmp.add(head.val);\n" + "    }\n" + "}\n" + "\n" + "核心思想：通过递归方法，把整个链表节点依次传入，顺带着再把val值也反向放入arraylist中。然后再通过for循环，把list中的值依次赋值给数组，最后返回数组结果。\n" + "\n" + "第一步：创建辅助列表tmp，泛型Integer\n" + "ArrayList<Integer> tmp = new ArrayList<Integer>();\n" + "\n" + "第二步：创建递归方法recur，无返回参数，入参为ListNode，判断head如果为空，return退出。然后递归调用recur方法，把head.next做为入参，下方为递归执行方法，反向把head.val添加到tmp列表中。\n" + "void recur(ListNode head) {\n" + "    if(head == null) return;\n" + "    recur(head.next);\n" + "    tmp.add(head.val);\n" + "}\n" + "\n" + "第三步：创建方法reversePrint，返回参数是int数组，入参节点listnode\n" + "public int[] reversePrint(ListNode head) {\n" + "\n" + "第四步：调用递归方法，传入节点ListNode，为tmp列表赋值\n" + "recur(head);\n" + "\n" + "第五步：创建新数组res，长度为tem.size()\n" + "int[] res = new int[tmp.size()];\n" + "\n" + "第六步：启动一个for循环，循环次数与数组长度相同，里面将list同下标的值赋给数组\n" + "for(int i = 0; i < res.length; i++)\n" + "     res[i] = tmp.get(i);\n" + "\n" + "第七步：返回数组res\n" + "return res;\n" + "\n" + "\n" + "时间复杂度 O(N)： 遍历链表，递归 N次。\n" + "空间复杂度 O(N)： 系统递归需要使用 O(N)的栈空间。"
        const val reverse_print_stack = "从尾到头打印链表（栈）"
        const val reverse_print_stack_answer = "核心思想：利用栈先进后出的原理，把节点依次放入栈中，然后再依次从栈中取出，赋值给数组并返回。\n" + "\n" + "易错点：把节点放入栈中时，要记得给节点进位tmp = tmp.next\n" + "\n" + "class Solution {\n" + "    public int[] reversePrint(ListNode head) {\n" + "        Stack<ListNode> stack = new Stack<ListNode>();\n" + "        ListNode temp = head;\n" + "        while (temp != null) {\n" + "            stack.push(temp);\n" + "            temp = temp.next;\n" + "        }\n" + "        int size = stack.size();\n" + "        int[] print = new int[size];\n" + "        for (int i = 0; i < size; i++) {\n" + "            print[i] = stack.pop().val;\n" + "        }\n" + "        return print;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度：O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。\n" + "空间复杂度：O(n)。额外使用一个栈存储链表中的每个节点。\n"
        const val create_list = "创建链表"
        const val create_list_answer = "核心思想：实现构造函数、增add、删delete、查get，其中增加头部与增加尾部可以复用addAtIndex方法\n" + "\n" + "class MyLinkedList {\n" + "        int size;\n" + "        ListNode head;  \n" + "\n" + "        public MyLinkedList() {\n" + "            size = 0;\n" + "            head = new ListNode(0);\n" + "        }\n" + "\n" + "        public int get(int index) {\n" + "            if (index < 0 || index >= size) return -1;\n" + "            ListNode curr = head;\n" + "            for (int i = 0; i < index + 1; ++i) curr = curr.next;\n" + "            return curr.val;\n" + "        }\n" + "\n" + "        public void addAtHead(int val) {\n" + "            addAtIndex(0, val);\n" + "        }\n" + "\n" + "        public void addAtTail(int val) {\n" + "            addAtIndex(size, val);\n" + "        }\n" + "\n" + "        public void addAtIndex(int index, int val) {\n" + "            if (index > size) return;\n" + "            if (index < 0) index = 0;\n" + "\n" + "            ++size;\n" + "            ListNode pred = head;\n" + "            for (int i = 0; i < index; ++i) pred = pred.next;\n" + "\n" + "            ListNode toAdd = new ListNode(val);\n" + "            toAdd.next = pred.next;\n" + "            pred.next = toAdd;\n" + "        }\n" + "\n" + "        public void deleteAtIndex(int index) {\n" + "            if (index < 0 || index >= size) return;\n" + "\n" + "            size--;\n" + "            ListNode pred = head;\n" + "            for (int i = 0; i < index; ++i) pred = pred.next;\n" + "\n" + "            pred.next = pred.next.next;\n" + "        }\n" + "    }\n" + "\n" + "第一步：创建size与链表头，完成构造函数\n" + "int size;\n" + "ListNode head;  \n" + "\n" + "public MyLinkedList() {\n" + "     size = 0;\n" + "     head = new ListNode(0);\n" + "}\n" + "\n" + "第二步：完成添加函数，addAtIndex，index大于size直接return，小于0，把index设置为0，然后添加链表长度++size，创建光标节点pre，并移动到目标位置，创建目标节点toAdd，调整前后指针完成添加。\n" + " public void addAtIndex(int index, int val) {\n" + "        if (index > size) return;\n" + "        if (index < 0) index = 0;\n" + "\n" + "        ++size;\n" + "        ListNode pred = head;\n" + "        for (int i = 0; i < index; ++i) pred = pred.next;\n" + "\n" + "        ListNode toAdd = new ListNode(val);\n" + "        toAdd.next = pred.next;\n" + "        pred.next = toAdd;\n" + "}\n" + "\n" + "第三步：完成删除函数，deleteAtIndex，当index大于size或小于0直接return，然后链表长度-1，创建光标节点pre，并移动光标节点至目标位，重新指向指针删除目标节点。\n" + " public void deleteAtIndex(int index) {\n" + "       if (index < 0 || index >= size) return;\n" + "\n" + "       size--;\n" + "       ListNode pred = head;\n" + "       for (int i = 0; i < index; ++i) pred = pred.next;\n" + "\n" + "       pred.next = pred.next.next;\n" + "}\n" + "\n" + "第四步：完成添加到头部与添加到尾部的方法，直接复用addAtIndex方法\n" + "public void addAtHead(int val) {\n" + "      addAtIndex(0, val);\n" + "}\n" + "\n" + "public void addAtTail(int val) {\n" + "      addAtIndex(size, val);\n" + "}\n" + "\n" + "时间复杂度：addAtHead  O(1)         addAtInder、get、deleteAtIndex  O(k)  k是元素索引值       addAtTail  O(n) n是元素个数\n" + "空间复杂度：所有操作都是O(1)"
        const val remove_n_from_end = "删除链表的倒数第N个结点"
        const val remove_n_from_end_answer = "核心思想：因为是需要返回头部，所以创建一个伪头部dum，创建一前一后两节点，前节点先移动目标n步，然后通过while循环一起前进，当前节点到最后一位时，后节点直接跳过赋值，删除目标节点，返回伪头部后一个节点就可以了。\n" + "\n" + "class Solution {\n" + "    public ListNode removeNthFromEnd(ListNode head, int n) {\n" + "        ListNode dum = new ListNode(0);\n" + "        dum.next = head;\n" + "        ListNode former = dum,latter = dum;\n" + "\n" + "        for(int i = 0;i<n;i++){\n" + "            former = former.next;\n" + "        }\n" + "        while(former.next!= null){\n" + "            former = former.next;\n" + "            latter = latter.next;\n" + "        }\n" + "        latter.next = latter.next.next;\n" + "        return dum.next;\n" + "    }\n" + "}\n" + "\n" + "第一步：创建方法removeNthFromEnd，返回头部ListNode，参数为节点head，目标值n\n" + "public ListNode removeNthFromEnd(ListNode head, int n) {\n" + "\n" + "第二步：创建伪头部，前后节点former、latter。\n" + "ListNode dum = new ListNode(0);\n" + "dum.next = head;\n" + "ListNode former = dum,latter = dum;\n" + "\n" + "第三步：通过for循环，使former节点前进n步。\n" + "for(int i = 0;i<n;i++){\n" + "    former = former.next;\n" + "}\n" + "\n" + "第四步：启动while循环，使前后节点共同前进\n" + "while(former.next!= null){\n" + "     former = former.next;\n" + "     latter = latter.next;\n" + "}\n" + "\n" + "第五步：到达目标点位前，latter节点跳过删除目标节点，并返回伪头部。\n" + "latter.next = latter.next.next;\n" + "return dum.next;\n" + "\n" + "\n" + "时间复杂度：O(L)，其中 L 是链表的长度。\u2028\n" + "空间复杂度：O(1)。"
        const val remove_elements = "移除链表元素"
        const val remove_elements_answer = "class Solution {\n" + "    public ListNode removeElements(ListNode head, int val) {\n" + "        ListNode dum = new ListNode(0);\n" + "        dum.next = head;\n" + "        ListNode cur = dum;\n" + "        while(cur.next!=null){\n" + "            if(cur.next.val ==val){\n" + "                cur.next = cur.next.next;\n" + "            }else{\n" + "                cur = cur.next;\n" + "            }\n" + "        }\n" + "        return dum.next;\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建伪头部及光标节点，通过wile循环移动光标节点，去掉目标节点后，返回伪头部。\n" + "\n" + "第一步：创建方法removeElements，返回节点ListNode，入参head节点与目标val。\n" + "public ListNode removeElements(ListNode head, int val) {\n" + "\n" + "第二步：创建伪头部与光标节点\n" + "ListNode dum = new ListNode(0);\n" + "dum.next = head;\n" + "ListNode cur = dum;\n" + "\n" + "第三步：通过while循环，移除相同值的节点，不同的移位\n" + "while(cur.next!=null){\n" + "   if(cur.next.val ==val){\n" + "        cur.next = cur.next.next;\n" + "      }else{\n" + "        cur = cur.next;\n" + "   }\n" + "}\n" + "\n" + "第四步：返回伪头部后一位，链表头\n" + "return dum.next;\n" + "\n" + "时间复杂度：O(n)，其中 n是链表的长度。需要遍历链表一次。\u2028空间复杂度：O(1)。"
        const val if_has_circle ="链表如果有环，返回相交节点"
        const val if_has_circle_answer ="核心思想：在判断是否有环基础上实现，先设立一快一慢两节点，快节点一次走两步，慢节点一次走一步，启动一个无限while循环，如果走到头没有相交没有环，如果相交，说明有环break退出，fast回归head位置，然后两节点一同前进，相交点就是环的相交点。\n" + "\n" + "public class Solution {\n" + "    public ListNode detectCycle(ListNode head) {\n" + "        ListNode slow = head,fast = slow;\n" + "        while(true){\n" + "            if(fast == null||fast.next == null){\n" + "                return null;\n" + "            }\n" + "            slow = slow.next;\n" + "            fast = fast.next.next;\n" + "            if(slow == fast) break;\n" + "        }\n" + "        fast = head;\n" + "        while (slow != fast) {\n" + "            slow = slow.next;\n" + "            fast = fast.next;\n" + "        }\n" + "        return fast;\n" + "    }\n" + "}\n" + "\n" + "第一步：创建方法，返回相交节点ListNode，入参头节点head，并创建一快一慢两节点，等于head。\n" + " public ListNode detectCycle(ListNode head) {\n" + "        ListNode slow = head,fast = slow;\n" + "\n" + "第二步，启动一个无限循环，如果fast走到头没有相交说明没有环，返回null，快的一次走两步，慢的一次走一步，如果有相遇，说明有环，break退出。\n" + "while(true){\n" + "        if(fast == null||fast.next == null){\n" + "                return null;\n" + "        }\n" + "        slow = slow.next;\n" + "        fast = fast.next.next;\n" + "        if(slow == fast) break;\n" + "}\n" + "\n" + "第三步：归位fast至head处，通过while循环，让两节点共同前进，相遇停止，返回节点fast\n" + "fast = head;\n" + "        while (slow != fast) {\n" + "            slow = slow.next;\n" + "            fast = fast.next;\n" + "        }\n" + "return fast;\n" + "\n" + "时间复杂度 O(N)：第二次相遇中，慢指针须走步数 a < a + b；第一次相遇中，慢指针须走步数 a + b - x < a + b，其中 xx 为双指针重合点与环入口距离；因此总体为线性复杂度；\n" + "空间复杂度 O(1)：双指针使用常数大小的额外空间。"
        const val cross_list_find_cross="相交链表，找出相交节点"
        const val cross_list_find_cross_answer="核心思想：A链表长度a，B链表长度b，公共长度c，有公式a+(b-c) = b+(a-c)。思想就是同时遍历a、b，然后到头后，从另一个链表的表头开始，相等即是相交节点。\n" + "\n" + "易错点：循环内，是判断a == null不是a.next == null\n" + "\n" + "public class Solution {\n" + "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n" + "        ListNode a  = headA,b = headB;\n" + "        while(a!=b){\n" + "            a = a==null?headB:a.next;\n" + "            b = b==null?headA:b.next;\n" + "        }\n" + "        return a;\n" + "    }\n" + "}\n" + "\n" + "第一步：创建方法getIntersectionNode，返回相交节点ListNode，入参两链表表头 headA、headB。\n" + "public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n" + "\n" + "第二步：创建两光标节点a、b，并赋值各自表头。\n" + "ListNode a  = headA,b = headB;\n" + "\n" + "第三步：通过while循环开始遍历a、b，到头后再从另一个表头开始，直到相等结束循环\n" + "while(a!=b){\n" + "      a = a==null?headB:a.next;\n" + "      b = b==null?headA:b.next;\n" + "}\n" + "\n" + "第四步：随便返回一个节点\n" + "return a;\n" + "\n" + "时间复杂度 O(a + b) ： 最差情况下无相交，此时需遍历 a + b个节点。\n" + "空间复杂度 O(1)： 节点指针 A , B 使用常数大小的额外空间。"
        const val odd_even_list = "奇偶链表"
        const val odd_even_list_answer = "class Solution {\n" + "    public ListNode oddEvenList(ListNode head) {\n" + "        if (head == null) {\n" + "            return head;\n" + "        }\n" + "        ListNode evenHead = head.next;\n" + "        ListNode odd = head, even = evenHead;\n" + "        while (even != null && even.next != null) {\n" + "            odd.next = even.next;\n" + "            odd = odd.next;\n" + "            even.next = odd.next;\n" + "            even = even.next;\n" + "        }\n" + "        odd.next = evenHead;\n" + "        return head;\n" + "    }\n" + "}\n" + "\n" + "核心思想：先对head判空，然后创建3个节点，一个奇光标节点，一个偶光标节点，一个偶节点头部。然后启动个while循环，让奇节点的下一个 = 偶节点下一个，奇光标移一位，然后偶节点 = 奇光标下一个，偶光标移位，最后，让奇节点的下一位等于偶节点头部。返回头部。\n" + "\n" + "第一步：创建方法oddEvenList，返回头节点ListNode，入参头节点head。然后判空。\n" + "public ListNode oddEvenList(ListNode head) {\n" + "        if (head == null) {\n" + "            return head;\n" + "        }\n" + "\n" + "第二步：创建三个节点，奇光标，偶光标，偶头部\n" + "ListNode evenHead = head.next, odd = head, even = evenHead;\n" + "\n" + "第三步：创建个while循环，条件为偶光标为空，或偶光标下一个为空，对于奇数长度链表，当even == null时结束循环，对于偶数长度链表，当even.next == null时结束循环。因为循环内第一行运算是用到了even.next，所以只能用even。循环内逻辑，让奇节点的下一个 = 偶节点下一个，奇光标移一位，然后偶节点 = 奇光标下一个，偶光标移位，\n" + " while (even != null && even.next != null) {\n" + "      odd.next = even.next;\n" + "      odd = odd.next;\n" + "      even.next = odd.next;\n" + "      even = even.next;\n" + "}\n" + "\n" + "第四步：两个奇偶链表整合，让奇链表的下一个等于偶链表头，并返回头节点。\n" + "odd.next = evenHead;\n" + "return head;\n" + "\n" + "\n" + "时间复杂度：O(n)，其中 n是链表的节点数。需要遍历链表中的每个节点，并更新指针。\u2028空间复杂度：O(1)。只需要维护有限的指针。\u2028"
        const val is_palindrome = "判断是否为回文链表"
        const val is_palindrome_answer = "class Solution {\n" + "    public boolean isPalindrome(ListNode head) {\n" + "        if (head == null) return true;\n" + "        ListNode firstHalfEnd = endOfFirstHalf(head);\n" + "        ListNode secondHalfStart = reverseList(firstHalfEnd.next);\n" + "\n" + "        ListNode p1 = head;\n" + "        ListNode p2 = secondHalfStart;\n" + "        boolean result = true;\n" + "        while (result && p2 != null) {\n" + "            if (p1.val != p2.val) {\n" + "                result = false;\n" + "            }\n" + "            p1 = p1.next;\n" + "            p2 = p2.next;\n" + "        }\n" + "        firstHalfEnd.next = reverseList(secondHalfStart);\n" + "        return result;\n" + "    }\n" + "\n" + "    private ListNode reverseList(ListNode head) {\n" + "        ListNode pre = null, cur = head;\n" + "        while (cur != null) {\n" + "            ListNode next = cur.next;\n" + "            cur.next = pre;\n" + "            pre = cur;\n" + "            cur = next;\n" + "        }\n" + "        return pre;\n" + "    }\n" + "\n" + "    private ListNode endOfFirstHalf(ListNode head) {\n" + "        ListNode fast = head, slow = head;\n" + "        while (fast.next != null && fast.next.next != null) {\n" + "            fast = fast.next.next;\n" + "            slow = slow.next;\n" + "        }\n" + "        return slow;\n" + "    }\n" + "}\n" + "\n" + "\n" + "核心思想：先通过快慢指针，找到中间节点，然后再通过链表反转，把后半部分链表反转，然后启动while循环，设置一个result与p2不为null为条件，然后从两链表头部开始对比，如果不等，result为false，然后移动两个指针遍历。完后再把后面的链表反转，拼接到第一个链表的尾部，返回result。\n" + "\n" + "第一步：写取中间节点方法，通过快慢指针方式\n" + "    private ListNode endOfFirstHalf(ListNode head) {\n" + "        ListNode fast = head, slow = head;\n" + "        while (fast.next != null && fast.next.next != null) {\n" + "            fast = fast.next.next;\n" + "            slow = slow.next;\n" + "        }\n" + "        return slow;\n" + "    }\n" + "\n" + "第二步：写反转链表\n" + "    private ListNode reverseList(ListNode head) {\n" + "        if (head == null) return head;\n" + "        ListNode pre = null, cur = head;\n" + "        while (cur != null) {\n" + "            ListNode next = cur.next;\n" + "            cur.next = pre;\n" + "            pre = cur;\n" + "            cur = next;\n" + "        }\n" + "        return pre;\n" + "    }\n" + "\n" + "第三步：先判空，然后通过中间节点方法得到前链表的尾节点、后链表的头节点\n" + "ListNode firstHalfEnd = endOfFirstHalf(head);\n" + "ListNode secondHalfStart = reverseList(firstHalfEnd.next);\n" + "\n" + "第四步：创建两个光标节点，还有个boolean标识result\n" + "ListNode p1 = head;\n" + "ListNode p2 = secondHalfStart;\n" + "boolean result = true;\n" + "\n" + "第五步：通过while循环从头到尾遍历前后链表，条件是结果标识与p2不为null\n" + "        while (result && p2 != null) {\n" + "            if (p1.val != p2.val) {\n" + "                result = false;\n" + "            }\n" + "            p1 = p1.next;\n" + "            p2 = p2.next;\n" + "        }\n" + "\n" + "第六步：拼接两链表，并返回结果\n" + "firstHalfEnd.next = reverseList(secondHalfStart);\n" + "return result;\n" + "\n" + "\n" + "时间复杂度：O(n)，其中 n 指的是链表的大小。\n" + "空间复杂度：O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)。"
        const val add_two_num = "两数相加链表版"
        const val add_two_num_answer = "class Solution {\n" + "    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n" + "        int carry = 0, m = 0, n = 0;\n" + "        ListNode dum = new ListNode(0), cur = dum;\n" + "        while (l1 != null || l2 != null) {\n" + "            m = l1 == null ? 0 : l1.val;\n" + "            n = l2 == null ? 0 : l2.val;\n" + "            cur.next = new ListNode((m + n + carry) % 10);\n" + "            carry = (m + n + carry)/10;\n" + "            cur = cur.next;\n" + "            if (l1 != null) l1 = l1.next;\n" + "            if (l2 != null) l2 = l2.next;\n" + "        }\n" + "        if (carry == 1) cur.next = new ListNode(1);\n" + "        return dum.next;\n" + "    }\n" + "}\n" + "\n" + "核心思想：因为是逆序存储，所以直接从链表头开始相加就行，同样创建三个int，carry、m、n，然后让两链表val赋值给mn，然后进行相加，值为%10，carry为除以10，最后如果有carry，新加个节点。\n" + "\n" + "第一步：创建方法addTwoNumbers，返回节点，入参数两链表头。创建carry、m、n，创建伪头部、光标节点cur。\n" + " public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n" + "        int carry = 0, m = 0, n = 0;\n" + "        ListNode dum = new ListNode(0), cur = dum;\n" + "\n" + "第二步：while循环，只要l1或l2有一个有值就继续加，赋值mn，创建新节点，负值(m+n+carry)%10,并计算carry。然后把cur、l1、l2前移一位。\n" + " while (l1 != null || l2 != null) {\n" + "            m = l1 == null ? 0 : l1.val;\n" + "            n = l2 == null ? 0 : l2.val;\n" + "            cur.next = new ListNode((m + n + carry) % 10);\n" + "            carry = (m + n + carry)/10;\n" + "            cur = cur.next;\n" + "            if (l1 != null) l1 = l1.next;\n" + "            if (l2 != null) l2 = l2.next;\n" + "        }\n" + "\n" + "第三步：循环结束后，如果有carry进位添加，并返回链表头\n" + "if (carry == 1) cur.next = new ListNode(1);\n" + "return dum.next;\n" + "\n" + "\n" + "时间复杂度：O(\\max(m,n))，其中m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。\n" + "空间复杂度：O(1)。注意返回值不计入空间复杂度。"
        const val pre_order_traversal_recursive="二叉数前序递归"
        const val pre_order_traversal_recursive_answer="class Solution {\n" + "    public List<Integer> preorderTraversal(TreeNode root) {\n" + "        List<Integer> res = new ArrayList<Integer>();\n" + "        preorder(root,res);\n" + "        return res;\n" + "    }\n" + "\n" + "    public void preorder(TreeNode root,List<Integer> res){\n" + "        if(root == null) return ;\n" + "        res.add(root.val);\n" + "        preorder(root.left,res);\n" + "        preorder(root.right,res);\n" + "    }\n" + "}\n" + "\n" + "核心思想：二叉数前序，先写一个preorder方法，判空，然后把结果放进list，递归调用左树节点，右树节点。再在主方法中调用preorder方法，返回结果list。\n" + "\n" + "第一步：创建preorder方法，判空，添加值到res，递归放入左树节点、右树节点。\n" + " public void preorder(TreeNode root,List<Integer> res){\n" + "        if(root == null) return ;\n" + "        res.add(root.val);\n" + "        preorder(root.left,res);\n" + "        preorder(root.right,res);\n" + "    }\n" + "\n" + "第二步，在主方法中，创建结果列表list，然后把树节点放入前序递归方法中。返回res。\n" + "public List<Integer> preorderTraversal(TreeNode root) {\n" + "        List<Integer> res = new ArrayList<Integer>();\n" + "        preorder(root,res);\n" + "        return res;\n" + "    }\n" + "\n" + "时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。\n" + "空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。"
        const val iteration_pre_order = "二叉数前序迭代"
        const val iteration_pre_order_answer = "class Solution {\n" + "        public List<Integer> preorderTraversal(TreeNode root) {\n" + "            List<Integer> res = new ArrayList();\n" + "            Stack<TreeNode> stack = new Stack();\n" + "\n" + "            while (root != null || !stack.isEmpty()) {\n" + "                while (root != null) {\n" + "                    res.add(root.val);\n" + "                    stack.push(root);\n" + "                    root = root.left;\n" + "                }\n" + "                root = stack.pop();\n" + "                root = root.right;\n" + "            }\n" + "            return res;\n" + "        }\n" + "    }\n" + "\n" + "核心思想：前序顺序是中、左、右，创建一个stack用来存储节点，利用嵌套while循环，小循环存值并把节点添加致stack，左移节点。大循环从stack中取出节点，并右移，通过此方法遍历整个树。\n" + "\n" + "第一步：创建方法，创建返回的list与stack栈，并做判空\n" + "        public List<Integer> preorderTraversal(TreeNode root) {\n" + "            List<Integer> res = new ArrayList();\n" + "            Stack<TreeNode> stack = new Stack();\n" + "\n" + "第二步：创建大小嵌套循环，小循环内部先把中间树节点值放入res，然后把节点装入stack，节点左移，当左节点为null时，表示当前树已经到底，再执行大循环，大循环的意思就是一层一层从stack中取出树节点，如果有右子树就装入res列表。\n" + "            while (root != null || !stack.isEmpty()) {\n" + "                while (root != null) {\n" + "                    res.add(root.val);\n" + "                    stack.push(root);\n" + "                    root = root.left;\n" + "                }\n" + "                root = stack.pop();\n" + "                root = root.right;\n" + "            }\n" + "            return res;\n" + "\n" + "\n" + "时间复杂度：O(n)，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。\n" + "空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。\n"
        const val inorder_traversal="二叉数中序遍历（迭代）"
        const val inorder_traversal_answer="class Solution {\n" + "    public List<Integer> inorderTraversal(TreeNode root) {\n" + "        List<Integer> res = new ArrayList();\n" + "        Stack<TreeNode> stack = new Stack();\n" + "        while (root != null || !stack.isEmpty()) {\n" + "            while (root != null) {\n" + "                stack.push(root);\n" + "                root = root.left;\n" + "            }\n" + "            root = stack.pop();\n" + "            res.add(root.val);\n" + "            root = root.right;\n" + "        }\n" + "        return res;\n" + "    }\n" + "}\n" + "\n" + "核心思想：先创建res结果列表和装TreeNode的stack，然后建立两个嵌套while循环，先通过小循环，把当前节点的所有左子树添加到stack中，然后跳出小循环，从最下面一层一层的把结果装入res，如果有right再把存入\n" + "\n" + "第一步：创建方法inorderTraversal，并创建res结果列表与stack栈。\n" + " public List<Integer> inorderTraversal(TreeNode root) {\n" + "        List<Integer> res = new ArrayList();\n" + "        Stack<TreeNode> stack = new Stack();\n" + "\n" + "第二步：建立大小嵌套while循环，小循环负责把所有的左子树放到stack中，大循环负责从下到上一层一层的把结果放到res中，如果有右子树再把右子树放入\n" + "        while (root != null || !stack.isEmpty()) {\n" + "            while (root != null) {\n" + "                stack.push(root);\n" + "                root = root.left;\n" + "            }\n" + "            root = stack.pop();\n" + "            res.add(root.val);\n" + "            root = root.right;\n" + "        }\n" + "\n" + "第三步：最后返回结果res\n" + "        return res;\n" + "\n" + "\n" + "时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\n" + "\n" + "空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。"
        const val recursive_inorder_traversal="二叉数中序遍历（递归）"
        const val recursive_inorder_traversal_answer="class Solution {\n" + "    public List<Integer> inorderTraversal(TreeNode root) {\n" + "        List<Integer> res = new ArrayList();\n" + "        inorder(root,res);\n" + "        return res;\n" + "    }\n" + "\n" + "    public void inorder(TreeNode root ,List<Integer> res){\n" + "        if(root== null) return;\n" + "        inorder(root.left,res);\n" + "        res.add(root.val);\n" + "        inorder(root.right,res);\n" + "    }\n" + "}\n" + "\n" + "核心思想：二叉数中序，先写一个inorder方法，判空，递归调用左子树，然后把结果放进list，再递归调右子树。再在主方法中调用inorder方法，返回结果list。\n" + "\n" + "第一步：先写一个inorder方法，判空，递归调用左子树，然后把结果放进list，再递归调右子树\n" + "    public void inorder(TreeNode root ,List<Integer> res){\n" + "        if(root== null) return;\n" + "        inorder(root.left,res);\n" + "        res.add(root.val);\n" + "        inorder(root.right,res);\n" + "    }\n" + "\n" + "第二步，在主方法中，创建结果列表list，然后把树节点放入前序递归方法中。返回res。\n" + "    public List<Integer> inorderTraversal(TreeNode root) {\n" + "        List<Integer> res = new ArrayList();\n" + "        inorder(root,res);\n" + "        return res;\n" + "    }\n" + "\n" + "\n" + "时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\n" + "空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。"
        const val post_order_traversal = "二叉数后序遍历（迭代）"
        const val post_order_traversal_answer = "class Solution {\n" + "    public List<Integer> postorderTraversal(TreeNode root) {\n" + "        List<Integer> res = new ArrayList();\n" + "        Stack<TreeNode> stack = new Stack();\n" + "        while(root!=null||!stack.isEmpty()){\n" + "            while(root!=null){\n" + "                res.add(0,root.val);\n" + "                stack.push(root);\n" + "                root = root.right;\n" + "            }\n" + "            root = stack.pop();\n" + "            root = root.left;\n" + "        }\n" + "        return res;\n" + "    }\n" + "}\n" + "\n" + "\n" + "核心思想：因为后序是左右中，与前序思路相似，关键需要通过res.add(0,root.val)把链表反转\n" + "\n" + "第一步：创建方法postorderTraversal，并创建res结果列表与stack栈。\n" + "    public List<Integer> postorderTraversal(TreeNode root) {\n" + "        List<Integer> res = new ArrayList();\n" + "        Stack<TreeNode> stack = new Stack();\n" + "\n" + "第二步：先按中右左的顺序摆放，然后再通过add(0,root.val)把链表返转，这样得到就是左右中了。建立大小嵌套while循环，小循环负责把中节点先放入res，然后右移，也就是先摆放中右，大循环负责从下到上一层一层的把结果从stack中取出，再把左子树摆好，整体就是中右左，然后反转。\n" + "        while(root!=null||!stack.isEmpty()){\n" + "            while(root!=null){\n" + "                res.add(0,root.val);\n" + "                stack.push(root);\n" + "                root = root.right;\n" + "            }\n" + "            root = stack.pop();\n" + "            root = root.left;\n" + "        }\n" + "\n" + "第三步：最后返回结果res\n" + "        return res;\n" + "\n" + "\n" + "时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\n" + "空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。"
        const val recursive_post_order_traversal = "二叉数后序遍历（递归）"
        const val recursive_post_order_traversal_answer = "class Solution {\n" + "    public List<Integer> postorderTraversal(TreeNode root) {\n" + "        List<Integer> res = new ArrayList();\n" + "        postorder(root,res);\n" + "        return res;\n" + "    }\n" + "\n" + "    public void postorder(TreeNode root,List<Integer> res){\n" + "        if(root == null) return;\n" + "        postorder(root.left,res);\n" + "        postorder(root.right,res);\n" + "        res.add(root.val);\n" + "    }\n" + "}\n" + "\n" + "\n" + "核心思想：二叉数后序，左右中，先写一个postorder方法，判空，递归调用左子树，然后递归调右子树，最后把结果放进list。再在主方法中调用inorder方法，再返回结果list。\n" + "\n" + "第一步：先写一个postorder方法，判空，递归调用左子树，再递归调右子树，然后把结果放进list\n" + "    public void postorder(TreeNode root,List<Integer> res){\n" + "        if(root == null) return;\n" + "        postorder(root.left,res);\n" + "        postorder(root.right,res);\n" + "        res.add(root.val);\n" + "    }\n" + "\n" + "第二步，在主方法中，创建结果列表list，然后把树节点放入前序递归方法中。返回res。\n" + "    public List<Integer> postorderTraversal(TreeNode root) {\n" + "        List<Integer> res = new ArrayList();\n" + "        postorder(root,res);\n" + "        return res;\n" + "    }\n" + "\n" + "\n" + "时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\n" + "空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。\n"
        const val level_order = "二叉数层序遍历（迭代）"
        const val level_order_answer = "核心思想：先创建个空二维list，然后判空。外层无逻辑，都是用queue装上TreeNode就完事，然后在while循环内，创建level与当前层的个数currentLevelSize，再用for循环给下一层level装node，在本轮while内，把level装入res里，最后返回res。\n" + "\n" + "易错点：如果要用LinkedList当level，1是要在初始化时就用LinkedList<Integer> 而不是List<>,2是放在的是addLast，而不是addFirst。\n" + "\n" + "class Solution {\n" + "    public List<List<Integer>> levelOrder(TreeNode root) {\n" + "        List<List<Integer>> res = new ArrayList();\n" + "        if (root == null) return res;\n" + "\n" + "        Queue<TreeNode> queue = new LinkedList();\n" + "        queue.offer(root);\n" + "        while (!queue.isEmpty()) {\n" + "            LinkedList<Integer> level = new LinkedList();\n" + "            int currentLevelSize = queue.size();\n" + "            for (int i = 0; i < currentLevelSize; i++) {\n" + "                TreeNode node = queue.poll();\n" + "                level.addLast(node.val);\n" + "                if (node.left != null) queue.offer(node.left);\n" + "                if (node.right != null) queue.offer(node.right);\n" + "            }\n" + "            res.add(level);\n" + "        }\n" + "        return res;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。\n" + "空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点 同时 在 queue 中，使用 O(N) 大小的额外空间。"
        const val recursive_level_order = "二叉数层序遍历（递归）"
        const val recursive_level_order_answer = "class Solution {\n" + "    List<List<Integer>> res = new ArrayList();\n" + "    public List<List<Integer>> levelOrder(TreeNode root) {\n" + "        if(root == null) return res;\n" + "        helper(root,0);\n" + "        return res;\n" + "    }\n" + "\n" + "    public void helper(TreeNode node,int level){\n" + "        if(res.size() == level) res.add(new ArrayList<Integer>());\n" + "        res.get(level).add(node.val);\n" + "        if(node.left!=null) helper(node.left,level+1);\n" + "        if(node.right!=null) helper(node.right,level+1);\n" + "    }\n" + "}\n" + "\n" + "核心思想：先创建list of list 的结果列表，然后创建递归方法，先判断res中的长度是否等于level，等于就让res添加个新列表。然后取到该层的level列表，添加node值，再判断左右子树，并加入。然后在主方法中调用。\n" + "\n" + "第一步：先创建递归方法，把节点与层数传进去，如果res的长度等于level，则添加新list。然后从res中取出当前层list，把node的值添加进去，如果有左子树，递归调用，如果有右子树，递归调用\n" + "    public void helper(TreeNode node,int level){\n" + "        if(res.size() == level) res.add(new ArrayList<Integer>());\n" + "        res.get(level).add(node.val);\n" + "        if(node.left!=null) helper(node.left,level+1);\n" + "        if(node.right!=null) helper(node.right,level+1);\n" + "    }\n" + "\n" + "第二步：创建主方法，判空，然后调用helper方法，最后返回res结果。\n" + "    public List<List<Integer>> levelOrder(TreeNode root) {\n" + "        if(root == null) return res;\n" + "        helper(root,0);\n" + "        return res;\n" + "    }\n" + "\n" + "\n" + "时间复杂度：O(N)\n" + "空间复杂度：O(h)，h 是树的高度\n"
        const val two_stack_for_list = "用两个栈实现队列"
        const val two_stack_for_list_answer = "核心思想：队列特点是先进先出发，栈是先进后出，所以把两个栈，一个设成进的，一个设成出的。出之前，先判空，没有就从进的栈中取，如果出的栈还没有，就返回-1，有就直接返回。\n" + "\n" + "class CQueue {\n" + "    Deque<Integer> stack1;\n" + "    Deque<Integer> stack2;\n" + "    \n" + "    public CQueue() {\n" + "        stack1 = new LinkedList<Integer>();\n" + "        stack2 = new LinkedList<Integer>();\n" + "    }\n" + "    \n" + "    public void appendTail(int value) {\n" + "        stack1.push(value);\n" + "    }\n" + "    \n" + "    public int deleteHead() {\n" + "        // 如果第二个栈为空\n" + "        if (stack2.isEmpty()) {\n" + "            while (!stack1.isEmpty()) {\n" + "                stack2.push(stack1.pop());\n" + "            }\n" + "        } \n" + "        if (stack2.isEmpty()) {\n" + "            return -1;\n" + "        } else {\n" + "            int deleteItem = stack2.pop();\n" + "            return deleteItem;\n" + "        }\n" + "    }\n" + "}\n" + "\n" + "时间复杂度：O(1)。插入与删除其实都是放在头部，和尾部，并没有过多调换，所以是O1\n" + "空间复杂度：O(n)。需要使用两个栈存储已有的元素"
        const val contains_min = "包含min函数的栈"
        const val contains_min_answer = "问题：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n" + "\n" + "核心思想：因为要求时间复杂度是O(1),所以需要辅助栈来实现，只需设法维护好 栈 BB 的元素，使其保持非严格降序，即可实现 min() 函数的 O(1)O(1) 复杂度。\n" + "\n" + "常错点：push方法时，易忘记b.isEmpty()这个条件\n" + "\n" + "class MinStack {\n" + "    Stack<Integer> A, B;\n" + "    public MinStack() {\n" + "        A = new Stack<>();\n" + "        B = new Stack<>();\n" + "    }\n" + "    public void push(int x) {\n" + "        A.add(x);\n" + "        if(B.empty() || B.peek() >= x)\n" + "            B.add(x);\n" + "    }\n" + "    public void pop() {\n" + "        if(A.pop().equals(B.peek()))\n" + "            B.pop();\n" + "    }\n" + "    public int top() {\n" + "        return A.peek();\n" + "    }\n" + "    public int min() {\n" + "        return B.peek();\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(1) ： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。\n" + "空间复杂度 O(N) ： 当共有 N 个待入栈元素时，辅助栈 B 最差情况下存储 N 个元素，使用 O(N) 额外空间。"
        const val hard_list = "复杂链表的复制"
        const val hard_list_answer = "核心思想：因为是复杂链表所以，可以理解成它有两条线，一条.next,一条是.random，所以可以使用hashmap，通过递归的方式，把节点存成两条线，核心代码就是新建个head，把head.val赋值，然后headNew.next=递归一条，headNew.random再递归一条\n" + "\n" + "常错点：map要放在方法外，不然会每次递归创建一个，超时。整体逻辑判断都是在map里不包含node的逻辑里处理的。要记得把head和headnew put到map里\n" + "\n" + "class Solution {\n" + "    Map<Node, Node> cachedNode = new HashMap<Node, Node>();\n" + "\n" + "    public Node copyRandomList(Node head) {\n" + "        if (head == null) {\n" + "            return null;\n" + "        }\n" + "        if (!cachedNode.containsKey(head)) {\n" + "            Node headNew = new Node(head.val);\n" + "            cachedNode.put(head, headNew);\n" + "            headNew.next = copyRandomList(head.next);\n" + "            headNew.random = copyRandomList(head.random);\n" + "        }\n" + "        return cachedNode.get(head);\n" + "    }\n" + "}\n" + "\n" + "时间复杂度：O(n)，其中 n 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。\n" + "\n" + "空间复杂度：O(n)，其中 n 是链表的长度。为哈希表的空间开销。"
        const val left_rotation_string = "左旋转字符串"
        const val left_rotation_string_answer = "核心思想：建一个StringBuilder，先拼后面的，再拼前面的几位，两个for循环。\n" + "\n" + "可以优化成int = n;i<n+length()     然后res.append(s.charAt(i % s.length()));\n" + "\n" + "class Solution {\n" + "    public String reverseLeftWords(String s, int n) {\n" + "        StringBuilder res = new StringBuilder();\n" + "        for(int i = n; i < s.length(); i++)\n" + "            res.append(s.charAt(i));\n" + "        for(int i = 0; i < n; i++)\n" + "            res.append(s.charAt(i));\n" + "        return res.toString();\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： 遍历使用 O(N) ，每轮添加（修改）字符操作使用 O(1) ；\n" + "空间复杂度 O(N) ： 新建的 StringBuilder 都使用了线性大小的额外空间。"
        const val string_all_arrangement = "字符串全排列"
        const val string_all_arrangement_answer = "核心思想：先固定第 1 位字符（ n 种情况）、再固定第 2 位字符（ n−1 种情况）、... 、最后固定第 n 位字符（ 1 种情况）。当遇到重复的情况时，需要通过set来排重剪枝。当排到最后一位时，把字符串放到res中。\n" + "\n" + "实现步骤：\n" + "1、创建临时结果list和转char。 \n" + "2、创建互换方法swap\n" + "3、添加backtrack方法回朔条件，把char转String加入res\n" + "4、创建hashset和for循环，循环条件是从x开始，不是0\n" + "5、如果set包含剪枝，不包含就装入，换位递归，然后再换回来\n" + "6、添加backtrack(0);把list换成String数组返回。\n" + "\n" + "class Solution {\n" + "    List<String> res = new LinkedList<>();\n" + "    char[] c;\n" + "    public String[] permutation(String s) {\n" + "        c = s.toCharArray();\n" + "        backtrack(0);\n" + "        return res.toArray(new String[res.size()]);  // 导出为数组\n" + "    }\n" + "    void backtrack(int x) {\n" + "        if(x == c.length - 1) {\n" + "            res.add(String.valueOf(c));      // 添加排列方案\n" + "            return;\n" + "        }\n" + "        HashSet<Character> set = new HashSet<>();\n" + "        for(int i = x; i < c.length; i++) {\n" + "            if(set.contains(c[i])) continue; // 重复，因此剪枝\n" + "            set.add(c[i]);\n" + "            swap(i, x);                      // 交换，将 c[i] 固定在第 x 位\n" + "            backtrack(x + 1);                      // 开启固定第 x + 1 位字符\n" + "            swap(i, x);                      // 恢复交换，保证一直都是abc\n" + "        }\n" + "    }\n" + "    void swap(int a, int b) {\n" + "        char tmp = c[a];\n" + "        c[a] = c[b];\n" + "        c[b] = tmp;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N!N)（O N的阶乘乘以N） ： 时间复杂度和字符串排列的方案数成线性关系，方案数为即复杂度为 O(N!) ；字符串拼接操作 join() 使用O(N) ；因此总体时间复杂度为 O(N!N)\n" + "\n" + "空间复杂度 O(N^2) ：  全排列的递归深度为 N，系统累计使用栈空间大小为 O(N) ；外加递归中辅助 Set 累计占用 O(N^2)的额外空间。"
        const val array_repeat_num = "数组中重复的数字"
        const val array_repeat_num_answer = "核心思想：由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。\n" + "\n" + "class Solution {\n" + "    public int findRepeatNumber(int[] nums) {\n" + "        Set<Integer> set = new HashSet<Integer>();\n" + "        int repeat = -1;\n" + "        for (int num : nums) {\n" + "            if (!set.add(num)) {\n" + "                repeat = num;\n" + "                break;\n" + "            }\n" + "        }\n" + "        return repeat;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度：O(n)。\n" + "遍历数组一遍。使用哈希集合（HashSet），添加元素的时间复杂度为 O(1)，故总的时间复杂度是 O(n)\n" + "空间复杂度：O(n)。不重复的每个元素都可能存入集合，因此占用 O(n) 额外空间"
        const val arrangement_array_find_num = "在排序数组中查找数字"
        const val arrangement_array_find_num_answer = "问题：统计一个数字在排序数组中出现的次数。\n" + "\n" + "核心思想：都是通过二分查找，先拿到右边界的index+1的下标，再拿到左边界index+1的下标，两者一减即可。注意，因为是排序数组，且都是整数，所以可以用taget-1，-2都不行。target-1 代表着去查找比 target 小的首个数字的右边界~ 至于这个数字具体小多少，都是能查找到的。\n" + "\n" + "class Solution {\n" + "    public int search(int[] nums, int target) {\n" + "        return binarySearch(nums, target) - binarySearch(nums, target - 1);\n" + "    }\n" + "    int binarySearch(int[] nums, int tar) {\n" + "        int i = 0, j = nums.length - 1;\n" + "        while(i <= j) {\n" + "            int m = (i + j) / 2;\n" + "            if(nums[m] <= tar) i = m + 1;\n" + "            else j = m - 1;\n" + "        }\n" + "        return i;\n" + "    }\n" + "}\n" + "\u2028O(logN) ： 二分法为对数级别复杂度。\n" + "O(1) ： 几个变量使用常数≤大小的额外空间。\n"
        const val array_missing_num = "0～n-1中缺失的数字"
        const val array_missing_num_answer = "核心思想：缺失的数字等于 “右子数组的首位元素” 对应的索引；因此考虑使用二分法查找，当 i ≤ j 时循环 （即当闭区间 [i, j]为空时跳出），跳出时，变量 i 和 j分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i即可。\n" + "\n" + "常错点：正常应该是相对应的，数与下标都是相等的，所以如果nums[m] = m，那应该是i=m+1。另外，if(nums[m] == m)后面直接跟else就行了，不要加东西，表示则 “左子数组的末位元素” 一定在闭区间 [i, m - 1] 中，因此执行 j = m - 1；\n" + "\n" + "class Solution {\n" + "    public int missingNumber(int[] nums) {\n" + "        int i = 0, j = nums.length - 1;\n" + "        while(i <= j) {\n" + "            int m = (i + j) / 2;\n" + "            if(nums[m] == m) i = m + 1;\n" + "            else j = m - 1;\n" + "        }\n" + "        return i;\n" + "    }\n" + "}\n" + "\n" + "O(logN)： 二分法为对数级别复杂度。\n" + "O(1)： 几个变量使用常数大小的额外空间。"
        const val two_array_find = "二维数组中的查找"
        const val two_array_find_answer = "核心思想：示例九宫格147、258、369，左上最小，右下最大。目标位大于taget，向上移消去一行，目标位小于target就向右移列加1。\n" + "\n" + "常错点：行长度是外面matrix.length，而列长度是matrix[0].length。\n" + "\n" + "class Solution {\n" + "    public boolean findNumberIn2DArray(int[][] matrix, int target) {\n" + "        int row = matrix.length - 1, column = 0;\n" + "        while(row >= 0 && column < matrix[0].length)\n" + "        {\n" + "            if(matrix[row][column] > target) row—;\n" + "            else if(matrix[row][column] < target) column++;\n" + "            else return true;\n" + "        }\n" + "        return false;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(M+N) ：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N 次。\n" + "空间复杂度 O(1) : i, j 指针使用常数大小额外空间。"
        const val rotation_small = "旋转数组的最小数字"
        const val rotation_small_answer = "核心思想：找旋转点，通过二分法来找，如果中间位num[m]小于最右测，则说明最小值旋转点至少还在左边j = m，如果中间位比最右测数据大，那还会在右测i = m+1;  因为有连续相等的情况，如果相等，最右侧就向左移一位。最后当跳出循环，就是结果值num[i]\n" + "\n" + "常错点：因为是数组下标，所以在比较时，是nums[m]与nums[i]、nums[j]比较，不是直接和i和j比较。\n" + "\n" + "class Solution {\n" + "    public int minArray(int[] numbers) {\n" + "        int i = 0,j = numbers.length-1;\n" + "        while(i<j){\n" + "            int m = (i+j)/2;\n" + "            if(numbers[i]>numbers[m]) j = m;\n" + "            else if(numbers[m]>numbers[j]) i = m+1;\n" + "            else j--;\n" + "        }\n" + "        return numbers[i];\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(log_2 N)： 在特例情况下（例如 [1, 1, 1, 1]），会退化到 O(N))。\n" + "空间复杂度 O(1) ： i , j , m 变量使用常数大小的额外空间。"
        const val once_show_char = "第一个只出现一次的字符"
        const val once_show_char_answer = "核心思想：创建一HashMap，把字符串转成charArray数组，再把其中的每个字节当成key，boolean当做值,每一遍，全存true，第二回里面有了，就填成false。通过HashMap的containsKey方法，把是否包含K当val，只存了一回返回true的字节返回。\n" + "\n" + "class Solution {\n" + "    public char firstUniqChar(String s) {\n" + "        HashMap<Character, Boolean> dic = new HashMap<>();\n" + "        char[] sc = s.toCharArray();\n" + "        for(char c : sc)\n" + "            dic.put(c, !dic.containsKey(c));\n" + "        for(char c : sc)\n" + "            if(dic.get(c)) return c;\n" + "        return ' ';\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N)： N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；HashMap 查找操作的复杂度为 O(1) ；\n" + "空间复杂度 O(1) ： 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用O(26)=O(1) 的额外空间。"
        const val println_tree_node = "从上到下打印二叉树"
        const val println_tree_node_answer = "核心思想：先判空，为null就返回个空int[]。外层无逻辑，初始化queue与装数字的list，用queue装上TreeNode就完事，然后在while循环内，把queue.poll()出来的node值装到list里，然后把左右子树装入queue。当所有的node都装完后，建一个和list同长的int[]，然后用for循环赋值过去，最后完成。\n" + "\n" + "易错点：while内记得把左右节点装到offer中，queue没有push、pop，用的是offer、poll。\n" + "\n" + "class Solution {\n" + "    public int[] levelOrder(TreeNode root) {\n" + "        if(root == null) return new int[0];\n" + "        Queue<TreeNode> queue = new LinkedList<>();\n" + "        ArrayList<Integer> ans = new ArrayList<>();\n" + "        queue.offer(root);\n" + "        while(!queue.isEmpty()) {\n" + "            TreeNode node = queue.poll();\n" + "            ans.add(node.val);\n" + "            if(node.left != null) queue.offer(node.left);\n" + "            if(node.right != null) queue.offer(node.right);\n" + "        }\n" + "        int[] res = new int[ans.size()];\n" + "        for(int i = 0; i < ans.size(); i++)\n" + "            res[i] = ans.get(i);\n" + "        return res;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次。\n" + "空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。"
        const val println_tree_node_zhi = "之字型打印二叉数"
        const val println_tree_node_zhi_answer ="核心思想：先创建个空二维list，然后判空。外层无逻辑，都是用queue装上TreeNode就完事，然后在while循环内，创建可以双向存值的LinkedList-level，与当前层的个数currentLevelSize，再用for循环按res的奇偶层进行存值，在本轮while内，把level装入res里，最后返回res。\n" + "\n" + "常错点：判断奇偶性是通过res总list判断，不是queue。 if(res.size() % 2 == 0) \n" + "\n" + "class Solution {\n" + "    public List<List<Integer>> levelOrder(TreeNode root) {\n" + "        List<List<Integer>> res = new ArrayList();\n" + "        if (root == null) return res;\n" + "\n" + "        Queue<TreeNode> queue = new LinkedList();\n" + "        queue.offer(root);\n" + "        while (!queue.isEmpty()) {\n" + "            LinkedList<Integer> level = new LinkedList();\n" + "            int currentLevelSize = queue.size();\n" + "            for (int i = 0; i < currentLevelSize; i++) {\n" + "                TreeNode node = queue.poll();\n" + "\n" + "                if(res.size() % 2 == 0) level.addLast(node.val); // 偶数层 -> 队列头部\n" + "                else level.addFirst(node.val); // 奇数层 -> 队列尾部\n" + "\n" + "                if (node.left != null) queue.offer(node.left);\n" + "                if (node.right != null) queue.offer(node.right);\n" + "            }\n" + "            res.add(level);\n" + "        }\n" + "        return res;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。\n" + "空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点 同时 在 queue 中，使用 O(N) 大小的额外空间。"
        const val tree_is_sub = "树的子结构"
        const val tree_is_sub_answer = "核心思想：AB不为空，并且，按先序顺序，中左右调用有一个通过即可。recur判断函数中，B空返回ture，Anull或不相等返回false，要不就让他们左右子树再判断。\n" + "\n" + "易错点：返回的先序，只有根节点是recure，左右调的是isSubStructure方法\n" + "\n" + "class Solution {\n" + "    public boolean isSubStructure(TreeNode A, TreeNode B) {\n" + "        return (A != null && B != null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));\n" + "    }\n" + "    boolean recur(TreeNode A, TreeNode B) {\n" + "        if(B == null) return true;\n" + "        if(A == null || A.val != B.val) return false;\n" + "        return recur(A.left, B.left) && recur(A.right, B.right);\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(MN) ： 其中 M,N分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N) 。\n" + "空间复杂度 O(M) ： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M>N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。"
        const val tree_left_to_right = "二叉树的镜像"
        const val tree_left_to_right_answer = "核心思想：先判空，递归获取左右节点，然后把root的左右子节点进行互换，返回root。与链表返回逻辑相似。\n" + "\n" + "class Solution {\n" + "    public TreeNode mirrorTree(TreeNode root) {\n" + "        if (root == null) {\n" + "            return null;\n" + "        }\n" + "        TreeNode left = mirrorTree(root.left);\n" + "        TreeNode right = mirrorTree(root.right);\n" + "        root.left = right;\n" + "        root.right = left;\n" + "        return root;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度：O(N)，其中 N 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。\n" + "\n" + "空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。"
        const val symmetry_tree = "判断对称的二叉数"
        const val symmetry_tree_answer = "核心思想：三目判空，或调用recure把左右子树传入。recure中，如果双空返回true，其中一方为空，或值不等，返回false。以上都不满足，说明还有子树，继续把左右子树左右对称，并以并且关系递归传入\n" + "\n" + "class Solution {\n" + "    public boolean isSymmetric(TreeNode root) {\n" + "        return root == null ? true : recur(root.left, root.right);\n" + "    }\n" + "    boolean recur(TreeNode L, TreeNode R) {\n" + "        if(L == null && R == null) return true;\n" + "        if(L == null || R == null || L.val != R.val) return false;\n" + "        return recur(L.left, R.right) && recur(L.right, R.left);\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： 其中 NN 为二叉树的节点数量，每次执行 recur() 可以判断一对节点是否对称，因此最多调用 N/2 次 recur() 方法。\n" + "空间复杂度 O(N) ： 最差情况下（见下图），二叉树退化为链表，系统使用 O(N) 大小的栈空间。"
        const val fei_bo_na_qi = "斐波那契数列"
        const val fei_bo_na_qi_answer = "核心思想：sum是从3开始的，n=1时，a = 0,b = 1,sum = 1。所以最后的sum是多出2次的，直接返回a即可。\n" + "\n" + "class Solution {\n" + "    public int fib(int n) {\n" + "        int a = 0, b = 1, sum;\n" + "        for(int i = 0; i < n; i++){\n" + "            sum = (a + b) % 1000000007;\n" + "            a = b;\n" + "            b = sum;\n" + "        }\n" + "        return a;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。\n" + "空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。"
        const val qi_wa_jump_tai_jie= "青蛙跳台阶"
        const val qi_wa_jump_tai_jie_answer= "核心思想：此问题基本与斐波那契数列一至，只是斐波那契是从0开始，而青蛙跳台阶是从1开始，sum初始是从n = 2开始算的，也就是求n级台阶的跳法，要取n-2，也就是a的值。斐波那契：n = (n-1)+(n-2)\n" + "\n" + "class Solution {\n" + "    public int numWays(int n) {\n" + "        int a= 1,b=1,sum;\n" + "        for(int i = 0;i<n;i++){\n" + "            sum =(a+b)%1000000007;\n" + "            a = b;\n" + "            b = sum;\n" + "        }\n" + "        return a;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。\n" + "空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。\n"
        const val stock_match_money= "股票的最大利润"
        const val stock_match_money_answer= "核心思想：先设边界值，防止极限情况。因为有限定买卖该股票一次，所以cost要取最低值Math.min(历史最低值, price)，然后最大利润就是最高值就通过Math.max(历史最高值, price - 最低值)来获取了。\n" + "\n" + "易错点：cost = Math.min(cost,price),是price 不是0。两个都有price参与\n" + "\n" + "class Solution {\n" + "    public int maxProfit(int[] prices) {\n" + "        int cost = Integer.MAX_VALUE, profit = 0;\n" + "        for(int price : prices) {\n" + "            cost = Math.min(cost, price);\n" + "            profit = Math.max(profit, price - cost);\n" + "        }\n" + "        return profit;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： 其中 N 为 prices 列表长度，动态规划需遍历 prices。\n" + "空间复杂度 O(1) ： 变量 cost 和 profit 使用常数大小的额外空间。"
        const val binary_search = "二分查找"
        const val binary_search_answer = "核心思想：二分查找定义查找的范围 [left,right]，初始查找范围是整个数组。每次取查找范围的中点 mid，比较nums[mid] 和target 的大小，如果相等则 mid 即为要寻找的下标，如果不相等则根据 nums[mid] 和target 的大小关系将查找范围缩小一半。\n" + "\n" + "常错点： while条件是left≤right，因为有可能数组内是没有target的，如果没有对应taget是要返-1的。另外，if(){}  else if(){}这块别省略，容易出逻辑错误。\n" + "\n" + "class Solution {\n" + "    public int search(int[] nums, int target) {\n" + "        int left = 0,right = nums.length -1;\n" + "        while(left<=right){\n" + "            int mid = (left +right)/2;\n" + "            if(nums[mid]>target){\n" + "                right = mid-1;\n" + "            }else if(nums[mid]<target){\n" + "                left = mid+1;\n" + "            }else{\n" + "                return mid;\n" + "            } \n" + "        }\n" + "        return -1;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度：O(logn)，其中 n 是数组的长度。\n" + "空间复杂度：O(1)。"
        const val continue_max_sum = "连续子数组的最大和"
        const val continue_max_sum_answer = "核心思想：先设结果等于第一位，然后从n=1启for循环，两位两位相加，当前值等于当前值加上最大上一位：cur = cur +max( prve , 0 );。最大结果等于结果与叠加后的当前值，拿cur与总结果res比较  res = max( res , cur ); 最后返回结果\n" + "\n" + "class Solution {\n" + "    public int maxSubArray(int[] nums) {\n" + "        int res = nums[0];\n" + "        for(int i = 1; i < nums.length; i++) {\n" + "            nums[i] += Math.max(nums[i - 1], 0);\n" + "            res = Math.max(res, nums[i]);\n" + "        }\n" + "        return res;\n" + "    }\n" + "\n" + "时间复杂度 O(N) ： 线性遍历数组 numsnums 即可获得结果，使用 O(N) 时间。\n" + "空间复杂度 O(1) ： 使用常数大小的额外空间。"
        const val gift_max_value = "礼物的最大价值"
        const val gift_max_value_answer = "核心思想：f(i,j) 等于 f(i,j-1) 和 f(i-1,j) 中的较大值加上当前单元格礼物价值 grid(i,j) 。有四种情况，都是0，i为0，j为0，都不为0；通过双循环计算得到结果grid[m - 1][n - 1];\n" + "\n" + "常错点：循环内判断，if和else if别简写，逻辑会出错。\n" + "\n" + "class Solution {\n" + "    public int maxValue(int[][] grid) {\n" + "        int m = grid.length,n = grid[0].length;\n" + "        for(int i = 0;i<m;i++){\n" + "            for(int j = 0;j<n;j++){\n" + "                if(i==0&&j==0){\n" + "                    continue;\n" + "                }else if(i==0){\n" + "                    grid[i][j] += grid[i][j-1];\n" + "                }else if(j==0){\n" + "                    grid[i][j] +=grid[i-1][j];\n" + "                }else{\n" + "                    grid[i][j] +=Math.max(grid[i-1][j],grid[i][j-1]);\n" + "                }\n" + "            }\n" + "        }\n" + "        return grid[m-1][n-1];\n" + "    }\n" + "}\n" + "\n" + "\n" + "时间复杂度 O(MN) ： M, N 分别为矩阵行高、列宽；动态规划需遍历整个 grid 矩阵，使用 O(MN) 时间。\n" + "空间复杂度 O(1) ： 原地修改使用常数大小的额外空间。"
        const val num_to_string = "把数字翻译成字符串"
        const val num_to_string_answer = "核心思想：从左到右，如果前两位通过ASC码判断值在10与25之间，那说明当前位等于前两位之和，否则等于最近一位。\n" + "\n" + "常错点：因为length+1了，所以for循环可以是i<=s.length()。还有做区间判断时，是>=10与<=25,等于边界值j和z也是可以的。\n" + "\n" + "class Solution {\n" + "    public int translateNum(int num) {\n" + "        String s = String.valueOf(num);\n" + "        int[] dp = new int[s.length()+1];\n" + "        dp[0] = 1;\n" + "        dp[1] = 1;\n" + "        for(int i = 2; i <= s.length(); i ++){\n" + "            String temp = s.substring(i-2, i);\n" + "            if(temp.compareTo(\"10\") >= 0 && temp.compareTo(\"25\") <= 0)\n" + "                dp[i] = dp[i-1] + dp[i-2];\n" + "            else\n" + "                dp[i] = dp[i-1];\n" + "        }\n" + "        return dp[s.length()];\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： N 为字符串 s 的长度（即数字 num 的位数 log(num)），其决定了循环次数。\n" + "空间复杂度 O(N) ： 字符串 s 使用 O(N) 大小的额外空间。"
        const val long_no_repeat_string = "最长不含重复字符的子字符串"
        const val long_no_repeat_string_answer = "核心思想：滑动窗口长度内，无重复数字即生效，窗口长度+1。通过hashmap来存它的索引，如果有，就相减算一下值是否大于目前滑动窗口的大小 ，大于就窗口加1，不大于就重新算窗口值。\n" + "\n" + "class Solution {\n" + "    public int lengthOfLongestSubstring(String s) {\n" + "        Map<Character, Integer> map = new HashMap<>();\n" + "        int res = 0, size = 0;  // size是滑动窗口长度\n" + "        for(int right = 0; right < s.length(); right++) {\n" + "            int leftRepeatIndex = map.getOrDefault(s.charAt(right), -1); // 获取索引 i\n" + "            map.put(s.charAt(right), right); // 更新哈希表\n" + "            if(size<right-leftRepeatIndex) size = size + 1;\n" + "            else size = right - leftRepeatIndex;      \n" + "            res = Math.max(res, size); // max(dp[j - 1], dp[j])\n" + "        }\n" + "        return res;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N)O(N) ： 其中 N 为字符串长度，动态规划需遍历计算 dp 列表。\n" + "空间复杂度 O(1)O(1) ： 字符的 ASCII 码范围为 0 ~ 127 ，哈希表 map 最多使用 O(128) = O(1)大小的额外空间。"
        const val ji_ou_separate = "调整数组顺序使奇数位于偶数前面"
        const val ji_ou_separate_answer = "核心思想：先通过一个大的while循环，条件是i<j，把所有元素都遍历，然后内部再用两个小while循环，从两头进行移位判断，如果i是奇数就++，j是偶数就减--，然后通过tmp进行交换，当遍历结束时，直接返回数组。a&1 = 0 位运算，a为偶。\n" + "\n" + "class Solution {\n" + "    public int[] exchange(int[] nums) {\n" + "        int i = 0, j = nums.length - 1, tmp;\n" + "        while(i < j) {\n" + "            while(i < j && (nums[i] & 1) == 1) i++;\n" + "            while(i < j && (nums[j] & 1) == 0) j--;\n" + "            tmp = nums[i];\n" + "            nums[i] = nums[j];\n" + "            nums[j] = tmp;\n" + "        }\n" + "        return nums;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。\n" + "空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。\n"
        const val sum_is_s = "和为s的两个数字"
        const val sum_is_s_answer = "核心思想：通过while循环，配合条件i<j遍历数组，先算出nums[i]、nums[j]的和，然后进行判断，如果小于target i++,如果大于target j - -，如果相等则返回\n" + "\n" + "class Solution {\n" + "    public int[] twoSum(int[] nums, int target) {\n" + "        int i = 0, j = nums.length - 1;\n" + "        while(i < j) {\n" + "            int s = nums[i] + nums[j];\n" + "            if(s < target) i++;\n" + "            else if(s > target) j--;\n" + "            else return new int[] { nums[i], nums[j] };\n" + "        }\n" + "        return new int[0];\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： N 为数组 nums 的长度；双指针共同线性遍历整个数组。\n" + "空间复杂度 O(1) ： 变量 i, j 使用常数大小的额外空间。"
        const val reverse_word = "翻转单词顺序"
        const val reverse_word_answer = "核心思想：先删除首尾空格，分割字符串。然后创建builder倒序添加单词\n" + "\n" + "易错点：倒序遍历时要先判断空单词的情况。\n" + "\n" + "class Solution {\n" + "    public String reverseWords(String s) {\n" + "        String[] strs = s.trim().split(\" \"); // 删除首尾空格，分割字符串\n" + "        StringBuilder res = new StringBuilder();\n" + "        for(int i = strs.length - 1; i >= 0; i--) { // 倒序遍历单词列表\n" + "            if(strs[i].equals(\"\")) continue; // 遇到空单词则跳过\n" + "            res.append(strs[i] + \" \"); // 将单词拼接至 StringBuilder\n" + "        }\n" + "        return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： 总体为线性时间复杂度\n" + "空间复杂度 O(N) ： 单词列表 strs 占用线性大小的额外空间。\n"
        const val n_println = "打印从1到最大的n位数"
        const val n_println_answer = "核心思想：不考虑大数，10的n次幂，(int)Math.pow(10,n)，结果值也就是end-1，然后通过for循环赋值返回。\n" + "\n" + "class Solution {\n" + "    public int[] printNumbers(int n) {\n" + "        int end = (int)Math.pow(10, n) - 1;\n" + "        int[] res = new int[end];\n" + "        for(int i = 0; i < end; i++)\n" + "            res[i] = i + 1;\n" + "        return res;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(10^n) ： 生成长度为 10^n  的列表需使用 O(10^n) 时间。\n" + "空间复杂度 O(1) ： 建立列表需使用 O(1) 大小的额外空间（ 列表作为返回结果，不计入额外空间 ）。"
        const val binary_number_deep = "二叉树的深度"
        const val binary_number_deep_answer = "核心思想：树的层序遍历 / 广度优先搜索往往利用 队列 实现。每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。\n" + "\n" + "class Solution {\n" + "    public int maxDepth(TreeNode root) {\n" + "        int res = 0;\n" + "        if(root == null) return res;\n" + "        Queue<TreeNode> queue = new LinkedList();\n" + "        queue.offer(root);\n" + "        while(!queue.isEmpty()){\n" + "            int currentLevelSize = queue.size();\n" + "            for(int i = 0;i<currentLevelSize;i++){\n" + "                TreeNode node = queue.poll();\n" + "                if(node.left!=null) queue.offer(node.left);\n" + "                if(node.right!=null) queue.offer(node.right);\n" + "            }\n" + "            res++;\n" + "        }\n" + "        return res;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。\n" + "空间复杂度 O(N) ：最差情况下（当树平衡时），队列 queue 同时存储 N/2个节点。"
        const val path_sum = "二叉树中和为某一值的路径"
        const val path_sum_answer = "易错点：创建res时，第二个是List不是LinkedList，要不返回会报错\n" + "\n" + "class Solution {\n" + "    LinkedList<List<Integer>> res = new LinkedList();\n" + "    LinkedList<Integer> path = new LinkedList();\n" + "    public List<List<Integer>> pathSum(TreeNode root, int target) {\n" + "        recure(root,target);    // 6、调用返回\n" + "        return res;\n" + "    }\n" + "\n" + "    void recure(TreeNode root,int tar){   \n" + "        if(root == null) return;   // 1、创建recur执行方法，判空直接返回。\n" + "        path.add(root.val);\n" + "        tar -= root.val;    // 2、把tar放入目录，并修改tar的值。\n" + "        if(tar == 0&&root.left == null&&root.right == null)\n" + "            res.add(new LinkedList(path));  // 3、如果目前值到到，且左右子树为Null，就把new一个path放到res中\n" + "        recure(root.left,tar);  // 4、把root的左右子树递归recure\n" + "        recure(root.right,tar);\n" + "        path.removeLast();  //  5、如果不成立，清除后加入的节点。\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： NN 为二叉树的节点数，先序遍历需要遍历所有节点。\n" + "空间复杂度 O(N) ： 最差情况下，即树退化为链表时，path 存储所有树节点，使用 O(N) 额外空间。"
        const val binary_num_two_node = "二叉搜索树与双向链表"
        const val binary_num_two_node_answer = "核心思想：排序的循环双链表，因为是二叉搜索树，所以中序是递增的，首尾还要相连。\n" + "\n" + "易错点：深度优先搜索中，当建立完两节点指针，要进一位，prv = cur;\n" + "\n" + "class Solution {\n" + "    Node prev,head;\n" + "    public Node treeToDoublyList(Node root) {\n" + "        if(root == null) return null;\n" + "        dfs(root);\n" + "        head.left = prev;   \n" + "        prev.right = head;\n" + "        return head;\n" + "    }\n" + "\n" + "    void dfs(Node cur){\n" + "        if(cur == null) return; //  1、判空\n" + "        dfs(cur.left);          //  2、中序第一步，遍历左节点\n" + "\n" + "        cur.left = prev;        //  4、左子树等于prev\n" + "\n" + "        if(prev == null){       //  6、prev为空，说明还未初始化，head == cur初始化，prev的left 为cur\n" + "            head = cur;\n" + "        }else{\n" + "            prev.right = cur;   //  5、这一步和第四步相呼应\n" + "        }\n" + "    \n" + "        prev = cur;             //  7、完成当前节点后，更新prev的值到下一节点。\n" + "        dfs(cur.right);         //  3、中序第三步，遍历右节点\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： N 为二叉树的节点数，中序遍历需要访问所有节点。\n" + "空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N)栈空间。"
        const val binary_num_k_big = "二叉搜索树的第k大节点"
        const val binary_num_k_big_answer = "核心思想：二叉搜索树的 中序遍历倒序 为 递减序列。因此，求 “二叉搜索树第 k大的节点” 可转化为求 “此树的中序遍历倒序的第 k 个节点”。\n" + "\n" + "class Solution {\n" + "    int res,k;\n" + "    public int kthLargest(TreeNode root, int k) {\n" + "        this.k = k;\n" + "        dfs(root);  \n" + "        return res;  // 4、调用并返回结果\n" + "    }\n" + "\n" + "    void dfs(TreeNode root){\n" + "        if(root == null) return;    \n" + "        dfs(root.right);    // 1、判空，并中序倒序，先放入右子树\n" + "        if(k == 0) return;\n" + "        if(--k == 0) res = root.val;    // 2、找到第K个节点\n" + "        dfs(root.left);    // 3、没有就继续按中序倒序，右左顺序放节点。\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 O(N)时间。\n" + "空间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），系统使用 O(N)大小的栈空间。"
        const val joker_shun_zi = "扑克牌中的顺子"
        const val joker_shun_zi_answer = "核心思想：先设一个joker变量，等记录大小王，然后再把数组进行排序，然后创建一个for循环，条件i<4，然后先判断是否==0，等于0 joker++，然后是else if  i张与i+1张如果相同，肯定不是顺子，返回false。最后用最大牌nums[4]减去除去王的最小牌nums[i]，如果小于5，就是顺子。\n" + "\n" + "易错点：要把数组进行排序\n" + "\n" + "class Solution {\n" + "    public boolean isStraight(int[] nums) {\n" + "        int joker = 0;\n" + "        Arrays.sort(nums); // 数组排序\n" + "        for(int i = 0; i < 4; i++) {\n" + "            if(nums[i] == 0) joker++; // 统计大小王数量\n" + "            else if(nums[i] == nums[i + 1]) return false; // 若有重复，提前返回 false\n" + "        }\n" + "        return nums[4] - nums[joker] < 5; // 最大牌 - 最小牌 < 5 则可构成顺子\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(NlogN)=O(5log5)=O(1) ： 其中 N 为 nums 长度，本题中 N≡5 ；数组排序使用 O(NlogN) 时间。\n" + "空间复杂度 O(1) ： 变量 joker 使用 O(1) 大小的额外空间。"
        const val singleton_three = "三种单例写法"
        const val singleton_three_answer = "\n" + "/*\n" + " * 饿汉单例\n" + " * 优点：没有加锁，执行效率会提高。\n" + " * 缺点：类加载时就初始化，浪费内存。\n" + " * */\n" + "\n" + "public class Singleton{\n" + "\tprivate static Singleton instance = new Singleton();\n" + "\tprivate Singleton(){}\n" + "\tpublic Singleton getInstence(){\n" + "\t\treturn instance;\n" + "\t}\n" + "}\n" + "\n" + "\n" + "\n" + "/*\n" + " * 懒汉单例\n" + " * 优点：第一次调用才初始化，避免内存浪费。\n" + " * 缺点：必须加锁synchronized 才能保证单例，如果多个线程调用，会影响效率\n" + " * */\n" + "\n" + "public class Singleton{\n" + "\tprivate static Singleton instance;\n" + "\tprivate Singleton(){}\n" + "\tpublic static synchronized Singleton getInstence(){\n" + "\t\tif(singleton == null){\n" + "\t\t\tinstance = new Singleton();\n" + "\t\t}\n" + "\t\treturn instance;\n" + "\t}\n" + "}\n" + "\n" + "\n" + "/*\n" + " * 双重锁单例\n" + " * 优点：资源利用率高，第一次执行方法是单例对象才会被实例化。\n" + " * 缺点：第一次加载时会稍慢，重排序问题jdk1.5之后，加volatile来约束乱序排行。\n" + " * 就算在单例类被实例化时有多个线程同时通过了第8行代码 if (instance == null) 的判断，但\n" + " * 同一时间只有一个线程获得锁后进入临界区。通过第8行判断的每个线程会依次获得锁进入临界区，所\n" + " * 以进入临界区后还要再判断一次单例类是否已被其它线程实例化，以避免多次实例化\n" + " * */\n" + "\n" + "public class Singleton{\n" + "\tprivate static volatile Singleton instance;\n" + "\tprivate Singleton(){}\n" + "\tpublic static Singleton getInstance(){\n" + "\t\tif(instance == null){\n" + "\t\t\tsynchronized(Singleton.class){\n" + "\t\t\t\tif(instance == null)\n" + "\t\t\t\t\tinstance = new Singleton();\n" + "\t\t\t}\n" + "\t\t}\n" + "\t\treturn instance;\n" + "\t}\n" + "}"
        const val one_add_to_n = "求1+2+…+n"
        const val one_add_to_n_answer = "迭代法：\n" + "\n" + "public int sumNums(int n) {\n" + "    int res = 0;\n" + "    for(int i = 1; i <= n; i++)\n" + "        res += i;\n" + "    return res;\n" + "}\n" + "\n" + "\n" + "要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）\n" + "\n" + "class Solution {\n" + "    public int sumNums(int n) {  \n" + "        // 当 n = 1 时 n > 1 不成立 ，此时 “短路” ，终止后续递归\n" + "        boolean x = n > 1 && (n =n + sumNums(n - 1)) > 0;\n" + "        return n;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(n) ： 计算 n+(n−1)+...+2+1 需要开启 n 个递归函数。\n" + "空间复杂度 O(n) ： 递归深度达到 n ，系统使用 O(n) 大小的额外空间。"
        const val hamming_weight = "二进制中 1 的个数"
        const val hamming_weight_answer = "核心思想：先创建一个res结果，用于记录有几个，然后通过while循环，来过逐个判断，条件是n不等于0，每一轮循环，都对res加加，并把n与n-1的与运算赋值给n，最后跳出循环返回res\n" + "\n" + "public class Solution {\n" + "    public int hammingWeight(int n) {\n" + "        int res = 0;\n" + "        while(n != 0) {\n" + "            res++;\n" + "            n &= n - 1;    //  消去数字 n 最右边的1\n" + "        }\n" + "        return res;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(M) ： n&(n−1) 操作仅有减法和与运算，占用 O(1) ；设 M 为二进制数字 n 中 11 的个数，则需循环 M 次（每轮消去一个 1 ），占用 O(M) 。\n" + "空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。"
        const val small_k_num = "最小的K个数"
        const val small_k_num_answer = "核心思想：先利用快排对arr排序，然后创建一个k大小的数组，通过for循环，赋值新数组并返回。\n" + "快排步骤：先判断左节点是否大于等于右节点，是的话返回，然后让i=左，j = 右。然后开wile循环，条件i<j，如果j位大于等于哨兵left位，就j--，i位小于等于哨兵位，就i++,然后得到两个错位的数，把两个大小错位的进行调换，再把i和哨兵调换，最后递归两边left到i-1，i+1到right。\n" + "\n" + "易错点：快排先判断是否left>=right，成立就return。while循环内，是两个while循环在不停的调整i和j的位置。不是if\n" + "\n" + "class Solution {\n" + "    public int[] getLeastNumbers(int[] arr, int k) {\n" + "        quickSort(arr,0,arr.length-1);\n" + "        int[] res = new int[k];\n" + "        for(int i = 0;i<k;i++){\n" + "            res[i] = arr[i];\n" + "        }\n" + "        return res;\n" + "    }\n" + "    \n" + "   private void quickSort(int[] arr, int left, int right) {\n" + "        if (left >= right) return;   // 子数组长度为 1 时终止递归\n" + "        \n" + "        int i = left, j = right;   // 哨兵划分操作（以 arr[l] 作为基准数）\n" + "        while (i < j) {\n" + "            while (i < j && arr[j] >= arr[left]) j--;\n" + "            while (i < j && arr[i] <= arr[left]) i++;\n" + "            swap(arr, i, j);\n" + "        }\n" + "        swap(arr, i, left);\n" + "\n" + "        quickSort(arr, left, i - 1);    // 递归左（右）子数组执行哨兵划分\n" + "        quickSort(arr, i + 1, right);\n" + "    }\n" + "\n" + "    private void swap(int[] arr, int i, int j) {\n" + "        int tmp = arr[i];\n" + "        arr[i] = arr[j];\n" + "        arr[j] = tmp;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(NlogN) ： 库函数、快排等排序算法的平均时间复杂度为 O(NlogN) 。\n" + "空间复杂度 O(N) ： 快速排序的递归深度最好（平均）为O(logN) ，最差情况（即输入数组完全倒序）为 O(N)。\n"
        const val quick_sort = "快速排序"
        const val quick_sort_answer = "易错点：快排while循环内，是两个while循环在不停的调整i和j的位置。不是if\n" + "\n" + "private void quickSort(int[] arr, int left, int right) {\n" + "        if (left >= right) return;   // 子数组长度为 1 时终止递归\n" + "        \n" + "        int i = left, j = right;   // 哨兵划分操作（以 arr[l] 作为基准数）\n" + "        while (i < j) {\n" + "            while (i < j && arr[j] >= arr[left]) j--;\n" + "            while (i < j && arr[i] <= arr[left]) i++;\n" + "            swap(arr, i, j);\n" + "        }\n" + "        swap(arr, i, left);\n" + "\n" + "        quickSort(arr, left, i - 1);    // 递归左（右）子数组执行哨兵划分\n" + "        quickSort(arr, i + 1, right);\n" + "    }\n" + "\n" + "    private void swap(int[] arr, int i, int j) {\n" + "        int tmp = arr[i];\n" + "        arr[i] = arr[j];\n" + "        arr[j] = tmp;\n" + "    }\n" + "\n" + "\n" + "时间复杂度 O(NlogN) ： O(NlogN) 。\n" + "空间复杂度 O(N) ： 快速排序的递归深度最好（平均）为O(logN) ，最差情况（即输入数组完全倒序）为 O(N)。\n"
        const val is_balance_tree = "是否是平衡二叉树"
        const val is_balance_tree_answer = "核心思想：通过判断左右子树相减的绝对值是否小于等于1，来决定是不是平衡二叉数。步骤1先写个dpeth方法，用来计算当前节点深度，把root传入，如果为空直接返回null，然后取root的左右子树的最大值，再进行加1操作返回。步骤2返回dpeth左子树与dpeth右子树的绝对值是否小于等于1，并且用总方法递归左右子树。\n" + "\n" + "class Solution {\n" + "    public boolean isBalanced(TreeNode root) {\n" + "        if (root == null) return true;\n" + "        return Math.abs(depth(root.left) - depth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);   // 如果左右子树绝对值小于1，并且左右子树的子树节点都平衡，返回true。\n" + "    }\n" + "\n" + "    private int depth(TreeNode root) {\n" + "        if (root == null) return 0;\n" + "        return Math.max(depth(root.left), depth(root.right)) + 1;  // 计算左右子树的深度。\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(NlogN)： 最差情况下（为 “满二叉树” 时）， isBalanced(root) 遍历树所有节点，判断每个节点的深度 depth(root) 需要遍历 各子树的所有节点 。\n" + "空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。"
        const val search_nearly_ancestor = "二叉搜索树的最近公共祖先"
        const val search_nearly_ancestor_answer = "class Solution {\n" + "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n" + "        if(root.val < p.val && root.val < q.val)\n" + "            return lowestCommonAncestor(root.right, p, q);\n" + "        if(root.val > p.val && root.val > q.val)\n" + "            return lowestCommonAncestor(root.left, p, q);\n" + "        return root;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： 其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 logN （满二叉树），最大为 N （退化为链表）。\n" + "空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到树的层数 N 。"
        const val nearly_ancestor = "二叉树的最近公共祖先"
        const val nearly_ancestor_answer = "核心思想：公共祖先就是root等于p或q，或pq在root的左右子树上，就是。步骤：如果root等于null或等于p或等于q，就返回root,然后创建左右两节点，通过递归传入root的左右节点获取的。再做判断，如果左为null就返回右子树，如果右为null就返回左子树。最终返回root。\n" + "\n" + "class Solution {\n" + "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n" + "        if(root == null || root == p || root == q) return root;\n" + "        TreeNode left = lowestCommonAncestor(root.left, p, q);\n" + "        TreeNode right = lowestCommonAncestor(root.right, p, q);\n" + "        if(left == null) return right; //当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right\n" + "        if(right == null) return left;\n" + "        return root;\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(N) ： 其中 N 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。\n" + "空间复杂度 O(N) ： 最差情况下，递归深度达到 N ，系统使用 O(N) 大小的额外空间。"
        const val no_add_make_add = "不用加减乘除做加法"
        const val no_add_make_add_answer = "核心思想：如果b为0就直接返回，然后就返回递归本函数。参数一是ab异或运算，参数二是ab与运算且左跳1位。\n" + "\n" + "class Solution {\n" + "    public int add(int a, int b) {\n" + "        if (b == 0) {\n" + "            return a;\n" + "        }\n" + "        \n" + "        // 转换成非进位和 + 进位\n" + "        return add(a ^ b, (a & b) << 1);\n" + "    }\n" + "}\n" + "\n" + "时间复杂度 O(1) ： 最差情况下 ，需循环 32 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1) 时间。\n" + "空间复杂度 O(1) ： 使用常数大小的额外空间。"
        const val many_num = "数组中出现次数超过一半的数字"
        const val many_num_answer = "核心思想：超过一半，所以中间值一定是结果\n" + "\n" + "class Solution {\n" + "    public int majorityElement(int[] nums) {\n" + "        Arrays.sort(nums);\n" + "        int res = nums.length/2;\n" + "        return nums[res];\n" + "    }\n" + "}\n" + "\n" + "还有一种是最多的数是众数，这种就是先把数存到map中，然后一个一个比较次数的大小，把大的返回。\n" + "\n" + " class Solution {\n" + "    public int majorityElement(int[] nums) {\n" + "        HashMap<Integer,Integer> map = new HashMap();\n" + "        int count = 0,ans = 0;\n" + "        for(int i = 0;i<nums.length;i++){\n" + "            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\n" + "        }\n" + "        for(int i:nums){\n" + "            if(map.get(i)>count){\n" + "                count = map.get(i);\n" + "                ans = i;\n" + "            }          \n" + "        }\n" + "        return ans;\n" + "    }\n" + "}\n"

    }
}

