package com.example.kotlin.data

/**
 * Author: sym
 * Date: 2021/7/13 8:11 PM
 * Describe:
 */
 class AlgorithmQA{

    companion object {
        const val reverse_list = "算法反转链表"
        const val reverse_list_answer = "class Solution {\n" + "    public ListNode reverseList(ListNode head) {\n" + "        if(head == null||head.next == null){\n" + "            return head;\n" + "        }\n" + "        ListNode cur = reverseList(head.next);\n" + "        head.next.next = head;\n" + "        head.next = null;\n" + "        return cur;\n" + "    }\n" + "}\n" + "\n" + "链表反转是用递归来实现，共有六步\n" + "第1步写方法reverseList，传入节点head，返回节点ListNode\n" + " public ListNode reverseList(ListNode head)\n" + "\n" + "第2步：先做一层判断，触发终止时结束递归，并返回最后的节点head\n" + " if(head == null||head.next == null){\n" + "            return head;\n" + "  }\n" + "\n" + "第3步：然后创建一个要返回的节点，递归调用reverseList，传入下一个head.next，这里假设传1-2-3-4-5，那这一步会递归的执行5回\n" + " ListNode cur = reverseList(head.next);\n" + "\n" + "/** 从这步向下的三行代码，递归传入的会一轮一轮反执行回来 */\n" + "\n" + "第4步：比如4的next 是5，那4的next的next等于4，意思是让5指向4\n" + "head.next.next = head;\n" + "\n" + "第5步：现在head已经是4了，5已经指向4了，要把4指向5的置null\n" + "head.next = null;\n" + "\n" + "第6步：返回节点cur\n" + "return cur;\n" + "\n" + "\n" + "时间复杂度：O(n)其中 n是链表的长度。需要遍历链表一次。\n" + "空间复杂度：O(1)反转指针而已"
        const val has_cycle = "链表是否有环"
        const val has_cycle_answer = "class Solution {\n" + "    public boolean hasCycle(ListNode head) {\n" + "        ListNode slow = head,fast = slow;\n" + "        while(true){\n" + "            if(fast == null||fast.next == null){\n" + "                return false;\n" + "            }\n" + "            slow = slow.next;\n" + "            fast = fast.next.next;\n" + "            if(slow == fast) return true;\n" + "        }\n" + "    }\n" + "}\n" + "\n" + "判断链表是否有环，核心思想是创建一快一慢两个指针，慢的走1步，快的走2步，然后在while循环中两个一起向前走，如果两节点相待了，那就说明有环，否则就没有。共有六步\n" + "\n" + "第一步：创建方法hasCycle，参数为节点head，返回值为boolean\n" + "public boolean hasCycle(ListNode head)\n" + "\n" + "第二步：创建一慢一快两指针，slow等于节点，fast等于slow\n" + "ListNode slow = head,fast = slow;\n" + "\n" + "第三步：写一个while循环，条件是true，一直跑\n" + "while(true){\n" + "\n" + "第四步：如果fast全等于null，或fast.next全等于null，说明到头了，还没有相等相遇，没有环返回false\n" + "if(fast == null||fast.next == null){\n" + "    return false;\n" + "}\n" + "\n" + "第五步：slow节点前移一步，fast节点前移两步\n" + "slow = slow.next;\n" + "fast = fast.next.next;\n" + "\n" + "第六步：判断，如果slow全等于fast，说明相遇了有环，返回true\n" + "\n" + "时间复杂度：O(N)，其中 N 是链表中的节点数\n" + "空间复杂度：O(1)，我们只使用了两个指针的额外空间。\n"
        const val merge_two_lists = "合并两个有序链表"
        const val merge_two_lists_answer = "class Solution {\n" + "    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n" + "        ListNode dum  = new ListNode(0),cur = dum;\n" + "        while(l1 !=null&&l2 !=null){\n" + "            if(l1.val<l2.val){\n" + "                cur.next = l1;\n" + "                l1 = l1.next;\n" + "            }else{\n" + "                cur.next = l2;\n" + "                l2 = l2.next;\n" + "            }\n" + "            cur = cur.next;\n" + "        }\n" + "        cur.next = l1!=null?l1:l2;\n" + "        return dum.next;\n" + "    }\n" + "}\n" + "\n" + "链表l1,l2是递增的，因此核心思想是使用双指针l1和l2通过while循环遍历两链表，根据l1.val和l2.val的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。\n" + "\n" + "第一步：创建方法mergeTwoLists，返回节点ListNode，参数是l1、l2两个节点\n" + "public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n" + "\n" + "第二步：创建伪头部dum，还需要再创建一个cur，做为移动指针\n" + "ListNode dum  = new ListNode(0),cur = dum;\n" + "\n" + "第三步：创建while循环，条件是l1不等于null并且l2也不等于null\n" + "while(l1 !=null&&l2 !=null){\n" + "\n" + "第四步：比较l1的val值与l2的val值大小，如果l1的val小，把l1添加到cur后面，l1向后移一位\n" + "if(l1.val<l2.val){\n" + "    cur.next = l1;\n" + "    l1 = l1.next;\n" + "}\n" + "\n" + "第五步：如果l2的val小，把l2添加到cur后面，l2向后移一位\n" + "else{\n" + "    cur.next = l2;\n" + "    l2 = l2.next;\n" + "}\n" + "\n" + "第六步：指针cur向后移一位\n" + "cur = cur.next;\n" + "\n" + "第七步：有一方为null结束后，看还剩下谁，把不为null的放在cur后面\n" + "cur.next = l1!=null?l1:l2;\n" + "\n" + "第八步：返回伪头部后面的链表\n" + "return dum.next;\n" + "\n" + "\n" + "时间复杂度 O(M+N)O(M+N) ： M、N分别为链表 l1 、 l2 的长度，合并操作需遍历两链表\n" + "空间复杂度 O(1) ： 节点引用 dum , cur 使用常数大小的额外空间。\n" + "\n"
        const val k_th_from_end = "链表倒数第K个节点"
        const val k_th_from_end_answer = "class Solution {\n" + "    public ListNode getKthFromEnd(ListNode head, int k) {\n" + "        ListNode former = head, latter = head;\n" + "        for(int i = 0; i < k; i++)}\n" + "            former = former.next;\n" + "\t}\n" + "        while(former != null) {\n" + "            former = former.next;\n" + "            latter = latter.next;\n" + "        }\n" + "        return latter;\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建一前一后双指针，快的先前进K步，然后启动一个while循环，同步前进，当快的到头后，慢的就是倒数第K个节点。\n" + "\n" + "第一步：创建方法名为getKthFromEnd，返回参数为ListNode节点，参数有两个，一个是head节点，一个是相隔距离K\n" + "public ListNode getKthFromEnd(ListNode head, int k) {\n" + "\n" + "第二步：创建一前一后两个节点，都等于head\n" + "ListNode former = head, latter = head;\n" + "\n" + "第三步：创建个for循环，把前面的节点向前先移动K部\n" + "for(int i = 0; i < k; i++){\n" + "     former = former.next;\n" + "}\n" + "\n" + "第四步：创建一个while循环，条件是former不为null，然后former和latter同步前移\n" + " while(former != null) {\n" + "     former = former.next;\n" + "     latter = latter.next;\n" + " }\n" + "\n" + "第五步：返回慢的节点，也就是倒数第K个节点\n" + "return latter;\n" + "\n" + "\n" + "时间复杂度 O(N) ： N 为链表长度；总体看， former 走了 N 步， latter 走了 (N-k)步。\n" + "空间复杂度 O(1) ： 双指针 former , latter 使用常数大小的额外空间。"
        const val jump_steps = "青蛙跳台阶"
        const val jump_steps_answer = "class Solution {\n" + "    public int numWays(int n) {\n" + "        int a= 1,b=1,sum;\n" + "        for(int i = 0;i<n;i++){\n" + "            sum =(a+b)%1000000007;\n" + "            a = b;\n" + "            b = sum;\n" + "        }\n" + "        return a;\n" + "    }\n" + "}\n" + "\n" + "核心思想：此问题基本与斐波那契数列一至，只是斐波那契是从0开始，而青蛙跳台阶是从1开始，也就是求n级台阶的跳法，也就是n-1级的值。斐波那契：n = (n-1)+(n-2)\n" + "\n" + "第一步：创建方法numWays，传入N级台阶数，返回int类型，有几种跳法\n" + "public int numWays(int n) {\n" + "\n" + "第二步：初始化两级台阶的值，与辅助变量sum\n" + "int a= 1,b=1,sum;\n" + "\n" + "第三步：创建for循环，执行n次\n" + "for(int i = 0;i<n;i++){\n" + "\n" + "第四步：计算sum值，然后前进a=b，前进b=sum\n" + "sum =(a+b)%1000000007;\n" + "a = b;\n" + "b = sum;\n" + "\n" + "第五步：循环结束后，n的前一级的值，也就是a就是结果，返回\n" + "return a;\n" + "\n" + "\n" + "时间复杂度 O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。\n" + "空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。"
        const val delete_node = "删除链表的节点"
        const val delete_node_answer = "class Solution {\n" + "    public ListNode deleteNode(ListNode head, int val) {\n" + "        if(head.val == val) return head.next;\n" + "        ListNode pre = head,cur = pre.next;\n" + "        while(cur!=null&&cur.val!=val){\n" + "            pre = cur;\n" + "            cur = cur.next;\n" + "        }\n" + "        if(cur.val == val) pre.next = cur.next;\n" + "        return head;\n" + "    }\n" + "}\n" + "\n" + "核心思想：建两个指针，当前指针cur与后指针pre，启动一个while循环，条件就是当前指针不为null，并且当前指针val与目标val不等，然后当前指针前移，后继指针跟上。遇到相待的cur，把后节点指向前节点的下一位，返回haed就行了\n" + "\n" + "第一步：创建方法deleteNode，返回头部节点ListNode，参数一个是head，还有一个是目标值val。\n" + "public ListNode deleteNode(ListNode head, int val) {\n" + "\n" + "第二步：判断头部节点head与目标值val是否相待，相等直接返回head.next。\n" + "if(head.val == val)  return head.next;\n" + "\n" + "第三步：创建后节点pre等于head，前节点为pre.next。\n" + "ListNode pre = head, cur = pre.next;\n" + "\n" + "第四步：启动一个while循环，条件是前节点cur不为null，并且cur.val不等于目标val。然后后节点pre等于cur，前节点前移一步。\n" + "while(cur!=null&&cur.val!=val){\n" + "    pre = cur;\n" + "    cur = cur.next;\n" + "}\n" + "\n" + "第五步：如果前节点val等于目标val，那把后节点指向前节点的下一位\n" + "if(cur.val == val) pre.next = cur.next;\n" + "\n" + "第六步：返回头部\n" + "return head;\n" + "\n" + "\n" + "时间复杂度 O(N) ： N 为链表长度，删除操作平均需循环 N/2 次，最差 N 次。\n" + "空间复杂度 O(1) ： cur, pre 占用常数大小额外空间。"
        const val merge_num = "合并两个有序数组(Arrays.sort())"
        const val merge_num_answer = "class Solution {\n" + "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "        for (int i = 0; i < n; ++i) {\n" + "            nums1[m + i] = nums2[i];\n" + "        }\n" + "        Arrays.sort(nums1);\n" + "    }\n" + "}\n" + "\n" + "核心思想：将数组2内元素通过for循环添加到数组1中，再通过Arrays的sort方法，把num1进行排序\n" + "\n" + "第一步：创建方法merge，无返回参数，入参是两个数组和他们的长度\n" + "public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "\n" + "第二步：启动for循环，执行次数与数组2和长度相同\n" + "for (int i = 0; i < n; ++i) {\n" + "\n" + "第三步：循环内，在数组1后面逐个添加数组2的元素\n" + "nums1[m + i] = nums2[i];\n" + "\n" + "第四步：通过Arrays.sort()方法，把num1进行排序\n" + "Arrays.sort(nums1);\n" + "\n" + "\n" + "时间复杂度：O((m+n) log(m+n))。\n" + "排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n) log(m+n))。\n" + "\n" + "空间复杂度：O( log(m+n))。\n" + "排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O( log(m+n))。"
        const val merge_num_traverse = "合并两个有序数组（遍历）"
        const val merge_num_traverse_answer = "class Solution {\n" + "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "        int k = m + n - 1;\n" + "        while (n > 0 && m > 0) {\n" + "            if (nums1[m - 1] < nums2[n - 1]) {\n" + "                nums1[k] = nums2[n - 1];\n" + "                n--;\n" + "            } else {\n" + "                nums1[k] = nums1[m - 1];\n" + "                m--;\n" + "            }\n" + "            k--;\n" + "        }\n" + "        for (int i = 0; i < n; i++) {\n" + "            nums1[i] = nums2[i];\n" + "        }\n" + "    }\n" + "}\n" + "\n" + "核心思想：先得到双数组之和的辅助下标k，然后再把数组1与数组2的的最后一位元素一一比较，从大到小，从后到前，反向放入nums1中。当有一组放完后，再把剩余一组，通过for循环逐个放入。\n" + "\n" + "第一步：创建方法merge，无返回参数，入参是两个数组和他们的长度\n" + "public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "\n" + "第二步：算出两数组总长的辅助下标k，为放入数组1做准备\n" + "int k = m + n - 1;\n" + "\n" + "第三步：启动个while循环，条件是m与n都大于0，开始准备遍历数组1与数组2\n" + "while (n > 0 && m > 0) {\n" + "\n" + "第四步：如果数组1最后一位小于数组2的最后一位，那把数组2的最后一位放到数组1的k下标上，并执行n--，下次比较下一位。\n" + "if (nums1[m - 1] < nums2[n - 1]) {\n" + "     nums1[k] = nums2[n - 1];\n" + "     n--;\n" + "}\n" + "\n" + "第五步：反之，则把数组1的最后一位放到数组1的k下标上，并执行m--，下次比较下一位。\n" + "else {\n" + "   nums1[k] = nums1[m - 1];\n" + "   m--;\n" + "}\n" + "\n" + "第六步：肯定有一方还有值，直接启动个for循环，把数组2的值搬过来，如果数组2没值，就跳过了。\n" + "for (int i = 0; i < n; i++) {\n" + "   nums1[i] = nums2[i];\n" + "}\n" + "\n" + "\n" + "时间复杂度：O(M + N)\n" + "空间复杂度：O(1)"
        const val string_add = "字符串相加"
        const val string_add_answer = "class Solution {\n" + "    public String addStrings(String num1, String num2) {\n" + "        StringBuilder res = new StringBuilder(\"\");\n" + "        int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n" + "        while(i >= 0 || j >= 0){\n" + "            int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;\n" + "            int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n" + "            int tmp = n1 + n2 + carry;\n" + "            carry = tmp / 10;\n" + "            res.append(tmp % 10);\n" + "            i--; j--;\n" + "        }\n" + "        if(carry == 1) res.append(1);\n" + "        return res.reverse().toString();\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建个两个长度-1的光标，还有个临时进位变量carry。启动个while循环，通过字符串指令，从最后一位把值取出转换成int，两值还有上一次的carry相加，并算出本次进位carry，把值放进result里。最后把余下的carry拼入Stringbuffer，返回to.Stirng。\n" + "\n" + "第一步：创建方法addStrings，返回String类型两数之和，参数是两个String数字\n" + "public String addString(String num1, String num2){\n" + "\n" + "第二步：创建一个StringBuider，用作拼接参数并返回\n" + "StringBuilder res = new StringBuiLder(\"\");\n" + "\n" + "第三步：创建两个移动光标i与j，分别等于两数之长-1\n" + "int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n" + "\n" + "第四步：启动一个while循环，条件是i与j都>=0\n" + "while( i>=0&&j>=0){\n" + "\n" + "第五步：把num1与num2的最后一位，通过字符串方法num1.charAt(i) - ‘0’转成数字，如果其中一个数的下标为负了，就取0就可以\n" + "int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;\n" + "int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n" + "\n" + "第六步：创建一轮相加数之和，变量tem，值为n1+n2+carry\n" + "int tmp = n1 + n2 + carry;\n" + "\n" + "第七步：计算本轮carry,值为tmp/10，十进制除10\n" + "carry = tem /10;\n" + "\n" + "第八步：把本轮个位数拼接到StringBuilder中，结束一轮计算，光标i与j减一位。\n" + "res.append(tmp % 10);\n" + "\n" + "第九步：当两数都加完后，如果carry还有值，则需在builder中再拼接个1\n" + "if(carry == 1) res.append(1);\n" + "\n" + "第十步：把拼接结果反转后，转成String，返回结果\n" + "return res.reverse().toString();\n" + "\n" + "\n" + "时间复杂度：O(max(len1,len2))，其中len1=num1.length ，len2=num2.length。竖式加法的次数取决于较大数的位数。\n" + "空间复杂度：O(1)。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 StringBuffer，故 Java 解法的空间复杂度为 O(n)。"
        const val first_show_char = "第一个只出现一次的字符"
        const val first_show_char_answer = "class Solution {\n" + "    public char firstUniqChar(String s) {\n" + "        HashMap<Character, Boolean> dic = new HashMap<>();\n" + "        char[] sc = s.toCharArray();\n" + "        for(char c : sc)\n" + "            dic.put(c, !dic.containsKey(c));\n" + "        for(char c : sc)\n" + "            if(dic.get(c)) return c;\n" + "        return ' ';\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建一HashMap，把字符串转成charArray数组，再把其中的每个字节当成key，通过HashMap的containsKey方法，把是否包含K当val，如果不包含，就返回true。再通过if语句，把符合val值为true的字节返回。\n" + "\n" + "第一步：创建方法getUniqChar，返回char类型，参数字符串s\n" + "public char firstUniqChar(String s) {\n" + "\n" + "第二步：创建HashMap，要加泛型，不然下面没法直接判断val为boolean类型。把封装类Character和Boolean当做key和value。\n" + "HashMap<Character, Boolean> dic = new HashMap<>();\n" + "\n" + "第三步：把字符串转成char数组\n" + "char[] sc = s.toCharArray();\n" + "\n" + "第四步：写个for循环，然后把字节c当Key，是否不包含当成value存入hashmap。\n" + "for(char c : sc)\n" + "dic.put(c, !dic.containsKey(c));\n" + "\n" + "第五步：再写个for循环，把value值做为条件，把为true的返回\n" + "for(char c : sc)\n" + "if(dic.get(c)) return c;\n" + "\n" + "第六步：最后，如果没有单独的，就返回个空字节\n" + "return ' ';\n" + "\n" + "\n" + "时间复杂度 O(N)： N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；HashMap 查找操作的复杂度为 O(1) ；\n" + "空间复杂度 O(1) ： 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用O(26)=O(1) 的额外空间。\n"
        const val replace_space = " 替换空格"
        const val replace_space_answer = "class Solution {\n" + "    public String replaceSpace(String s) {\n" + "        StringBuilder dic = new StringBuilder(\"\");\n" + "        for(char c : s.toCharArray()){\n" + "            if(c == ' '){\n" + "                dic.append(\"%20\");\n" + "            } \n" + "            else{\n" + "                dic.append(c);\n" + "            }\n" + "        }\n" + "        return dic.toString();\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建个StringBuilder，然后把目标String转换成字节数组charArray，然后通过for循环，遍历每个字节，如果是空格，就把目标值放入StringBuilder中，否则就把字节放入builder。最后再返回Stringbuilder.toString();\n" + "\n" + "第一步：创建方法replaceSpace，返回结果String格式，参数为String s。\n" + "public String replaceSpace(String s){\n" + "\n" + "第二步：创建StringBuilder res，用来拼接字节，最后返回用\n" + "StringBuilder res = new StringBuilder(\"\");\n" + "\n" + "第三步：创建for循环，遍历字符串中的每一个字节\n" + "for(char c : s.toCharArray()){\n" + "\n" + "第四步：判断字节c是为空，如果为空，替换为目标值“%20”，拼入StringBuilder，否则把字节直接拼入StringBuilder。\n" + "if(c == ' '){\n" + "    dic.append(\"%20\");\n" + "} else{\n" + "        dic.append(c);\n" + "}\n" + "\n" + "第五步，把StringBuilder转成String返回\n" + "return dic.toString();\n" + "\n" + "时间复杂度 O(N)： 遍历使用 O(N)，每轮添加（修改）字符操作使用 O(1)；\n" + "空间复杂度 O(N)： Python 新建的 list 和 Java 新建的 StringBuilder 都使用了线性大小的额外空间。"
        const val two_sum = "两数之和求数组下标"
        const val two_sum_answer = "class Solution {\n" + "    public int[] twoSum(int[] nums, int target) {\n" + "        HashMap<Integer,Integer> map = new HashMap();\n" + "        for(int i = 0;i<nums.length;i++){\n" + "            if(map.containsKey(target - nums[i])){\n" + "                return new int[]{map.get(target-nums[i]),i};\n" + "            }\n" + "            map.put(nums[i],i);\n" + "        }\n" + "        return new int[0];\n" + "    }\n" + "}\n" + "\n" + "核心思路：通过for循环，把数组的值存入HashMap中的key，把下标当作val存入。然后再利用hashmap的contaionsKey方法，找出相应的下标，然后返回其下标。如果没有，返回new int[0]。\n" + "\n" + "第一步：创建方法twoSum，返回参数int[]数组，参数是数组加目标值taget。\n" + "public int[] twoSum(int[] nums, int target) {\n" + "\n" + "第二步：创建HashMap，泛型int+int，用来承接计算数组中的数。\n" + "HashMap<Integer,Integer> map = new HashMap();\n" + "\n" + "第三步：启动一个for循环，执行次数与数组长度一致\n" + "for(int i = 0;i<nums.length;i++){\n" + "\n" + "第四步：判断map中是否包含与num[i]相加为taget的key，如果有，返回该key的值与i下标。\n" + "if(map.containsKey(target - nums[i])){\n" + "    return new int[]{map.get(target-nums[i]),i};\n" + "}\n" + "\n" + "第五步：把数组的值存入HashMap中的key，把下标当作val存入map。\n" + "map.put(nums[i],i);\n" + "\n" + "第六步：如果不存在就返回空数组\n" + "return new int[0];\n" + "\n" + "\n" + "时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)地寻找 target - x。\n" + "空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。"
        const val reverse_print_recursive = "从尾到头打印链表（递归）"
        const val reverse_print_recursive_answer = "class Solution {\n" + "    ArrayList<Integer> tmp = new ArrayList<Integer>();\n" + "    public int[] reversePrint(ListNode head) {\n" + "        recur(head);\n" + "        int[] res = new int[tmp.size()];\n" + "        for(int i = 0; i < res.length; i++)\n" + "            res[i] = tmp.get(i);\n" + "        return res;\n" + "    }\n" + "    void recur(ListNode head) {\n" + "        if(head == null) return;\n" + "        recur(head.next);\n" + "        tmp.add(head.val);\n" + "    }\n" + "}\n" + "\n" + "核心思想：通过递归方法，把整个链表节点依次传入，顺带着再把val值也反向放入arraylist中。然后再通过for循环，把list中的值依次赋值给数组，最后返回数组结果。\n" + "\n" + "第一步：创建辅助列表tmp，泛型Integer\n" + "ArrayList<Integer> tmp = new ArrayList<Integer>();\n" + "\n" + "第二步：创建递归方法recur，无返回参数，入参为ListNode，判断head如果为空，return退出。然后递归调用recur方法，把head.next做为入参，下方为递归执行方法，反向把head.val添加到tmp列表中。\n" + "void recur(ListNode head) {\n" + "    if(head == null) return;\n" + "    recur(head.next);\n" + "    tmp.add(head.val);\n" + "}\n" + "\n" + "第三步：创建方法reversePrint，返回参数是int数组，入参节点listnode\n" + "public int[] reversePrint(ListNode head) {\n" + "\n" + "第四步：调用递归方法，传入节点ListNode，为tmp列表赋值\n" + "recur(head);\n" + "\n" + "第五步：创建新数组res，长度为tem.size()\n" + "int[] res = new int[tmp.size()];\n" + "\n" + "第六步：启动一个for循环，循环次数与数组长度相同，里面将list同下标的值赋给数组\n" + "for(int i = 0; i < res.length; i++)\n" + "     res[i] = tmp.get(i);\n" + "\n" + "第七步：返回数组res\n" + "return res;\n" + "\n" + "\n" + "时间复杂度 O(N)： 遍历链表，递归 N次。\n" + "空间复杂度 O(N)： 系统递归需要使用 O(N)的栈空间。"
        const val reverse_print_stack = "从尾到头打印链表（栈）"
        const val reverse_print_stack_answer = "class Solution {\n" + "    public int[] reversePrint(ListNode head) {\n" + "        Stack<ListNode> stack = new Stack();\n" + "        while(head!=null){\n" + "            stack.push(head);\n" + "            head= head.next;\n" + "        }\n" + "        int[] tmp = new int[stack.size()];\n" + "        for(int i = 0;i<tmp.length;i++){\n" + "            tmp[i] = stack.pop().val ;\n" + "        }\n" + "        return tmp;\n" + "    }\n" + "}\n" + "\n" + "核心思想，利用stack先进后出的特点，先通过while循环遍历链表，并把每个链表push入stack。然后创建一个与stack长度相同的数组，并通过for循环，把弹出栈node的值赋值给数组。\n" + "\n" + "第一步：创建方法reversePrint，返回int数组，入参ListNode head。\n" + "public int[] reversePrint(ListNode head) {\n" + "\n" + "第二步：创建辅助栈stack，泛型ListNode\n" + "Stack<ListNode> stack = new Stack();\n" + "\n" + "第三步：创建while循环，条件是head不等于null，即遍历ListNode，并把head入栈，head后移。\n" + "while(head!=null){\n" + "     stack.push(head);\n" + "     head= head.next;\n" + "}\n" + "\n" + "第四步：创建数组tmp，长度与stack相同\n" + "int[] tmp = new int[stack.size()];\n" + "\n" + "第五步：启动for循环，循环次数与数组长度相同，在循环中，将stack.pop出栈的值赋值给数组对应下标上。\n" + "for(int i = 0;i<tmp.length;i++){\n" + "    tmp[i] = stack.pop().val ;\n" + "}\n" + "\n" + "第六步：返回数组\n" + "return tmp;\n" + "\n" + "\n" + "时间复杂度：O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。\n" + "空间复杂度：O(n)。额外使用一个栈存储链表中的每个节点。"
        const val create_list = "创建链表"
        const val create_list_answer = "class MyLinkedList {\n" + "        int size;\n" + "        ListNode head;  \n" + "\n" + "        public MyLinkedList() {\n" + "            size = 0;\n" + "            head = new ListNode(0);\n" + "        }\n" + "\n" + "        public int get(int index) {\n" + "            if (index < 0 || index >= size) return -1;\n" + "            ListNode curr = head;\n" + "            for (int i = 0; i < index + 1; ++i) curr = curr.next;\n" + "            return curr.val;\n" + "        }\n" + "\n" + "        public void addAtHead(int val) {\n" + "            addAtIndex(0, val);\n" + "        }\n" + "\n" + "        public void addAtTail(int val) {\n" + "            addAtIndex(size, val);\n" + "        }\n" + "\n" + "        public void addAtIndex(int index, int val) {\n" + "            if (index > size) return;\n" + "            if (index < 0) index = 0;\n" + "\n" + "            ++size;\n" + "            ListNode pred = head;\n" + "            for (int i = 0; i < index; ++i) pred = pred.next;\n" + "\n" + "            ListNode toAdd = new ListNode(val);\n" + "            toAdd.next = pred.next;\n" + "            pred.next = toAdd;\n" + "        }\n" + "\n" + "        public void deleteAtIndex(int index) {\n" + "            if (index < 0 || index >= size) return;\n" + "\n" + "            size--;\n" + "            ListNode pred = head;\n" + "            for (int i = 0; i < index; ++i) pred = pred.next;\n" + "\n" + "            pred.next = pred.next.next;\n" + "        }\n" + "    }\n" + "\n" + "核心思想：实现构造函数、增add、删delete、查get，其中增加头部与增加尾部可以复用addAtIndex方法\n" + "\n" + "第一步：创建size与链表头，完成构造函数\n" + "int size;\n" + "ListNode head;  \n" + "\n" + "public MyLinkedList() {\n" + "    \tsize = 0;\n" + "    \thead = new ListNode(0);\n" + "}\n" + "\n" + "第二步：完成添加函数，addAtIndex，index大于size直接return，小于0，把index设置为0，然后添加链表长度++size，创建光标节点pre，并移动到目标位置，创建目标节点toAdd，调整前后指针完成添加。\n" + " public void addAtIndex(int index, int val) {\n" + "        if (index > size) return;\n" + "        if (index < 0) index = 0;\n" + "\n" + "        ++size;\n" + "        ListNode pred = head;\n" + "        for (int i = 0; i < index; ++i) pred = pred.next;\n" + "\n" + "        ListNode toAdd = new ListNode(val);\n" + "        toAdd.next = pred.next;\n" + "        pred.next = toAdd;\n" + "}\n" + "\n" + "第三步：完成删除函数，deleteAtIndex，当index大于size或小于0直接return，然后链表长度-1，创建光标节点pre，并移动光标节点至目标位，重新指向指针删除目标节点。\n" + " public void deleteAtIndex(int index) {\n" + "       if (index < 0 || index >= size) return;\n" + "\n" + "       size--;\n" + "       ListNode pred = head;\n" + "       for (int i = 0; i < index; ++i) pred = pred.next;\n" + "\n" + "       pred.next = pred.next.next;\n" + "}\n" + "\n" + "第四步：完成添加到头部与添加到尾部的方法，直接复用addAtIndex方法\n" + "public void addAtHead(int val) {\n" + "      addAtIndex(0, val);\n" + "}\n" + "\n" + "public void addAtTail(int val) {\n" + "      addAtIndex(size, val);\n" + "}\n" + "\n" + "时间复杂度：addAtHead  O(1)         addAtInder、get、deleteAtIndex  O(k)  k是元素索引值       addAtTail  O(n) n是元素个数\n" + "空间复杂度：所有操作都是O(1)"
        const val remove_n_from_end = "删除链表的倒数第N个结点"
        const val remove_n_from_end_answer = "class Solution {\n" + "    public ListNode removeNthFromEnd(ListNode head, int n) {\n" + "        ListNode dum = new ListNode(0);\n" + "        dum.next = head;\n" + "        ListNode former = dum,latter = dum;\n" + "\n" + "        for(int i = 0;i<n;i++){\n" + "            former = former.next;\n" + "        }\n" + "        while(former.next!= null){\n" + "            former = former.next;\n" + "            latter = latter.next;\n" + "        }\n" + "        latter.next = latter.next.next;\n" + "        return dum.next;\n" + "    }\n" + "}\n" + "\n" + "核心思想：因为是需要返回头部，所以创建一个伪头部dum，创建一前一后两节点，前节点先移动目标n步，然后通过while循环一起前进，当前节点到最后一位时，后节点直接跳过赋值，删除目标节点，返回伪头部后一个节点就可以了。\n" + "\n" + "第一步：创建方法removeNthFromEnd，返回头部ListNode，参数为节点head，目标值n\n" + "public ListNode removeNthFromEnd(ListNode head, int n) {\n" + "\n" + "第二步：创建伪头部，前后节点former、latter。\n" + "ListNode dum = new ListNode(0);\n" + "dum.next = head;\n" + "ListNode former = dum,latter = dum;\n" + "\n" + "第三步：通过for循环，使former节点前进n步。\n" + "for(int i = 0;i<n;i++){\n" + "    former = former.next;\n" + "}\n" + "\n" + "第四步：启动while循环，使前后节点共同前进\n" + "while(former.next!= null){\n" + "     former = former.next;\n" + "     latter = latter.next;\n" + "}\n" + "\n" + "第五步：到达目标点位前，latter节点跳过删除目标节点，并返回伪头部。\n" + "latter.next = latter.next.next;\n" + "return dum.next;\n" + "\n" + "\n" + "时间复杂度：O(L)，其中 L 是链表的长度。\u2028空间复杂度：O(1)。"
        const val remove_elements = "移除链表元素"
        const val remove_elements_answer = "class Solution {\n" + "    public ListNode removeElements(ListNode head, int val) {\n" + "        ListNode dum = new ListNode(0);\n" + "        dum.next = head;\n" + "        ListNode cur = dum;\n" + "        while(cur.next!=null){\n" + "            if(cur.next.val ==val){\n" + "                cur.next = cur.next.next;\n" + "            }else{\n" + "                cur = cur.next;\n" + "            }\n" + "        }\n" + "        return dum.next;\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建伪头部及光标节点，通过wile循环移动光标节点，去掉目标节点后，返回伪头部。\n" + "\n" + "第一步：创建方法removeElements，返回节点ListNode，入参head节点与目标val。\n" + "public ListNode removeElements(ListNode head, int val) {\n" + "\n" + "第二步：创建伪头部与光标节点\n" + "ListNode dum = new ListNode(0);\n" + "dum.next = head;\n" + "ListNode cur = dum;\n" + "\n" + "第三步：通过while循环，移除相同值的节点，不同的移位\n" + "while(cur.next!=null){\n" + "   if(cur.next.val ==val){\n" + "        cur.next = cur.next.next;\n" + "      }else{\n" + "        cur = cur.next;\n" + "   }\n" + "}\n" + "\n" + "第四步：返回伪头部后一位，链表头\n" + "return dum.next;\n" + "\n" + "时间复杂度：O(n)，其中 n是链表的长度。需要遍历链表一次。\u2028空间复杂度：O(1)。"
    }
}

