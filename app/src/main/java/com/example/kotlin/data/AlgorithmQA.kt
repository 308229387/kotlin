package com.example.kotlin.data

/**
 * Author: sym
 * Date: 2021/7/13 8:11 PM
 * Describe:
 */
 class AlgorithmQA{

    companion object {
        const val reverse_list = "算法反转链表"
        const val reverse_list_answer = "class Solution {\n" + "    public ListNode reverseList(ListNode head) {\n" + "        if(head == null||head.next == null){\n" + "            return head;\n" + "        }\n" + "        ListNode cur = reverseList(head.next);\n" + "        head.next.next = head;\n" + "        head.next = null;\n" + "        return cur;\n" + "    }\n" + "}\n" + "\n" + "链表反转是用递归来实现，共有六步\n" + "第1步写方法reverseList，传入节点head，返回节点ListNode\n" + " public ListNode reverseList(ListNode head)\n" + "\n" + "第2步：先做一层判断，触发终止时结束递归，并返回最后的节点head\n" + " if(head == null||head.next == null){\n" + "            return head;\n" + "  }\n" + "\n" + "第3步：然后创建一个要返回的节点，递归调用reverseList，传入下一个head.next，这里假设传1-2-3-4-5，那这一步会递归的执行5回\n" + " ListNode cur = reverseList(head.next);\n" + "\n" + "/** 从这步向下的三行代码，递归传入的会一轮一轮反执行回来 */\n" + "\n" + "第4步：比如4的next 是5，那4的next的next等于4，意思是让5指向4\n" + "head.next.next = head;\n" + "\n" + "第5步：现在head已经是4了，5已经指向4了，要把4指向5的置null\n" + "head.next = null;\n" + "\n" + "第6步：返回节点cur\n" + "return cur;\n" + "\n" + "\n" + "时间复杂度：O(n)其中 n是链表的长度。需要遍历链表一次。\n" + "空间复杂度：O(1)反转指针而已"
        const val has_cycle = "链表是否有环"
        const val has_cycle_answer = "class Solution {\n" + "    public boolean hasCycle(ListNode head) {\n" + "        ListNode slow = head,fast = slow;\n" + "        while(true){\n" + "            if(fast == null||fast.next == null){\n" + "                return false;\n" + "            }\n" + "            slow = slow.next;\n" + "            fast = fast.next.next;\n" + "            if(slow == fast) return true;\n" + "        }\n" + "    }\n" + "}\n" + "\n" + "判断链表是否有环，核心思想是创建一快一慢两个指针，慢的走1步，快的走2步，然后在while循环中两个一起向前走，如果两节点相待了，那就说明有环，否则就没有。共有六步\n" + "\n" + "第一步：创建方法hasCycle，参数为节点head，返回值为boolean\n" + "public boolean hasCycle(ListNode head)\n" + "\n" + "第二步：创建一慢一快两指针，slow等于节点，fast等于slow\n" + "ListNode slow = head,fast = slow;\n" + "\n" + "第三步：写一个while循环，条件是true，一直跑\n" + "while(true){\n" + "\n" + "第四步：如果fast全等于null，或fast.next全等于null，说明到头了，还没有相等相遇，没有环返回false\n" + "if(fast == null||fast.next == null){\n" + "    return false;\n" + "}\n" + "\n" + "第五步：slow节点前移一步，fast节点前移两步\n" + "slow = slow.next;\n" + "fast = fast.next.next;\n" + "\n" + "第六步：判断，如果slow全等于fast，说明相遇了有环，返回true\n" + "\n" + "时间复杂度：O(N)，其中 N 是链表中的节点数\n" + "空间复杂度：O(1)，我们只使用了两个指针的额外空间。\n"
        const val merge_two_lists = "合并两个有序链表"
        const val merge_two_lists_answer = "class Solution {\n" + "    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n" + "        ListNode dum  = new ListNode(0),cur = dum;\n" + "        while(l1 !=null&&l2 !=null){\n" + "            if(l1.val<l2.val){\n" + "                cur.next = l1;\n" + "                l1 = l1.next;\n" + "            }else{\n" + "                cur.next = l2;\n" + "                l2 = l2.next;\n" + "            }\n" + "            cur = cur.next;\n" + "        }\n" + "        cur.next = l1!=null?l1:l2;\n" + "        return dum.next;\n" + "    }\n" + "}\n" + "\n" + "链表l1,l2是递增的，因此核心思想是使用双指针l1和l2通过while循环遍历两链表，根据l1.val和l2.val的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。\n" + "\n" + "第一步：创建方法mergeTwoLists，返回节点ListNode，参数是l1、l2两个节点\n" + "public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n" + "\n" + "第二步：创建伪头部dum，还需要再创建一个cur，做为移动指针\n" + "ListNode dum  = new ListNode(0),cur = dum;\n" + "\n" + "第三步：创建while循环，条件是l1不等于null并且l2也不等于null\n" + "while(l1 !=null&&l2 !=null){\n" + "\n" + "第四步：比较l1的val值与l2的val值大小，如果l1的val小，把l1添加到cur后面，l1向后移一位\n" + "if(l1.val<l2.val){\n" + "    cur.next = l1;\n" + "    l1 = l1.next;\n" + "}\n" + "\n" + "第五步：如果l2的val小，把l2添加到cur后面，l2向后移一位\n" + "else{\n" + "    cur.next = l2;\n" + "    l2 = l2.next;\n" + "}\n" + "\n" + "第六步：指针cur向后移一位\n" + "cur = cur.next;\n" + "\n" + "第七步：有一方为null结束后，看还剩下谁，把不为null的放在cur后面\n" + "cur.next = l1!=null?l1:l2;\n" + "\n" + "第八步：返回伪头部后面的链表\n" + "return dum.next;\n" + "\n" + "\n" + "时间复杂度 O(M+N)O(M+N) ： M、N分别为链表 l1 、 l2 的长度，合并操作需遍历两链表\n" + "空间复杂度 O(1) ： 节点引用 dum , cur 使用常数大小的额外空间。\n" + "\n"
        const val k_th_from_end = "链表倒数第K个节点"
        const val k_th_from_end_answer = "class Solution {\n" + "    public ListNode getKthFromEnd(ListNode head, int k) {\n" + "        ListNode former = head, latter = head;\n" + "        for(int i = 0; i < k; i++)}\n" + "            former = former.next;\n" + "\t}\n" + "        while(former != null) {\n" + "            former = former.next;\n" + "            latter = latter.next;\n" + "        }\n" + "        return latter;\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建一前一后双指针，快的先前进K步，然后启动一个while循环，同步前进，当快的到头后，慢的就是倒数第K个节点。\n" + "\n" + "第一步：创建方法名为getKthFromEnd，返回参数为ListNode节点，参数有两个，一个是head节点，一个是相隔距离K\n" + "public ListNode getKthFromEnd(ListNode head, int k) {\n" + "\n" + "第二步：创建一前一后两个节点，都等于head\n" + "ListNode former = head, latter = head;\n" + "\n" + "第三步：创建个for循环，把前面的节点向前先移动K部\n" + "for(int i = 0; i < k; i++){\n" + "     former = former.next;\n" + "}\n" + "\n" + "第四步：创建一个while循环，条件是former不为null，然后former和latter同步前移\n" + " while(former != null) {\n" + "     former = former.next;\n" + "     latter = latter.next;\n" + " }\n" + "\n" + "第五步：返回慢的节点，也就是倒数第K个节点\n" + "return latter;\n" + "\n" + "\n" + "时间复杂度 O(N) ： N 为链表长度；总体看， former 走了 N 步， latter 走了 (N-k)步。\n" + "空间复杂度 O(1) ： 双指针 former , latter 使用常数大小的额外空间。"
        const val jump_steps = "青蛙跳台阶"
        const val jump_steps_answer = "class Solution {\n" + "    public int numWays(int n) {\n" + "        int a= 1,b=1,sum;\n" + "        for(int i = 0;i<n;i++){\n" + "            sum =(a+b)%1000000007;\n" + "            a = b;\n" + "            b = sum;\n" + "        }\n" + "        return a;\n" + "    }\n" + "}\n" + "\n" + "核心思想：此问题基本与斐波那契数列一至，只是斐波那契是从0开始，而青蛙跳台阶是从1开始，也就是求n级台阶的跳法，也就是n-1级的值。斐波那契：n = (n-1)+(n-2)\n" + "\n" + "第一步：创建方法numWays，传入N级台阶数，返回int类型，有几种跳法\n" + "public int numWays(int n) {\n" + "\n" + "第二步：初始化两级台阶的值，与辅助变量sum\n" + "int a= 1,b=1,sum;\n" + "\n" + "第三步：创建for循环，执行n次\n" + "for(int i = 0;i<n;i++){\n" + "\n" + "第四步：计算sum值，然后前进a=b，前进b=sum\n" + "sum =(a+b)%1000000007;\n" + "a = b;\n" + "b = sum;\n" + "\n" + "第五步：循环结束后，n的前一级的值，也就是a就是结果，返回\n" + "return a;\n" + "\n" + "\n" + "时间复杂度 O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。\n" + "空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。"
        const val delete_node = "删除链表的节点"
        const val delete_node_answer = "class Solution {\n" + "    public ListNode deleteNode(ListNode head, int val) {\n" + "        if(head.val == val) return head.next;\n" + "        ListNode pre = head,cur = pre.next;\n" + "        while(cur!=null&&cur.val!=val){\n" + "            pre = cur;\n" + "            cur = cur.next;\n" + "        }\n" + "        if(cur.val == val) pre.next = cur.next;\n" + "        return head;\n" + "    }\n" + "}\n" + "\n" + "核心思想：建两个指针，当前指针cur与后指针pre，启动一个while循环，条件就是当前指针不为null，并且当前指针val与目标val不等，然后当前指针前移，后继指针跟上。遇到相待的cur，把后节点指向前节点的下一位，返回haed就行了\n" + "\n" + "第一步：创建方法deleteNode，返回头部节点ListNode，参数一个是head，还有一个是目标值val。\n" + "public ListNode deleteNode(ListNode head, int val) {\n" + "\n" + "第二步：判断头部节点head与目标值val是否相待，相等直接返回head.next。\n" + "if(head.val == val)  return head.next;\n" + "\n" + "第三步：创建后节点pre等于head，前节点为pre.next。\n" + "ListNode pre = head, cur = pre.next;\n" + "\n" + "第四步：启动一个while循环，条件是前节点cur不为null，并且cur.val不等于目标val。然后后节点pre等于cur，前节点前移一步。\n" + "while(cur!=null&&cur.val!=val){\n" + "    pre = cur;\n" + "    cur = cur.next;\n" + "}\n" + "\n" + "第五步：如果前节点val等于目标val，那把后节点指向前节点的下一位\n" + "if(cur.val == val) pre.next = cur.next;\n" + "\n" + "第六步：返回头部\n" + "return head;\n" + "\n" + "\n" + "时间复杂度 O(N) ： N 为链表长度，删除操作平均需循环 N/2 次，最差 N 次。\n" + "空间复杂度 O(1) ： cur, pre 占用常数大小额外空间。"
        const val merge_num = "合并两个有序数组(Arrays.sort())"
        const val merge_num_answer = "class Solution {\n" + "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "        for (int i = 0; i < n; ++i) {\n" + "            nums1[m + i] = nums2[i];\n" + "        }\n" + "        Arrays.sort(nums1);\n" + "    }\n" + "}\n" + "\n" + "核心思想：将数组2内元素通过for循环添加到数组1中，再通过Arrays的sort方法，把num1进行排序\n" + "\n" + "第一步：创建方法merge，无返回参数，入参是两个数组和他们的长度\n" + "public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "\n" + "第二步：启动for循环，执行次数与数组2和长度相同\n" + "for (int i = 0; i < n; ++i) {\n" + "\n" + "第三步：循环内，在数组1后面逐个添加数组2的元素\n" + "nums1[m + i] = nums2[i];\n" + "\n" + "第四步：通过Arrays.sort()方法，把num1进行排序\n" + "Arrays.sort(nums1);\n" + "\n" + "\n" + "时间复杂度：O((m+n) log(m+n))。\n" + "排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n) log(m+n))。\n" + "\n" + "空间复杂度：O( log(m+n))。\n" + "排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O( log(m+n))。"
        const val merge_num_traverse = "合并两个有序数组（遍历）"
        const val merge_num_traverse_answer = "class Solution {\n" + "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "        int k = m + n - 1;\n" + "        while (n > 0 && m > 0) {\n" + "            if (nums1[m - 1] < nums2[n - 1]) {\n" + "                nums1[k] = nums2[n - 1];\n" + "                n--;\n" + "            } else {\n" + "                nums1[k] = nums1[m - 1];\n" + "                m--;\n" + "            }\n" + "            k--;\n" + "        }\n" + "        for (int i = 0; i < n; i++) {\n" + "            nums1[i] = nums2[i];\n" + "        }\n" + "    }\n" + "}\n" + "\n" + "核心思想：先得到双数组之和的辅助下标k，然后再把数组1与数组2的的最后一位元素一一比较，从大到小，从后到前，反向放入nums1中。当有一组放完后，再把剩余一组，通过for循环逐个放入。\n" + "\n" + "第一步：创建方法merge，无返回参数，入参是两个数组和他们的长度\n" + "public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "\n" + "第二步：算出两数组总长的辅助下标k，为放入数组1做准备\n" + "int k = m + n - 1;\n" + "\n" + "第三步：启动个while循环，条件是m与n都大于0，开始准备遍历数组1与数组2\n" + "while (n > 0 && m > 0) {\n" + "\n" + "第四步：如果数组1最后一位小于数组2的最后一位，那把数组2的最后一位放到数组1的k下标上，并执行n--，下次比较下一位。\n" + "if (nums1[m - 1] < nums2[n - 1]) {\n" + "     nums1[k] = nums2[n - 1];\n" + "     n--;\n" + "}\n" + "\n" + "第五步：反之，则把数组1的最后一位放到数组1的k下标上，并执行m--，下次比较下一位。\n" + "else {\n" + "   nums1[k] = nums1[m - 1];\n" + "   m--;\n" + "}\n" + "\n" + "第六步：肯定有一方还有值，直接启动个for循环，把数组2的值搬过来，如果数组2没值，就跳过了。\n" + "for (int i = 0; i < n; i++) {\n" + "   nums1[i] = nums2[i];\n" + "}\n" + "\n" + "\n" + "时间复杂度：O(M + N)\n" + "空间复杂度：O(1)"
        const val string_add = "字符串相加"
        const val string_add_answer = "class Solution {\n" + "    public String addStrings(String num1, String num2) {\n" + "        StringBuilder res = new StringBuilder(\"\");\n" + "        int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n" + "        while(i >= 0 || j >= 0){\n" + "            int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;\n" + "            int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n" + "            int tmp = n1 + n2 + carry;\n" + "            carry = tmp / 10;\n" + "            res.append(tmp % 10);\n" + "            i--; j--;\n" + "        }\n" + "        if(carry == 1) res.append(1);\n" + "        return res.reverse().toString();\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建个两个长度-1的光标，还有个临时进位变量carry。启动个while循环，通过字符串指令，从最后一位把值取出转换成int，两值还有上一次的carry相加，并算出本次进位carry，把值放进result里。最后把余下的carry拼入Stringbuffer，返回to.Stirng。\n" + "\n" + "第一步：创建方法addStrings，返回String类型两数之和，参数是两个String数字\n" + "public String addString(String num1, String num2){\n" + "\n" + "第二步：创建一个StringBuider，用作拼接参数并返回\n" + "StringBuilder res = new StringBuiLder(\"\");\n" + "\n" + "第三步：创建两个移动光标i与j，分别等于两数之长-1\n" + "int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n" + "\n" + "第四步：启动一个while循环，条件是i与j都>=0\n" + "while( i>=0&&j>=0){\n" + "\n" + "第五步：把num1与num2的最后一位，通过字符串方法num1.charAt(i) - ‘0’转成数字，如果其中一个数的下标为负了，就取0就可以\n" + "int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;\n" + "int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n" + "\n" + "第六步：创建一轮相加数之和，变量tem，值为n1+n2+carry\n" + "int tmp = n1 + n2 + carry;\n" + "\n" + "第七步：计算本轮carry,值为tmp/10，十进制除10\n" + "carry = tem /10;\n" + "\n" + "第八步：把本轮个位数拼接到StringBuilder中，结束一轮计算，光标i与j减一位。\n" + "res.append(tmp % 10);\n" + "\n" + "第九步：当两数都加完后，如果carry还有值，则需在builder中再拼接个1\n" + "if(carry == 1) res.append(1);\n" + "\n" + "第十步：把拼接结果反转后，转成String，返回结果\n" + "return res.reverse().toString();\n" + "\n" + "\n" + "时间复杂度：O(max(len1,len2))，其中len1=num1.length ，len2=num2.length。竖式加法的次数取决于较大数的位数。\n" + "空间复杂度：O(1)。除答案外我们只需要常数空间存放若干变量。在 Java 解法中使用到了 StringBuffer，故 Java 解法的空间复杂度为 O(n)。"
    }
}

