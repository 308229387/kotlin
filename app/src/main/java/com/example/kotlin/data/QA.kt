package com.example.kotlin.data

/**
 * Author: sym
 * Date: 2021/7/13 8:11 PM
 * Describe:
 */
 class QA{

    companion object {
        const val cache_optimization = "内存优化"
        const val cache_optimization_answer = "1、可以在Androidmanifest文件中application节点加入android:largeHeap=“true”来增加其dalvik虚拟机中堆的大小\n" + "\n" + "2、解决内存泄漏的问题，像静态引用啊、单例啊什么的\n" + "\n" + "3、对图片进行管理 ，把大图都做一遍压缩过滤，能换webp(androidstudio自带covert to webp)都换，在不失真的情况下尽量压缩，尽量用.9。\n" + "\n" + "4、 修改对象引用类型，增强GC收回的效率\n" + "\n" + "5、其他还有些细节，比如增加复用，减少不必要的全局变量，少用枚举啊等等"
        const val cache_big = "扩大内存"
        const val cache_big_answer ="Android为每个进程分配内存时，采用弹性的分配方式，即刚开始并不会给应用分配很多的内存，而是给每一个进程分配一个“够用”的内存大小。\n" + "\n" + "ActivityManager的getLargeMemoryClass()可以获得开启largeHeap最大的内存大小\n" + "通过ActivityManager的MemoryInfo，可以获取到应用最大使用内存大小getLargeMemoryClass()\n" + "\n" + "\n" + "1、创建一个新的进程，那么我们就可以把一些对象分配到新进程的heap上了，从而达到一个应用程序使用更多的内存的目的，建议把一些高消耗但不常用的模块放到独立的进程，不使用的进程可及时手动关闭；void killBackgroundProcesses(String packageName)\n" + "\n" + "2、可以在Androidmanifest文件中application节点加入android:largeHeap=“true”来增加其dalvik虚拟机中堆的大小。开子进程，分担内存"
        const val performance_optimization = "性能优化"
        const val performance_optimization_answer = "性能优化：Android的性能优化，主要是从以下几个方面进行优化的：\n" + " \n" + "一是稳定性，是否有内存溢出、崩溃的情况\n" + "\n" + "二是流畅性，有没有卡顿，冷启动时间长不长\n" + "\n" + "三是耗损是否严重，耗电、流量多不多啊\n" + "\n" + "四是安装包体积等，有没有冗余可优化空间 \n\n\n内存优化\n1.使用leakcanery先解决程序中内存占用较大的业务模块中的内存泄漏\n" + "2.移除程序中多余的代码和引用，这里使用默认的lint检测再配合shrinkResources来删除无效资源\n" + "3.优化图片，保证图片放置在合理的文件夹，根据View大小加载合适的图片大小，根据手机状态配置bitmap和回收策略\n" + "4.优化对象创建，比如string，使用对象池等\n\nAndroid官方对象池的简单实现：SimplePool，也是用得最多的实现\n" + "原理：使用了“懒加载”的思想。当SimplePool初始化时，不会生成N个T类型的对象存放在对象池中。而是当每次外部调用release()时，才把释放的T类型对象存放在对象池中。要先放入，才能取出来。   这样就避免了内存抖动。\n\nMemory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。\n" + "瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。\n"
        const val tcp_shake_hands = "Tcp握手过程"
        const val tcp_shake_hands_answer = "TCP三次握手：\n" + "\n" + "1：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；\n" + "\n" + "2：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n" + "\n" + "3：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n" + "\n" + "四次挥手：\n" + "1、主动关闭方会发一个长度为0的数据包以及FIN关闭标识。\n" + "\n" + "2、被动方收到FIN后，会发一个ACK确认包，确认序号+1。\n" + "\n" + "3、确认无需要发送数据后，被动关闭方也会发一个FIN包，告诉主动关闭方，我也不会再发数据了。\n" + "\n" + "4主动关闭方发ACK确认，确认序号+1。\n\n" + "两次不行，为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。\n" + "\n" + "确认号要加1，因为报文不一定会按发送的时序到达目标，为了区分所以要加1\n" + "\n" + "出现大量的close_wait是因为被动关闭方没有发送FIN包确认关闭，是程序的问题。\n" + "如果是server主动关闭链接,那么Client则有可能进入CLOSE_WAIT,如果Client不发送FIN包，该关不关,那么client就一直会处在CLOSE_WAIT状态\n" + "\n" + "为什么是4次握手，因为被动方收到FIN后，需要先确认，防止主动方因等待时间过长再发FIN，被动方处理完数据后再发FIN"
        const val draw_view = "自定义View的流程"
        const val draw_view_answer = "介绍下实现一个自定义View的基本流程\n" + "①.自定义View的属性 编写attr.xml文件 ②.在layout布局文件中引用，同时引用命名空间 ③.在View的构造方法中获得我们自定义的属性 ，在自定义控件中进行读取（构造方法拿到attr.xml文件值） ④.重写onMesure 、onDraw    如果有需要还可以重写onTouchEvent"
        const val lock_type_use = "锁的分类及用法"
        const val lock_type_use_answer = "Synchronized的用法 ：\n" + "锁主要有三种\n" + "\n" + "类锁:像synchronized(class)或是锁静态方法，这种都是类锁，作用范围比较大，类的所有对象都会被作用到。\n" + "\n" + "第二种是对象锁，像普通方法锁就是，他的作用范围就是一个对象，不同线程不能同时执行一个对象的不同synchronized方法。\n" + "\n" + "还是就是同步代码块，synchronized（obj），这个的作用范围就是被作用的代码块上。"
        const val synchronized_lock_diff = "synchronized和Lock的区别、适用场景"
        const val synchronized_lock_diff_answer = "区别：\n" + "1、定义和使用：synchronized是java的关键字，可以作用于类、函数、对象，但lock是接口，需要线程去持有使用实现lock的对象来使用。\n" + "\n" + "2、操作性：synchronized加锁和解锁都是自动进行的，易于操作，但lock（或实现接口的reentrantlock）都需要手动上锁解锁，最好还要配合try-finaly来使用，防止死锁\n" + "\n" + "3、灵活性：最重要的，synchronized的是不可终断锁，等待锁过程是固定的，等不到就会一直等，但lock可以trylock尝试上锁，而且能够拿到锁定与否的状态(boolean=lock.trylock())，会有更多的选择，可以提高多个线程进行读操作的效率。\n" + "\n" + "4、性能：如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized\n" + "\n" + "\n" + "适用场景：少量线程同步适合用synchronized，大量线程适合用lock"
        const val mor_lock = "锁的类型"
        const val mor_lock_answer = "1、公平锁：先来先得，按顺利获得锁。非公平锁：有可能后申请的线程比先申请的线程优先获取锁，随机性\n" + "\n" + "2、乐观锁/悲观锁：乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度，悲观锁：悲观的认为，不加锁的并发操作一定会出问题。乐观锁：乐观的认为，不加锁的并发操作是没有事情的\n" + "\n" + "3、独享锁：是指该锁只能同时被一个线程持有ReentrantLock。共享锁：是只该所可以同时被多个线程持有ReadWriteLock。\n" + "\n" + "4、可重入锁：也叫递归锁。同一个线程在进入内层方法会自动获取锁，可重入锁的一个好处是可一定程度避免死锁"
        const val twice_lock = "可重入锁"
        const val twice_lock_answer = "在JAVA环境下ReentrantLock和synchronized都是可重入锁。\n" + "\n" + "synchronized是一个可重入锁。在一个类中，如果synchronized方法1调用了synchronized方法2，方法2是可以正常执行的，这说明synchronized是可重入锁。否则，在执行方法2想获取锁的时候，该锁已经在执行方法1时获取了，那么方法2将永远得不到执行。\n" + "\n" + "可重入锁主要用在线程需要多次进入临界区代码时，需要使用可重入锁。具体的例子，比如上文中提到的一个synchronized方法需要调用另一个synchronized方法时。"
        const val four_components = "四大组件"
        const val four_components_answer = "Activity【活动】：用于表现功能。 \n" + "Service【服务】：后台运行服务，不提供界面呈现。 \n" + "BroadcastReceiver【广播接收器】：用来接收广播。 \n" + "Content Provider【内容提供商】：支持在多个应用中存储和读取数据，相当于数据库。\n"
        const val activity_life = "Activity生命周期及跳转"
        const val activity_life_answer = "onCreate:create表示创建\n" + "onStart:start表示启动\n" + "onResume:resume表示继续、重新开始\n" + "onPause:pause表示暂停\n" + "onStop：stop表示停止\n" + "onDestroy：destroy表示销毁\n" + "onRestart：restart表示重新开始\n" + "\n" + "当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume，最后才执行A的onStop!!!\n" + "\n" + "当B按下返回键，B先执行onPause，然后是A再执行onRestart -> onStart -> onResume，最后才是B执行onStop  -> onDestroy\n" + "\n" + "如果B是dialog或透明的，A只会执行onPause，不会执行onStop。当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume。（注意：A的 onStop 不会执行）\n" + "\n" + "当B按下返回键，B先执行onPause，然后是A只会执行 onResume，最后 B 执行onStop  -> onDestroy。\n\n Activity弹出 Dialog 对生命周期\n" + "生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响"
        const val android_configChanges = "activity横纵向切换，或页面发生改变时"
        const val android_configChanges_answer = "程序在运行时，一些设备的配置可能会发生改变，如：横竖屏切换、键盘的可用性等这样的事情发生的时候，activity在没有配置android:configChanges属性时会重新启动\n" + "生命周期：onSaveInstanceState-->onPause-->onStop-->onDestroy-->onCreate-->onStart-->onRestoreInstanceState-->onResume\n" + "\n" + "但如果给configChanges配置了orientation|keyboardHidden|screenSize这些属性后，再发生屏幕改变会调用onConfigurationChanged方法，我们可以通过Configuration里的orientation属性判断是横向还是纵向。\n" +"\n"+"onNewIntent 什么时候调用\n"+"如果此次启动不创建该Activity的新实例,则系统会调用原有实例的onNewIntent()方法来处理此intent"
        const val fragment_life = "fragment生命周期"
        const val fragment_life_answer = "onAttach() 在Fragment 和 Activity 建立关联是调用（Activity 传递到此方法内）\n" + "\n" + "onCreate()\n" + "\n" + "onCreateView() 当Fragment 创建视图时调用\n" + "\n" + "onActivityCreated() 在相关联的 Activity 的 onCreate() 方法已返回时调用。\n" + "\n" + "onStart() ：Fragment对用户可见的时候调用，前提是Activity已经started。\n" + "\n" + "onResume()：Fragment和用户之前可交互时会调用，前提是Activity已经resumed。\n" + "\n" + "onPause()：Fragment和用户之前不可交互时会调用。\n" + "\n" + "onStop()：Fragment不可见时会调用。\n" + "\n" + "onDestroyView() 当Fragment中的视图被移除时调用\n" + "\n" + "onDestroy()\n" + "\n" + "onDetach() 当Fragment 和 Activity 取消关联时调用。"
        const val fragment_life_change = "fragment切换时生命周期的变化"
        const val fragment_life_change_answer = "1、用replace替换后Fragment都是销毁重新创建的,生命周期全走。加了回退栈的，只是销毁视图onDestroyView() -> 重新创建视图onCreateView()。这种方法会消耗流量和性能\n" + "\n" + "2、add hide show------onHiddenChange()，使用hide() show()方法切换fragment 不会走任何的生命周期 无法通过生命周期进行刷新，需要监听onHiddenChanged方法，来判断fragment显示与否。add 与 remove，会走正常创建与销毁周期。"
        const val service_create = "service两种启动方式"
        const val service_create_answer = "两种启动方式：\n" + "\n" + "通过StartService启动Service：startService(new Intent(this, NormalService.class));\n" + "\n" + "通过bingService启动Service:bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);"
        const val service_two_create_diff = "两种启动的区别"
        const val service_two_create_diff_answer = "主要是生命周期不同\n" + "\n" + "startService一旦服务开启跟开启者就没有任何关系\n" + "\n" + "而bindService可以通过unBindService来停掉Service。而且调用者挂了，服务也会跟着挂掉。"
        const val service_life = "Service生命周期"
        const val service_life_answer = "startService方式\n" + "onCreate()：创建  \n" + "onStartCommand()：运行\n" + "onDestroy() ：停止\n" + "\n" + "bindService方式\n" + "onCreate()：创建\n" + "onBind()：运行\n" + "onUnbind()：取消绑定 \n" + "onDestroy() ：停止"
        const val service_stop = "如何停止service"
        const val service_stop_answer = "终止的话使用stopSelf()或stopService(intent)\n" + "\n" + "混合启动如何停止：同时使用 startService 与 bindService Service 的终止，需要unbindService与stopService同时调用，才能终止 Service。不管 startService 与 bindService 的调用顺序"
        const val service_activity_info = "activity与service通信"
        const val service_activity_info_answer = "一、通过Intent，startService（intent）来启动Service，在intent中放入数据，在Service的onStartCommant()中接收通过intent传过来的值。（性能差）\n" + "\n" + "二、binder+回调\n" + "在Activity中实现ServiceConnection，在onServiceConnected()中获取Service的实例，通过这个实例就能调用Service的方法和变量了。通过回调可以将Service主动将变化通知Activity。\n" + "\n" + "三、Broadcase方式\n" + "在Service中需要通知更新UI的地方，发送广播，在Activity中注册广播，在BroadcaseRecever中接受广播，更新UI。\n" + "\n" + "四、EventBus"
        const val activity_launchMode = "Activity启动模式"
        const val activity_launchMode_answer = "standard 模式:这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。\n" + "\n" + "singleTop 模式:如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的\n" + "\n" + "singleTask 模式:如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建\n" + "\n" + "singleInstance 模式：在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再启动该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。"
        const val activity_task = "如何理解Task栈？"
        const val activity_task_answer = "Android平台设计了一种堆栈机制用于管理Activity，也就是Task,它遵循先进后出的原则，系统总是显示位于栈 顶的Activity，从逻辑上将，位于栈顶的Activity也就是最后打开的Activity"
        const val activity_launchMode_how = "如何设置启动方式 "
        const val activity_launchMode_how_answer = "1、设置启动模式的位置在 AndroidManifest.xml 文件中 Activity 元素的 Android:launchMode 属性。\n" + "\n" + "2、通过intent跳转时，给intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)"
        const val activity_launchMode_question = "SingleInstance在中间会遇到的问题"
        const val activity_launchMode_question_answer = "第一种情况：因为栈不同A开启B，B开启C，如果finish C，那么A会显示而不是我们想要的B。可以通过记录开启activity，在被关闭的activity的finish方法中重新开启activityB。\n" + "\n" + "第二种情况：A开启B，然后按home键，再开应用，显示的是A，这是因为launch启动我们应用的时候 会从默认的栈找到栈顶的activity显示，这个解决办法的思路跟第一种差不多\n" + "\n" + "第三种情况：A开启C，C开启B，B开启A，结果显示的是C，这还是两个栈造成的，B开启A的时候，其实是到达A所处的栈，栈顶是C，所以就显示C了，解决办法是用flag把默认栈activity清理了，重新开启A，或者回退到C时再开启A。"
        const val http_https = "Http与Https的区别"
        const val http_https_answer = "主要有3点不同\n" + "1、安全性：HTTPS不是明文传输的，会通过SSL数据加密、TLS验证身份，以及数据完整性保护（收方或非法者不能伪造、篡改报文，运营商加广告）而HTTP是明文传输无状态的（比较独立，服务器与客户端都不会记录信息），所以安全性要高于HTTP\n" + "2、HTTPS需要申请CA证书，而HTTP不需要\n" + "3、用的端口也不一样，HTTP是80，HTTPS是443"
        const val jvm_model = "JVM模型"
        const val jvm_model_answer = "程序计数器\n" + "一块较小的内存空间，是字节码解释器的行为指示器。程序执行的过程中会有分支、循环、跳转、异常处理、线程恢复等基础功能，也就是程序运行碰到了关键字或特殊行为，字节码解释器就需要进行特殊处理，而字节码需要怎么做正是由程序计数器去通知。程序计数器是线程私有的\n" + "\n" + "虚拟机栈\n" + "Java 方法执行的内存模型，每个方法执行的时候，都会创建一个栈帧用于保存局部变量表，操作数栈，动态链接，方法出口信息等。一个方法调用的过程就是一个栈帧从 VM 栈入栈到出栈的过程。VM 栈主要用于存储方法包含的信息如，基本数据类型、局部变量等，VM 栈也是线程私有的\n" + "\n" + "本地方法栈\n" + "执行 Native 方法的栈，与 VM 栈发挥的作用非常相似，VM 栈执行Java 方法（字节码）服务，Native 方法栈执行的是 Native 方法服务。Native 栈也是线程私有的\n" + "\n" + "Java 堆\n" + "所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象都在这分配内存。Java 堆是线程共享的。\n" + "\n" + "方法区\n" + "存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。这部分区域包含「运行时常量池」，所以这个区域主要存储常量。方法区是线程共享的\n"
        const val jvm_gc_root = "GC root 对象"
        const val jvm_gc_root_answer = "1.虚拟机栈(栈帧中的本地变量表)中引用的对象\n" + "2.方法区中类静态属性引用的对象\n" + "3.方法区中常量引用的对象\n" + "4.本地方法栈中 JNI(一般说的 Native 方法)引用的对象"
        const val volatile_features = "volatile特性"
        const val volatile_features_answer = "Volatile关键字可以修饰变量，用于多线程的访问。它能保证内存的可见性和有序性，但不能保证原子性\n" + "\n" + "内存可见性：如果对变量加上volatile关键字修饰的话，它可以保证当有线程对变量值做了变动之后，会立即刷回到主内存中，所有线程都能读到相同的值\n" + "\n" + "有序性：JVM为了保证执行上的效率，可能会对指令进行重排序，而加上volatile关键字修饰后，在指令间插入一个屏障点，就告诉JVM和CPU，不能进行重排优化。其实volatile有序性是通过内存屏障实现的\n" + "\n" + "不保证原子性：有个例子，1000个线程同时去对被volatile修饰过的变量进行+1操作，但值确肯定不是1000，也就是说volatile并不能保证一个线程执行完，另一个线程才开始执行，不能保证操作并不是不可分割的。"
        const val synchronize_principle = "synchronized原理"
        const val synchronize_principle_answer = "在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。所有锁都是存储在 Java 对象头里的。jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。\n" + "\n" + "如果是方法级的同步，JVM会从方法表结构 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。如果是的话，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。\n" + "\n" + "代码块的同步是利用 monitorenter 和 monitorexit 这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当 jvm 执行到 monitorenter 指令时，当前线程试图获取 monitor 对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器 + 1；当执行 monitorexit 指令时，锁计数器 - 1；当锁计数器为 0 时，该锁就被释放了。如果获取 monitor 对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。"
        const val volatile_synchronize_different = "volatile与synchronized区别"
        const val volatile_synchronize_different_answer = "1、volatile本质上是直接从主内存中读取值，无法保证同步\n" + "\n" + "2、volatile只能实现变量的修改可见性，并不能保证原子性；而synchronizedl则因为能保证线程安全，可以保证变量的修改可见性和原子性。\n" + "\n" + "3、volatile只能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。\n" + "\n" + "4、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。"
        const val synchronize_range = "锁的作用范围"
        const val synchronize_range_answer = "作用在方法上：\n" + "\n" + "实例方法：被锁的是该类实例对象\n" + "public synchronized void method(){}\n" + "\n" + "表态方法：锁住的是类的所有对象\n" + "public static synchronized void method(){}\n" + "\n" + "\n" + "\n" + "作用在代码块上：\n" + "\n" + "实例对象：被锁的是类的实例对象\n" + "synchronized(this){}\n" + "\n" + "Class对象：被锁的是类的所有对象\n" + "synchronized(Demo.class){}\n" + "\n" + "任意实例对象Object\n" + "String a = “”;\n" + "synchronized(a){}\n" + "\n" + "\n" + "总结下，除了静态方法和锁class，其他的都是作用在实例上。"
        const val handler_four_components= "Handler四大组件"
        const val handler_four_components_answer = "Message\n" + "Message是在线程之间传递的消息，它可以在内部携带信息，用于在不同线程之间交换数据。\n" + "\n" + "Handler\n" + "处理者，它主要用来发送和处理消息。发送消息一般是使用Handler的sendMessage()方法，消息经过处理后，最终传递到Handler的handlerMessage()方法中。\n" + "\n" + "MessageQueue\n" + "消息队列，它主要用来存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理。每个线程只有一个Messgequeue\n" + "\n" + "Looper\n" + "是每个线程中MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，每当发现MessageQueue中存在一条消息，就会将其取出传递到Handler的handleMessage()方法当中。注意：每个线程中只会有一个Looper对象。"
        const val handler_use = "Handler的使用"
        const val handler_use_answer = "Handler异步消息处理流程：\n" + "首先在UI线程我们创建了一个Handler实例对象，重写handleMessage方法，我们可以通过这个方法的参数msg来实现接受消息过后Ui线程的逻辑处理。\n" + "\n" + "在子线程中需要更新UI的时候，可以通过obtain获取一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理。\n" + "\n" + "Looper会不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法 "
        const val handler_child_create = "子线程中创建handler"
        const val handler_child_create_answer = "子线程中创建Handler的方法：需要调用Looper.prepare()创建一个looper,并调用looper.loop来启动循环\n" + "\n" + "一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？\n" + "一个Thread只能有一个Looper，一个MessageQueen，可以有多个Handler。\n" + "\n" + "以一个线程为基准，他们的数量级关系是：Thread(1) : Looper(1) : MessageQueue(1) : Handler(N)。"
        const val what_anr = "ANR是什么"
        const val what_anr_answer = "ANR就是ApplicationNotResponding，应用无响应：\n" + "\n" + "当操作在一段时间内系统无法处理时，会在系统层面会弹出ANR对话框\n" + "\n" + "产生ANR可能是因为5s内无响应用户输入事件、10s内未结束BroadcastReceiver、20s内未结束Service\n" + "\n" + "想要避免ANR就不要在主线程做耗时操作，而是通过开子线程，具体方法比如使用Thread或Runnable接口、还有像AsyncTask、IntentService、HandlerThread都可以"
        const val watching_anr = "如何监控ANR"
        const val watching_anr_answer = "可以通过命令，把/data/anr/trace（吹西死）文件pull到当前目录下，无需root权限即可获取，Input dispatching timed out\n" + "\n" + "或是通过继承FileObserver，来监测data/anr目录下文件的变化，但这种方式兼容性比较差，需要root获取系统权限，开发测试阶段还是很好用的\n" + "\n" + "还有一种是，ANR-WatchDog是参考Android WatchDog机制，起个单独线程向主线程发送一个变量+1操作，自我休眠，休眠过后判断变量是否+1完成，如果未完成则告警。但也无法保证能捕捉所有ANR，比如我的休眠时间和系统时间正好错过，我还没记录你已经报错退出了 ，那就无法捕捉。\n" + "\n" + "还有blockcanary我看网上说可以捕捉一部分，但我觉得应该也有它的局限性。主要就这几种吧，还是推荐FileObserver配合WatchDog混合使用。"
        const val solve_anr = "怎么解决ANR"
        const val solve_anr_answer = "想要避免ANR就不要在主线程做耗时操作，可以通过开子线程来完成，具体方法比如使用Thread或Runnable接口、还有像AsyncTask、IntentService、HandlerThread都可以"
        const val block_canary_principle = "BlockCanary原理"
        const val block_canary_principle_answer = "blockcanary利用了主线程的消息队列处理机制\n" + "\n" + "通过就是Looper里setMessageLogging自定义一个 Printer，来获取主线程dispatch这个message的开始和结束时间\n" + "\n" + "并判定该时间超过阈值(如2000毫秒)为主线程卡慢发生，并dump出各种信息，提供开发者分析性能瓶颈。"
        const val touch_event = "事件分发流程"
        const val touch_event_answer = "Android的UI界面由Activity、ViewGroup、View 及其派生类组成，1个点击事件发生后，如果我们没有对控件里面的方法进行重写或更改返回值，而直接用super调用父类的默认实现，该事件会先传到Activity、再传到ViewGroup、最终再传到 View，再从最底层开始往上传，那这个传递模型就类似于一个U型。\n" + "\n" + "其中共涉及3个方法，分发方法dispachTouchEvent、拦截onIntercepteorTouchEvent、处理onTouchEvent。其中分发和处理是三层都有的，拦截方法是ViewGrop独有的。\n" + "\n" + "分发方法不处理会给到下一层或下一个方法处理，而它返回true和false都和处理方法一样，直接消费或是给到上一级的处理方法。\n" + "\n" + "而拦截方法返回true会给到本层的onTouchEvent处理,false和默认方法都不拦截，会向下走。\n"
        const val touch_event_move = "action_move与action_up传递流程"
        const val touch_event_move_answer = "ACTION_DOWN事件在哪个控件消费了（return true）， 不管他是传到底层返上来的，还是直接拦截在这一层消费的，那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）直接传到这一层，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。\n" + "\n" + "在ViewGroup源码中使用了一个全局变量mFirstTouchTarget来记录是否有View处理了Down事件。mFirstTouchTarget默认为null，如果发现了View可以处理，那么就会把mFirstTouchTarget的值设置为对应的View。那么随之而来的Down和Up都会交给该View处理，（mFirstTouchTarget为单链表结构）"
        const val touch_event_target = "mFirstTouchTarget为什么是链表结构"
        const val touch_event_target_answer = "因为链表结构更适合添加touchTarget\n" + "\n" + "多指触控时。第一根按下的手指触发ACTION_DOWN事件,之后按下的手指触发ACTION_POINTER_DOWN事件。\n" + "\n" + "所以当有多指进行触控的时候，addTouchTarget方法可能会被调用多次，mFirstTouchTarget以链式结构存储对应的view。"
        const val touch_event_conflict = "滑动冲突解决方案"
        const val touch_event_conflict_answer = "1、可以考虑从父布局的拦截方法onInterceptTouchEvent来处理，如果需要拦截返回true.\n" + "\n" + "2、如果不修复父布局，可以当前view.getParent().requestDisallowInterceptTouchEvent(true/false);如果传true表示父布局不做处理\""
        const val touch_event_x_different = "getX、getRawX、getTranslationX区别"
        const val touch_event_x_different_answer = "getX()是表示触摸点距离自身view左边的距离。\n" + "\n" + "getRawX()表示的是触摸点距离屏幕左边界的距离\n" + "\n" + "View.getWidth():表示的是当前控件的宽度\n" + "\n" + "View.getTranslationX()计算的是该View在X轴的偏移量。初始值为0，向左偏移值为负，向右偏移值为正。"
        const val memory_leak = "内存泄漏原因及如何解决"
        const val memory_leak_answer = "单例造成的内存泄漏：单例生命周期和应用的生命周期一样长，单例对象还持有该对象的引用，就会使得该对象不能被正常回收，替换上下文applicationcontext\n" + "\n" + "Handler造成的内存泄漏:Activity结束时，未处理的消息持有handler的引用，而handler又持有它所属的外部类也就是Activity的引用。将Handler声明为静态内部类。因为静态内部类不会持有外部类的引用，所以不会导致外部类实例出现内存泄露。在Handler中添加对外部Activity的弱引用。用完后记得清空队列removeCallbacksAndMessages\n" + "\n" + "非静态内部类造成的内存泄漏:非静态内部类默认会持有外部类的引用，如果里面再有个静态实例或延时任务，就会出现泄漏\n" + "\n" + "资源未关闭造成的内存泄漏：对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，从而造成内存泄漏\n" + "\n" + "集合容器中的内存泄露:在退出程序之前，将集合里的东西clear，然后置空，让相关对象不再被引用"
        const val animations = "Android动画"
        const val animations_answer = "逐帧动画(Frame Animation) 加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间\n\n" + "补间动画(Tween Animation)也叫视图动画 Tween可以对View对象实现一系列动画效果，比如平移，缩放，旋转，透明度等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。\n\n" + "属性动画(Property Animation) 动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了\n\n\n属性动画\n\nValueAnimator是整个属性动画机制当中最核心的一个类，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。\n" + "\n" + "但如果只是些常规动画，还是使用ObjectAnimator多一些，它会把我们常用的位移、旋转、缩放、透明等效果都做为属性参数直接调用。还可以通过addListener，添加个动画的adapter，来监听它的执行状态。还可以通过setInerpolator来配置插值器，实现些加速或掉落回弹等效果。（通过时间百分比来实现非线性需求）"
        const val hash_map="HashMap原理"
        const val hash_map_answer="HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表的表头，由 Node 内部类完成存储，Node类实现了 Map.Entry<K,V>接口。\n" + "\n" + "当存储对象时，将 K/V 键值传给 put() 方法：首先会计算出Key的hash值，如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞\n" + "\n" + "如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对，如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）"
        const val how_hash="如何计算hash值的？"
        const val how_hash_answer="采用高位16位组成的数字与源哈希值取异或而生成的哈希值作为用来计算的\n" + "\n" + "为什么要用异或？减少碰撞。可以将高低位二进制特征混合起来\n" + "\n" + "异或：两个值相同结果为0，不同结果为1"
        const val change_big="扩容机制"
        const val change_big_answer="HashMap的默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。\n" + "\n" + "这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。"
        const val red_black_time="红黑数查找性能"
        const val red_black_time_answer="jdk1.8引入了红黑树的设计，当hash表的单一链表长度超过 8 个的时候，链表结构就会转为红黑树结构。\n" + "\n" + "红黑树查询：其访问性能近似于折半查找，时间复杂度 O(logn)；\n" + "\n" + "链表查询：这种情况下，需要遍历全部元素才行，时间复杂度 O(n)；\n" + "\n" + "简单的说，红黑树是一种近似平衡的二叉查找树，其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)。"
        const val aidl = "aidl"
        const val aidl_answer = "AIDL是进程间通讯的一种方式，一般会与Service、Binder共同完成交互通信。\n" + "\n" + "首先服务端需要先创建AIDL接口文件，定义自己所需要的方法，配置好后build项目，生成aidl JAVA文件，里面会自动生成一个静态的抽像类Stub，继承了Binder，而且还实现了自己所定制aidl接口\n" + "\n" + "然后客户端需要先配置一个与服务端相同的aidl-java文件，并与服务端通过BindService的方式启动一个远程服务，服务端在onBind方法中，传给客户端一个stub代理对象，客户端在ServiceCnection的回调中得到了这个stub代理对象，就可以通过stub里定义好的接口进行通信了。\n" + "\n" + "客户端向服务端：直接用ServiceCnected里返回的bind调用就可以了。\n" + "服务端向客户端：通过接口回调，在客户端ServiceCnected里注册个callback，然后进行通信。"
        const val thread_pool_create = "线程池创建方法"
        const val thread_pool_create_answer = "创建线程池的方式一般有两种：\n" + "\n" + "1、通过Executors工厂方法创建\n" + "\n" + "2、 通过ThreadPoolExecutor构造函数创建。\n" + "\n" + "newThreadPoolExecutor(intcorePoolSize, intmaximumPoolSize, longkeepAliveTime,TimeUnitunit,BlockingQueue<Runnable>workQueue)自定义创建"
        const val thread_four_api = "Executors API提供的4种线程池"
        const val thread_four_api_answer = "Executors.newSingleThreadExecutor()：单线程的线程池，只有一个线程在工作，任务按顺利执行\n" + "\n" + "Executors.newFixedThreadPool(3)：构建固定线程数的线程池，默认情况下，空闲线程不会被回收\n" + "\n" + "Executors.newCachedThreadPool():创建一个会根据需要创建新线程的线程池，线程数随着任务量而变动，空闲线程超过60秒将被回收\n" + "\n" + "Executors.newScheduledThreadPool(空或int):创建定时线程任务的线程池，可以通过传参设置固定数量，它的实例可以调用\n" + "\n" + "scheduleAtFixRate(runnable,第一次执行延迟时间，每隔多久执行，时间单位)来周期性执行任务。"
        const val thread_seven_params = "ThreadPoolExecutor 线程池构造函数的七个参数"
        const val thread_seven_params_answer = "1、corePoolSize 线程池核心线程大小\n" + "\n" + "2、maximumPoolSize 线程池最大线程数量\n" + "\n" + "3、keepAliveTime 空闲线程存活时间\n" + "\n" + "4、unit 空闲线程存活时间单位\n" + "\n" + "5、workQueue 工作队列，JDK提供了四种\n" + "\n" + "6、threadFactory 线程工厂\n" + "\n" + "7、handler 拒绝策略，JDK提供了四种"
        const val thread_work_principle = "线程池相关"
        const val thread_work_principle_answer = "线程池任务提交过程,核心流程其实就是走的ThreadPoolExcutor类中的execute(runnable)方法：\n" + "\n" + "a. 首先判断核心线程池中的线程是否已经满了，如果没满，则创建一个核心线程执行任务，否则进入下一步\n" + "\n" + "b. 判断工作队列是否已满，没有满则加入工作队列，否则执行下一步\n" + "\n" + "c. 判断线程数是否达到了最大值，如果不是，则创建非核心线程执行任务，否则执行饱和策略，默认抛出异常"
        const val thread_shut_down = "如何关闭线程池"
        const val thread_shut_down_answer = "1. shutdown() 不接收新任务,会处理已添加任务\n" + "\n" + "2. shutdownNow() 不接受新任务,不处理已添加任务,中断正在处理的任务"
        const val thread_pool_work_queue = "工作队列 wordQueue"
        const val thread_pool_work_queue_answer = "SynchronousQueue:无缓冲等待队列.从队列中取和放都是阻塞方法,如果队列满了再往里放,会进入阻塞.如果队列中没有任务在往出取也会进入阻塞.类似于生产者与消费者模式那种的.这个队列只能装一个任务.\n" + "\n" + "LinkedBlockingQueue:无界缓存队列. 长度是Integer.MAX_VALUE,当执行的线程数量等于核心线程数量的时候,剩余的任务会在阻塞队列中等待.所以在使用这个队列的时候,最大线程数的参数相当于无效了.\n" + "\n" + "ArrayBlockingQueue:有界缓存队列可以定义队列的长度.\n" + "\n" + "PriorityBlockingQueue（具有优先级的无界阻塞队列，优先级通过参数Comparator实现）\n" + "\n" + "注意\n" + "1. 当workQueue使用的是无界限队列时，maximumPoolSize参数就变的无意义了，比如new LinkedBlockingQueue(),或者new ArrayBlockingQueue(Integer.MAX_VALUE);\n" + "\n" + "2. 使用SynchronousQueue队列时由于该队列没有容量的特性，所以不会对任务进行排队，如果线程池中没有空闲线程，会立即创建一个新线程来接收这个任务。maximumPoolSize要设置大一点。\n" + "\n" + "3. 核心线程和最大线程数量相等时keepAliveTime无作用."
        const val thread_pool_reject_policy = "线程池的拒绝策略"
        const val thread_pool_reject_policy_answer = "CallerRunsPolicy：不抛弃线程 调用线程池的线程帮助执行，如果线程池已经shutdown，则直接抛弃任务。\n" + "\n" + "AbortPolicy：该策略下，直接丢弃任务，并抛出\n" + "\n" + "RejectedExecutionException异常\n" + "\n" + "DiscardPolicy：该策略下，直接丢弃任务，什么都不做。\n" + "\n" + "DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列"
        const val thread_pool_recycling = "非核心线程的回收"
        const val thread_pool_recycling_answer = "工作线程启动后，会进入一个runWorker的方法里。\n" + "\n" + "里面是一个while循环，循环判断任务是否为空，若不为空，执行任务；若取不到任务，或发生异常，退出循环，执行processWorkerExit(w, completedAbruptly);\n" + "\n" + "在这个方法里把工作线程移除掉。"
        const val leak_canary="LeakCanary原理"
        const val leak_canary_answer="Leakcanary在初始化时会返回一个refWatcher监听器，他会注册一个callback来监听Activity的onDestroy方法。activity在执行onDestroy后需要被回收，监听机制将Activity包装到WeakReference中，被WeakReference包装过的Activity对象如果被回收，该WeakReference引用会被放到ReferenceQueue中。如果过5秒没有回收，监听机制会手动触发次GC，如果还没有被回收，那就说明Activity可能已经泄露。 这个时候就可以抓取内存dump文件来分析展示了。"
        const val java_reference = "java引用类型"
        const val java_reference_answer = "强引用：当我们使用new创建对象时，被创建的对象就是强引用，如Object object = new Object()，其中的object就是一个强引用了。如果一个对象具有强引用，JVM就不会去GC它，JVM宁可会报OOM来终止程序，也不回收该对象。\n" + "\n" + "软引用: 如果一个对象只具备软引用，如果内存空间足够，那么JVM就不会GC它，如果内存空间不足了，就会GC该对象。\n" + "\n" + "弱引用: 如果一个对象只具有弱引用，只要JVM的GC线程检测到了，就会立即回收。弱引用的生命周期要比软引用短很多。不过，如果垃圾回收器是一个优先级很低的线程，也不一定会很快就会释放掉软引用的内存。\n" + "\n" + "虚引用：如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行GC。\n" + "\n" + "\n" + "软引用一般用于图片缓存，场景，图片编辑bitmap，用法类似于SoftReference<String> sr = new SoftReference<String>(new String(\"hello\")); System.out.println(sr.get());\n" + "WeakReference<Car> weakCar = new WeakReference<Car>(car); if(weakCar.get()!=null)，虚引用可以解决一些内存泄漏的问题，如Handler之类的。"
        const val java_reference_queue = "ReferenceQueue的使用与作用"
        const val java_reference_queue_answer = "ReferenceQueue queue = new ReferenceQueue();\n" + "\n" + "SoftReference ref = new SoftReference( aMyObject , queue );\n" + "\n" + "\n" + "当软引用对象被GC之后，虽然这个SoftReference对象指向的对象已不存在,但这个SoftReference对象本身还占用内存，如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法。ReferenceQueue的poll()方法来检查是否有它所关心的非强引用对象被回收。作用就是通知处理"
        const val thread_local="ThreadLocal原理"
        const val thread_local_answer = "ThreadLocal是一个关于创建线程局部变量的类。使用场景如下所示：\n" + "\n" + "* 有助于线程安全，因为每个线程都会有一个对应的实例。承载一些线程相关的数据，避免在方法中来回传递参数。\u2028\n" + "* 实现单个线程单例以及单个线程上下文信息存储，比如交易id等。\n" + "\n" + "\n" + "什么是ThreadLocal\n" + "\n" + "ThreadLocal 是 Thread 的共享变量。有助于线程安全，因为每个线程都会有一个对应的实例。承载一些线程相关的数据，避免在方法中来回传递参数，或加synchronized上锁那么麻烦。\n" + "\n" + "\n" + "ThreadLocal的原理\n" + "\n" + "ThreadLocal中有一个ThreadLocalMap中有一个table数组，元素是Entry。根据ThreadLocal(需要转换获取到Hash Key)能get到对应的Enrty。\u2028Entry中key为ThreadLocal, value就是存储的数值。\n"
        const val sleep_wait = "sleep、wait、notify、notifyAll区别"
        const val sleep_wait_answer = "sleep、wait最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。\n" + "\n" + "1. sleep是Thread类的静态方法,wait是Object类中定义的方法\n" + "2. Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁,而wait 会释放当前线程锁\n" + "3. Thread.sleep需要设定休眠时间.Object.wait也可以设定wait时间,或者通过线程执行notify/notifyAll进行唤醒\n\nnotify与notifyAll\n\n1. notify唤醒一个线程,如果有多线程在wait,可能是随机一个\n" + "\n" + "2. notifyAll唤醒所有在等待的线程,\n" + "\n" + "3. 使用中尽量使用notifyAll,因为notify容易导致线程死锁(nofity只唤醒一个,其他等待的线程没有唤醒)"
        const val version_features = "android版本特性"
        const val version_features_answer = "6.0增加运行时权限\n" + "7.0分屏多任务、夜间模式\n" + "8.0画中画android:supportsPictureInPicture=ture，调用接口、指纹手势\n" + "9.0“刘海”屏幕支持，可以通过windowInsets.getDisplayCutout()、增加ImageDecoder替换BitmapFactory，代码更优雅\n" + "\n" + "//裁剪图像\n" + "imageDecoder.setCrop();\n" + "//调整大小\n" + " imageDecoder.setResize();\n" + "\n" + "10支持可折叠设备、5G 网络\n"
        const val handler_thread = "HandlerThread"
        const val handler_thread_answer = "HandlerThread继承自Thread，因此HandlerThread其实就是一个线程。他和优点就是，HandlerThread的run方法里就调用了Looper.preper()，和looper.loop()方法，为我们创建好了消息Looper.可以直接拿来用。使用场景就是，在子线程中执行耗时的、可能有多个任务的操作。比如说多个网络请求操作，或者多文件 I/O 等等。使用 HandlerThread 的典型例子就是 IntentService\n" + "\n" + "\n" + "HandlerThread handlerThread = new HandlerThread(\"handlerThread\");\n" + "handlerThread.start(); \n" + "\n" + "创建Handler\n" + "Handler mCheckMsgHandler = new Handler(mHandlerThread.getLooper()){\n" + "     @Override\n" + "     public void handleMessage(Message msg){\n" + "         // 进行耗时操作\n" + "     }\n" + "};"
        const val invalidate = "postInvalidate和Invalidate的区别"
        const val invalidate_answer = "一般来说，如果View确定自身不再适合当前区域，比如说它的LayoutParams发生了改变，需要父布局对其进行重新测量、布局、绘制这三个流程，往往使用requestLayout。而invalidate则是刷新当前View，使当前View进行重绘，不会进行测量、布局流程，因此如果View只需要重绘而不需要测量，布局的时候，使用invalidate方法往往比requestLayout方法更高效\n" + "\n" + "postInvalidate\n" + "这个方法与invalidate方法的作用是一样的，都是使View树重绘，但两者的使用条件不同，postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。"
        const val app_start_process = "APP启动过程"
        const val app_start_process_answer = "注（AMS是system_server中的一个进程）\n" + "\n" + "1、Launcher响应用户点击，通知AMS，需要启动一个应用\n" + "\n" + "2、AMS会检查这个应用程序所需要的进程是否存在，不存在就会请求Zygote进程启动需要的应用程序进程\n" + "\n" + "3、Zygote进程接收到AMS请求并通过fock自身创建应用程序进程，并执行ActivityThread的main方法\n" + "\n" + "4、然后App进程，通过Binder IPC向AMS进程发起attachApplication请求；\n" + "\n" + "5、AMS进程在收到请求后，进行一系列准备工作后，再通过Binder IPC向App进程发送handleBindApplication,也就是初始化Application并调用onCreate方法请求，和scheduleLaunchActivity创建启动Activity请求。\n" + "\n" + "6、App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；\n" + "\n" + "7主线程在收到Message后，通过反射机制创建目标Activity，并回调Activity.onCreate()等方法。到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。"
        const val app_start_about_role = "App启动中涉及的模块及作用"
        const val app_start_about_role_answer = "ActivityManagerService：（AMS）AMS是Android中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。\n" + "\n" + "ActivityThread：应用的入口类，通过调用main方法，开启消息循环队列。ActivityThread所在的线程被称为主线程；\n" + "\n" + "ApplicationThread：ApplicationThread提供Binder通讯接口，AMS则通过代理调用此App进程的本地方法\n" + "\n" + "Application：通过反射的方式创建了一个Application对象，并且调用了Appliction的attach()方法，而attach方法又调用了attachBaseContext方法，现在应该明白为什么该方法在Application的onCreate之前调用了。\n"
        const val app_start_start_time = "计算启动时间"
        const val app_start_start_time_answer = "本地调试的话，直接一个命令就可以了，adb shell am start -W com.example.kotlin/com.example.kotlin.activity.MainActivity，其中有个TotalTime表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，本地用这个就可以了\n" + "\n" + "冷启动：\n" + "在Application.attachBaseContext() 开始的位置记录就可以，因为在这之前 Context 还没有初始化， App 的具体业务逻辑还没开始执行。\n" + "\n" + "结束时间点：\n" + "可以在 Activity.onWindowFocusChanged 记录应用启动的结束时间点，从onWindowFocusChanged被执行起，用户可以与应用进行交互了，真正的visible时间点。如果后面有焦点变化，也会调这个方法，需要区分好。\n" + "\n" + "热启动启动时间点：\n" + "可以在 Activity.onRestart() 中记录起始时间点。\n" + "\n" + "统计线上应用的话，就需要打点了，起始时间点比较容易记录："
        const val app_start_optimize = "APP启动优化"
        const val app_start_optimize_answer = "1、在application中配置一个theme，在style中定义广告页或默认图，让用户先看默认图。\n" + "\n" + "2、在Application和activity初始化的时候，把耗时操作放到子线程中进行，非必要的功能可以懒加载，还有布局层次也要减少"
        const val app_start_method_sequence = "启动过程中方法调用顺序"
        const val app_start_method_sequence_answer = "-> Application 构造函数\n" + "\n" + "-> Application.attachBaseContext()\n" + "\n" + "-> Application.onCreate()\n" + "\n" + "-> Activity 构造函数\n" + "\n" + "-> Activity.setTheme()\n" + "\n" + "-> Activity.onCreate()\n" + "\n" + "-> Activity.onStart\n" + "\n" + "-> Activity.onResume\n" + "\n" + "-> Activity.onAttachedToWindow\n" + "\n" + "-> Activity.onWindowFocusChanged"
        const val assets_res = "Assets目录与res目录的区别"
        const val assets_res_answer = "res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即可，assets文件夹下的文件不会被映射到R文件中，访问的时候需要AssetManager类。\n" + "\n" + "res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹。"
        const val intent_service = "介绍下IntentService"
        const val intent_service_answer = "IntentService其本质上是一个Service，因为它是继承至Service，所以开启IntentService和普通的Service一致。但是他和普通的Service不同之处在于它可以处理异步任务，在任务处理完之后会自动结束。另外，我们可以启动多次IntentService，而每一个耗时任务会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且是串行执行。其实IntentService的内部是通过HandleThread和Handle来实现异步操作的。"
        const val mvp = "介绍下MVP"
        const val mvp_answer = "MVP模式分离了视图逻辑和业务逻辑，Activity只是用来相应生命周期，其他工作都丢到Presenter中完成，Presenter是Model和View之间的桥梁，为了让结构变得更加简单，View并不能直接对Model进行操作，这也是MVP与MVC最大的不同之处。"
        const val final_finally_finalize = "Java 中的 final, finally 和 finalize?"
        const val final_finally_finalize_answer = "\n" + "final：对基本类型而言，你不能改变其数值，对于引用，你不能将其指向一个新的引用，即用final关键字修饰方法，它表示该方法不能被覆盖，用final修饰的类是无法被继承的\n" + "finally：是异常处理中进行收场处理的代码块，比如关闭一个数据库连接，清理一些资源占用的问题。不管有没有异常被捕获，finally子句中的代码都会被执行。\n" + "finalize：finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，定位bug"
        const val equals_deng = " == 和 equals() 有什么区别？"
        const val equals_deng_answer = "1、对于==，比较的是值是否相等\n" + "\n" + "如果作用于基本数据类型的变量，则直接比较其存储的 值是否相等，\n" + "\n" + "如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等。\n" + "\n" + "\n" + "2、equals()方法不能作用于基本数据类型的变量，在没有重写equals()的类中，调用equals()方法其实和使用==的效果一样，也是比较的是引用类型的变量所指向的对象的地址\n" + "\n" + "不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。"
        const val equals_hash_code = " hashCode()与equals()"
        const val equals_hash_code_answer = "hashCode也是Object类的一个方法。返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。\n" + "\n" + "如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。\n" + "\n" + "如果两个对象不equals，他们的hashcode有可能相等。\n" + "\n" + "如果两个对象hashcode相等，他们不一定equals。\n" + "\n" + "如果两个对象hashcode不相等，他们一定不equals。"
        const val overloading_overriding = "重载和重写的区别"
        const val overloading_overriding_answer = "重载：方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。\n" + "\n" + "重写：是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。如果父类的方法有异常声明，那么子类重写这个方法时候，所要声明的异常不应该比父类的大。只能是小等，或者可以没有\n" + "\n" + "可否重写父类的静态方法\n" + "\n" + "静态方法，是在运行时，虚拟机已经认定此方法属于哪个类。 静态方法的调用不需要实例化， \"重写\"只能适用于实例方法.不能用于静态方法.对于静态方法,只能隐藏... "
        const val java_three_point = "java三大特性"
        const val java_three_point_answer = "封装：将类的属性和方法细节隐藏起来，只对外提供访问和修改接口\n" + "\n" + "\n" + "继承：一个类可以使用另一个类的部分属性与方法，比如子类继承父类后，除了private子 类不可见，其他属性与方法都可以使用\n" + "\n" + "\n" + "多态：一种类形具有表现多种形态的能力，多态的作用就是消除类型之间的耦合关系，它的三个必要条件是继承、重写、父类引用指向子类对象。这样可以提高程序的扩展力，是一种面向抽象编程的思想。"
        const val generic_reflection = "介绍下 泛型、反射"
        const val generic_reflection_answer = "泛型：\n" + "在集合中存储对象并在使用前进行类型转换是很不方便的，并且容易出错，为了防止这种情况，泛型产生。泛型提供了编译期的类型安全，确保我们只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException（类型转换异常）\n" + "\n" + "反射：就是动态加载一个指定的类，并获取该类中的所有的内容，比如有些第三方的JAR文件中的资源，我们没法直接调用，就可以用反射这种比较原始的方法来调用。\n" + "\n" + "1、获得Class对象，就是获取到指定的名称的字节码文件对象。\n" + "Class c = Class.forName(className);\n" + "\n" + "2、实例化对象，获得类的属性、方法或构造函数。\n" + "\u2028Field[] fields = c.getDeclaredFields();\u2028\u2028for (int i = 0; i < fields.length; i++) {\n" + "\n" + "// 打印属性的 修饰符 类型 名称\n" + "System.out.println(Modifier.toString(fields[i].getModifiers()) + \" \" + fields[i].getGenericType() + \" \"+ fields[i].getName());}\n" + "\n" + "\n" + "\n" + "3、访问属性、调用方法、调用构造函数创建对象。"
        const val join_about = "如何让线程按顺序执行"
        const val join_about_answer = "可以用线程类的join()方法，join()方法的作用，是等待这个线程结束；在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕.\n" + "\n" + "newSingleThreadExecutor()方法创建的线程池是一个基于FIFO先进先出的队列，也就是说，当我们依次将thread1，thread2，thread3加入队列中时，实际在就绪状态的只有thread1这个线程，thread2，thread3则会被添加到队列中等待，当thread1执行完毕后，则会按进入队列的先后顺序执行队列中的其他线程。"
        const val deadlock_about = "什么是死锁？死锁的四个条件，如何避免死锁"
        const val deadlock_about_answer = "死锁：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程都处于阻塞状态，无法继续。\n" + "\n" + "\n" + "四个条件\n" + "1、互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。\n" + "\n" + "2、请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n" + "\n" + "3、不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。\n" + "\n" + "4、循环等待条件:若干进程间形成首尾相接循环等待资源的关系\n" + "\n" + "\n" + "如何避免\n" + "在设计阶段就应该考虑如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。比较常用的方法：\n" + "\n" + "1、避免多次锁定。尽量避免同一个线程对多个 Lock 进行锁定。\n" + "\n" + "2、具有相同的加锁顺序。如果多个线程需要对多个 Lock 进行锁定，则应该保证它们以相同的顺序请求加锁\n" + "\n" + "3、使用定时锁。程序在调用 acquire() 方法加锁时可指定 timeout 参数，该参数指定超过 timeout 秒后会自动释放对 Lock 的锁定，这样就可以解开死锁了\n" + "\n" + "4、用算法来做死锁检测。这个了解一些，服务端可能会用到，客户端用的不多。"
        const val sum_link = "数组和链表的区别"
        const val sum_link_answer = "数组：是将元素在内存中连续存储的；它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效率比较高；它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低。\n" + "\n" + "链表：是动态申请内存空间，不需要像数组需要提前申请好内存的大小，链表只需在用的时候申请就可以，根据需要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）"
        const val array_link = "ArrayList和LinkedList的区别，以及应用场景"
        const val array_link_answer = "Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中后面的所有数据。最差情况是ON\n" + "\n" + "linkedList是基于双链表的，他的特点就是插入和删除非常快，只需要改变相邻节点的指针就可以了，但他如果用来查询就很慢了，最差情况是ON，因为他需要一个一个去找。\n" + "\n" + "除此之外像ArrayList是数组结构，所以他的起始容量是10，当数组需要增长时，就会新增一个为原来1.5倍容量的新数组，然后把原数组的数据原封不动的复制到新数组中，再把新数组赋值给原来的数组对象就完成了。所以会有空间浪费的情况\n" + "\n" + "一般情况下，LinkedList的占用空间更大，因为每个节点要维护指向前后地址的两个节点，但也不是绝对，如果刚好数据量超过ArrayList默认的临时值时，ArrayList占用的空间也是不小的，因为扩容的原因会浪费将近原来数组一半的容量\n"
        const val string_string_buffer = "介绍下String，为什么要设计成不可变的？以及StringBuffer、StringBuilder"
        const val string_string_buffer_answer = "String并不是基础类型，是final修饰的java类，之所以被设计成不可变主要是为了保证数据不被污据，方法区中的字符串池，当一个字符串已经被创建并且该字符串在池中，该字符串的引用会立即返回给变量，而不是重新创建一个字符串再将引用返回给变量。如果字符串不是不可变的，那么改变一个引用（如:string2）的字符串将会导致另一个引用（如:string1）出现脏数据。\n" + "\n" + "string不是基本数据类型，那么一个string的内存位置是什么呢？一共有两种情况：\n" + "　　1、string直接赋值：\n" + "　　　　String s = \"haha\";\n" + "　　　　s的引用存在栈内存中，引用指向的haha存在方法区的常量池中（先判断常量池中是否有一个haha，存在则直接指向）\n" + "　　2、string对象new创建\n" + "　　　　String s = new String(\"haha\");\n" + "　　　　s的引用存在于栈内存中，引用指向的haha对象，存在堆内存中（每new一次，在堆中创建一个新的haha对象）\n" + "\n" + "和String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象\n" + "\n" + "StringBuffer是线程安全的，可以在多线程操作字符串\n" + "StringBuilder是非线程安全的，性能会比StringBuffer好些"
        const val thread_application = "进程和线程的区别"
        const val thread_application_answer = "首先是定义：进程是执行中的一段程序，一个应用至少有一个进程，而线程是用来执行任务的。他们之间是包含关系，一个进程中能有一个或多个线程。\n" + "\n" + "二是进程可以拥有系统分配的资源，但线程只涉及运行栈和程序计数器。\n" + "\n" + "还有就是开销上，线程要比进程小很多，主要就是这三点。\n" + "\n" + "（每当有线程被创建的时候，JVM就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。）\n"
        const val hash_map_hashtable = "HashMap与HashTable的区别"
        const val hash_map_hashtable_answer = " Hashtable 数据结构是table数组，用元素Entry来保存数据，基中的方法是Synchronize的，而HashMap是不加锁的，在多线程并发的环境下，可以直接使用Hashtable，但使用HashMap时就必须要自己增加同步处理\n" + "\n" + " Hashtable中，key和value都不允许出现null值。HashMap中key和value都可以为null\n" + "\n" + "HashMap 要比 HashTable 效率高，现在用hashtable比较少。\n\n\njdk8以前：使用链地址法(拉链法)\n" + "从jdk8开始，使用的是链表与红黑数转换\n" + "HashMap:\n" + "1、如果冲突数量小于等于8，则是以链表方式解决冲突。\n" + "2、而当冲突大于8时且数组size>64，就会将冲突的Entry转换为红黑树进行存储。 3.而又当数量小于6时，则又转化为链表存储。\n" + "\n" + "而在Hashtable中， 都是以链表方式存储。遍历方法也不一样HashMap：iterator Hashtable：enumeration"
        const val clean_apk = "APK体积优化"
        const val clean_apk_answer = "在APP中图片就占据了很大的一部分体积，所以图片的优化是我们要关注的重点。\n" + "首先是图片格式，可以把UI同学给的图都过一遍，把png都转换webp(androidstudio自带covert to webp)或是压缩一遍，在不失真的情况下尽量压缩，还有些是可以用.9的图，就用.9来拉伸，这些都是很有效的。\n" + "\n" + "再有就是移除无用资源，可以通过Remove Unused Resources来查找出无用资源，或是用lint也行\n" + "\n" + "在gradle中打开代码压缩(minifyEnabled)、开启混淆压缩\n" + "\n" + "一些SO，也可以酌情精简，比如我们市场上基本都是使用基于armeabi的CPU架构（ABI），像微信、头条，都只保留了一套armeabi的so，所以我们也可以做些精简\n" + "\n" + "再有就是移除国际语言gradle中    defaultConfig{resConfigs 'en’}\n" + "\n" + "通过第三方框架来做资源混淆压缩啊等等（通过微信的开源的AndResGuard，资源混淆的原理是通过修改APK包里的resource.arsc文件，修改文件中的字符串池中的字符串，将其修改为简单短小的字符串，以此来减少文件大小）\n"
        const val interrupt_interrupted = "interrupt(),interrupted() 和 isinterrupted() 的区别"
        const val interrupt_interrupted_answer = "interrupt方法主要作用是将线程的中断状态设置为true，如果遇到被阻塞的线程会抛出InterruptedException异常（同时中断状态为false）。\n" + "\n" + "interrupted()用来清除当前线程的中断状态，还会返回当前线程的状态，如果线程已中断，则返回true，否则返回false。而且会清除当前Thread的中断状态，置为false。\n" + "\n" + "isInterrupted是用来获取调用线程的中断状态的，但不会重置中断状态\n" + "\n" + "一般interrupt会和isInterrupted，配合while循环、try、catch一起来使用\n"
        const val thread_status = "线程有几种状态"
        const val thread_status_answer = "在 Thread 类里有一个枚举类型 State，定义了线程的几种状态，分别有：\n" + "\n" + "New: new 一个实例出来，线程就进入了初始状态。\n" + "\n" + "Runnable: 就绪状态，像调用start() 、sleep（）结束、他线程 join() 结束都会进入runnable。线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态\n" + "\n" + "Blocked： 没有获取到锁被阻塞的状态\n" + "\n" + "WAITING： 处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n" + "\n" + "TIMED_WAITING： 处于这种状态的线程不会被分配 CPU 执行时间，在达到一定时间后它们会自动唤醒。\n" + "\n" + "TERMINATED： 当线程的 run() 方法完成时，或者主线程的 main() 方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。"
        const val binder_info = "介绍下Binder机制"
        const val binder_info_answer = "因为Linux 内核与用户空间是隔离的，所以为了支持用户程序之间通讯，Android系统通过添加一个内核模块运行在内核空间，也就是LKM，用户程序就可以通过这个模块来作为桥梁，完成通信。\n" + "\n" + "Binder 通信采用 C/S 架构，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务\n" + "\n" + "首先需要服务端向 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表中插入服务端的信息，并缓存到 ServiceManager 中去，这样就有了服务端。\n" + "\n" + "有了服务端，客户端就可以通过 ServiceManager 拿到服务端的代理，并通过Binder驱动与服务端进程通信；"
        const val catch_exception = "如何捕捉异常"
        const val catch_exception_answer = "Exception分为两类：一种是CheckedException，一种是UncheckedException，如果是CheckedException，可以用try\\catch来捕捉，如果是运行时异常，可以自定义一个工具类，实现UncaughtExceptionHandler接口，然后在application中初始化，用这个工具来捕获unchecked异常。里面需要重写一个uncaughtException方法，在里面完成错误信息收集，发送错误报告等操作"
        const val ui_block = "卡顿的原因"
        const val ui_block_answer = "卡顿最根本原因是因为掉帧，我们手机正常情况下是每秒60帧，也就是16ms一帧。\n" + "\n" + "但如果我们的线程被阻塞住了，或是因为内存不够、过度绘制这些原因，导致系统无法在16ms内绘制好，就会出现掉帧的情况，也就是我们说的卡顿，严重的话就会被用户感知到。"
        const val how_solve_block = "卡顿如何解决"
        const val how_solve_block_answer = "这要根据实际情况来做处理了\n" + "\n" + "如果是主线程阻塞的原因，可以用TraceView，它可以看出代码在运行时的一些具体信息，方法调用时长，次数，时间比率，了解代码运行过程的效率问题。\n" + "\n" + "如果是内存引起的卡顿，可以通过leakcanary，看看是不是有内存泄漏啊，或是通过Memory Profiler看看对于一些大图的加载处理，是不是需要优化的。\n" + "\n" + "过度绘制，就直接使用系统的过度绘制检测就可以了，如果是蓝绿一层两层的就可以，红色就需要再优化优化。\n"
        const val not_ui_refresh = "为什么非 UI 线程不能更新 UI"
        const val not_ui_refresh_answer = "因为一旦多线程抢着更新UI，那么界面将会乱套更新了，所以在Android中规定必须在主线程更新UI。\n" + "\n" + "他的原理是在根视图ViewRootImpl源码中的requestLayout方法中有个checkThread()方法，他在那做了个检测，如果非UI线程调用会报错。（ViewRootImpl对象是在onResume方法回调之后才创建）\n" + "\n" + "SurfaceView是一个特例。\n" + "SurfaceView是存在于独立UI线程的，它拥有surface(表面)的canvas，在绘制时，可以通过加锁和解锁来绘制，所以当界面如果更新操作时间较长，而且数据量较大的话，一般采用SurfaceView方式更新屏幕，而少用View"
        const val serializable_parcelable = "Serializable和Parcelable的区别"
        const val serializable_parcelable_answer = "所谓的序列化指的是把对象转换成字节流的过程，可以保存到文件中，也可以用来网络传输数据。\n" + "反序列化既是相反的过程，可以从我们的文件中把字节流读出来，转换为对象供我们使用。\n" + "\n" + "\n" + "序列化有两个方法，一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，但在序列化的时候会产生大量的临时变量，内部会执行大量的i/o操作，效率很低。而实现Parcelable接口稍微复杂一些，但效率更高，在内存中读写，但对象不能保存到磁盘中，因为Parcelable在外界有变化的情况下不能很好的保证数据的持续性\n" + "\n" + "Parcelable用法\n" + "\n" + "1）implements Parcelable\n" + "2）实现接口中的两个方法，一个是描述内容的，返回0就行。还有个是重写writeToParcel方法，将你的对象序列化为一个Parcel对象，把属性都写入Parcel对象中\n" + "4）实例化静态内部对象CREATOR实现接口Parcelable.Creator，实例化CREATOR时要实现其中的两个方法，其中createFromParcel的功能就是从Parcel中读取我们的对象（另一个是供外部类反序列化本类数组使用）\n" + "\n" + "调用方法\n" + "\n" + "存：intent.putExtra(\"key\", new Book(\"哈\", \"鸿\", 8));\n" + "取： Book book = intent.getParcelableExtra(\"key\");"
        const val more_process_purpose = "应用内多进程的目的、优点"
        const val more_process_purpose_answer = "1、让一个组件运行在单独的进程中，可以减少主进程所占用的内存，降低被系统杀死的概率。\n" + "\n" + "2、如果子进程因为某种原因崩溃了，不会直接导致主程序的崩溃，可以降低我们程序的崩溃率。\n" + "\n" + "3、即使主进程退出了，我们的子进程仍然可以继续工作"
        const val more_process_use = "应用内多进程的方法"
        const val more_process_use_answer = "实现：只需要添加 android:process 的属性即可，属性名可以自定义，相同的属性名的进程在同一个里面运行。\n" + "\n" + "1 . 如果android:process的值以冒号开头的话，那么该进程就是私有进程，其他应用的组件不可以和它跑在同一个进程中。\n" + "\n" + "2 . 如果以.开头，那么就是公有进程，其他应用的组件不可以和它跑在同一个进程中。其他应用通过设置相同的ShareUID可以和它跑在同一个进程。\n" + "\n" + "ShareUserId的作用，数据共享、调用其他程序资源。在manifest里可以配置android:sharedUserId=\"com.mythou.share\""
        const val more_process_question = "应用内多进程的问题"
        const val more_process_question_answer = "问题1：Application的多次重建，会初始化两回\n" + "解决：判断是否为主进程，只有主进程的时候才执行下面的操作\n" + "String processName = this.getProcessName();\n" + "processName.equals(this.getPackageName())\n" + "\n" + "问题2：静态成员的失效，设置了process属性后，产生了两个隔离的内存空间，一个内存空间里值的修改并不会影响到另外一个内存空间。所以就算是静态成员也是两个不同的成员值。\n" + "\n" + "问题3：文件共享问题，多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等，即便上锁，排队等机制，对多进程也较难实现\n" + "解决：解决方法就是统一由主进程来处理，子进程通知主进程来操作。\n" + "\n" + "问题4：调试断点，调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试。\n" + "解决：临时去掉process标签，统一在一个进程里调试，结束后再还原标签"
        const val sp_about = "介绍下SP"
        const val sp_about_answer = "SP作为Android存储数据方式之一，它是轻量级存储，只支持java基本数据类型，且在进程内可以进行数据共享"
        const val sp_why_light = "为什么说是SP是轻量级存储"
        const val sp_why_light_answer = "之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会一次性把整个文件全部加载进内存，如果SharedPreference文件比较大，会导致阻塞线程、产生大量临时对象引起GC、key和value会占用大量内存，非常消耗资源"
        const val sp_save_steps = "使用SP保存key-values的步骤"
        const val sp_save_steps_answer = "1）使用activity类的getSharedPreferences方法获得SharedPreference对象\n" + "\n" + "2）使用SP接口的edit获得Sharedpreferences.Editor对象\n" + "\n" + "3）通过sharedpreferences.editor接口的putXxx方法保存键值对，\n" + "\n" + "4）通过Sharedpreferences.editor接口的commit（）方法保存键值对"
        const val sp_principle = "SP内部工作原理"
        const val sp_principle_answer = "1、调用getSharedPreferences（）；创建一个SharedPreferences对象，其中会先判断是否存在对应xml文件\n" + "\n" + "2、如果对应的xml不存在则重新创建一个对应xml文件，如果存在则会把xml文件解析后存入一个map对象中(通过I/O流操作和xmlUtil，map为ArrayMap)。\n" + "\n" + "3、EditorImpl的putXXX方法，主要是将数据保存在一个Map中，这些数据是存储在内存中，只有调用了commit()或apply()方法之后，才会同步到磁盘中。"
        const val sp_two_save_method = "SP的两种提交方式"
        const val sp_two_save_method_answer = "commit会立即并同步保存数据。\n" + "\n" + "apply则异步保存数据，从而提高了性能。如果你不关心它的返回类型，则apply优先于commit"
        const val sp_why_no_safe = "SP是否是线程安全的？"
        const val sp_why_no_safe_answer = "在进程间是不安全的。原因是系统对SharedPreferences的读写有一定的缓存策略，即内存中有一份SharedPreferences文件的缓存\n" + "\n" + "在多进程模式下，系统对它的读写变的不可靠，当面对高并发的读写访问，SharedPreferences很很大几率会造成数据丢失\n" + "\n" + "所以，不建议在进程通信中使用SharedPreferences。"
        const val lazy_fragment_purpose = "fragment懒加载的目的"
        const val lazy_fragment_purpose_answer="viewpager+fragment结合使用等场景下，因为viewpager有着预加载机制：默认一次加载当前页面前后两个页面，如果不进行懒加载会导致多个fragment页面的生命周期被调用，这样一是会消耗内存、CPU资源，二是造成流量浪费。\n" + "\n" + "注释：同级下，onResume也会被调用"
        const val lazy_fragment_support = "support包 fragment懒加载方法"
        const val lazy_fragment_support_answer="1、viewpager+fragment场景时，主要的方法是Fragment中的setUserVisibleHint()，此方法会在onCreateView(）之前执行。使用getUserVisibleHint() 可以返回fragment是否可见状态。 通过在setUserVisibleHint中判断显示与否，再进行异步初始化，初始化后显示正常UI。\n" + "onCreateView—> lazyLoad()异步初始化方法\n" + "setUserVisibleHint—>if (isVisibleToUser)—>lazyLoad()异步初始化方法\n" + "\n" + "2、add+show+hide场景时，我们可以利用onHiddenChanged 来完成懒加载机制,它里面会返回个boolean，相当于onPause、onResume\n" + "\n" + "3、当add+hide+show和viewpager+fragment 嵌套组合时，也可以配合setUserVisibleHint+onHiddenChanged来进行懒加载，但需要设置些变量来管理状态"
        const val lazy_fragment_androidx = "Androidx下 fragment懒加载方法："
        const val lazy_fragment_androidx_answer="1、ViewPager+Fragment，在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有behavior字段的构造函数，当mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT\n" + "也就是fragment显示后只调用onResume，我们只需要在onResume中，加个标识，通过标识来进行懒加载就可以了。原理FragmentPagerAdapter 在其setPrimaryItem方法中调用了setMaxLifecycle方法，可以在其中配置\n" + "mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);\n" + "\n" + "2、add+show+hide在add fragment时仅把要显示的fragment通过setMaxLifecycle设置为只调用resume，其他fragment均设置为STARTED。\n" + "在show、hide切换显示的fragment时仅把show的fragment通过setMaxLifecycle设置为只调用onResume，其他hide的fragment再还原成STARTED\n" + "\n" + "3、复杂嵌套\n" + "当fragment嵌套fragment等复杂情况下，只要父fragment回调onresume生命周期函数那被嵌套的所有同级子fragment都会回调onresume，所以我们需要再加上fragment是否隐藏的标识，来判断是否要进行懒加载\n" + "\n" + "ViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法,可以通过setOffscreenPageLimit（）传入Int,来控制两侧要加载的数量\n" + "\n" + "解释：懒加载，只有显示时才执行onResume(),viewpager 的适配器构造行数里有个字段，可以控制是否是运行完全周期，还是显示后才只调用onResume"
        const val class_load = "类加载机制、流程"
        const val class_load_answer = "类加载指的是将类的class文件动态的加载到内存中，最终可以被虚拟机直接使用， 这些工作是通过加载器来完成的\n" + "\n" + "JVM采用的是双亲委派加载，也就是有任务会先委派给父加载器，这样从下到上逐层委派，最终会给到根类加载器，如果父类无法加载，子类才会自己尝试加载。双亲委派机制的好处一是可以避免重复加载，二是防止核心API被随意篡改。\n" + "\n" + "整体加载流程也可以叫生命周期有七步：\n" + "1、加载：把class文件加载到内存里，转换成二进制字节流\n" + "2、验证：格式、字节码等验证，保证符合虚拟机要求\n" + "3、准备：在方法区为类变量分配内存设默认值\n" + "4、解析：把虚拟机常量池中的符号引用转换为直接引用也就是内存地址\n" + "5、初始化：为类的静态变量赋初值\n" + "6、使用：\n" + "7、卸载：执行完成\n" + "\n" + "解析这一步是不固定的，有可能会放在初始化之后，为了支持JAVA语言的动态绑定"
        const val class_load_three = "JVM预定义有三种类加载器"
        const val class_load_three_answer = "1是根类加载器bootstrap classloader，他主要加载JDK/lib目录下的rt、resources等jar包和class等核心类库，他底层是由C++代码来编写的。\n" + "\n" + "2是扩展类加载器，Extention ClassLoader，可以加载ext目录下的jar包和class文件\n" + "\n" + "3是系统类加载器，App ClassLoader，加载当前应用的classpath下的所有类"
        const val abstract_interface = "抽像类与接口的差别"
        const val abstract_interface_answer = "抽象类是对整个类进行抽象，包括属性和方法，是一种模板设计。我们可以有选择地重写需要用到的方法。而接口是对行为的抽象，实现接口的一定要实现接口里定义的所有方法，里面不能有私有的方法或变量，是用于让别人使用的。还有就是一个具体类只能extends一个抽象类，可以implements多个接口。\n" + "\n" + "还有些就是定义上的区别，比如抽像类可以有构造器，但接口没有，访问修饰符抽像类可以有public protected  default等，但接口默认修饰符是public，不可以用其他修饰符。"
        const val blocking_queue = "阻塞队列的原理"
        const val blocking_queue_answer = "阻塞队列实际上是使用了Condition来模拟线程间协作，调用Condition的await()和signal()方法也都是上锁的，原理就是类似于Looper，那种生产者与消费者的场景，当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程会被唤醒，就可insert了"
        const val handler_async = "Handler同步屏障"
        const val handler_async_answer = "屏障消息是用来挡住普通消息来保证异步消息优先处理的。在next()方法中，判断下队首消息的的target是否为空，如果为空的话，说明是同步屏障消息，那它就会寻找队列中的下一个异步消息优先处理。\n" + "\n" + "Handler有个构造方法，可以传入async标志为true，这样构造的Handler发送的消息就是异步消息，优先级高于普通消息，优先发送\n" + "\n" + "还可以通过message.setSynchronus();把本条消息设成异步消息。\n" + "\n" + "同步屏障是通过MessageQueue的postSyncBarrier方法插入到消息队列的。\n" + "\n" + "移除屏障可以通过MessageQueue的removeSyncBarrier方法：\n" + "\n" + "屏障消息和普通消息的区别在于屏障没有tartget，普通消息有target是因为它需要将消息分发给对应的handler，而屏障不需要被分发，"
        const val delay_message = "延迟消息处理"
        const val delay_message_answer = "Handler会先在sendMessageAtTime这个方法里去计算消息被处理的时间，也就是当前时间加上延迟时间\n" + "\n" + "然后再把消息在enqueueMessage这个方法当中，按时间msg.when的时间先后顺序插入到消息队列中去\n" + "\n" + "handler每次插入message都会唤醒线程，通过next()方法，依次拿到队首消息，先判断屏障消息，如果不是的话\n" + "\n" + "再判断当前时间是否小于消息的执行时间，如果小于就是消息还没准备好发送，就会设置一个超时时间，给到nextPollTimeoutMillis，然后通过调用nativePollOnce本地方法进行阻塞\n" + "\n" + "等到时间后，再通过pipe管道写入数据来唤醒线程，判断时间到后，发送消息"
        const val why_no_die = "为什么Looper.loop不会卡死"
        const val why_no_die_answer = "looper.loop()是个死循环，但并不是所有的死循环都会卡死进程的，如果我们的程序运行完就结束了，那我们的应用也就没法使了。\n" + "\n" + "所以我们的应用还需要依赖死循环一直执行下去。真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume里的耗时操作\n" + "\n" + "而looper.loop在没有事务要处理的时候，便阻塞在messagequeue中的nativePollOnce()方法里。\n" + "\n" + "这是个本地代码，会通过Linux epoll监听文件描述符的写入事件来实现阻塞，直到有新事务要处理的时候，才会调用nativeWake方法，通过往pipe管道写入数据来唤醒主线程工作。\n" + "\n" + "在这期间，主线程是处于休眠状态的，并不会消耗大量CPU资源，所以looper.loop本身不会导致应用卡死。"
        const val how_many_string = "string在使用时会创建几个对象"
        const val how_many_string_answer = "String str1 = \"abc\"; // 在常量池中，如果有不需要创建  1个\n" + "\n" + "String str2 = new String(\"abc\"); // 在堆上 str2 常量池中“abc” abc如果有不需要创建   1或2个\n" + "\n" + "String str = \"abc\" + \"def\"; //在编译时已经被合并成“abcdef”字符串，因此，只会创建1个对象。\n" + "\n" + "String str = \"abc\" + new String(\"def\"); //“abc”和“def”，堆中对象new String(\"def\")和“abcdef”。还会创建一个StringBuilder来进行字符串的拼接\u2028  字符串、new、builder"
        const val volatile_principle = "volatile原理"
        const val volatile_principle_answer = "为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。\n" + "\n" + "当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。\n" + "\n" + "为了保证各个处理器的缓存是一致的，还涉及到缓存一致性协议。每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。\n" + "\n" + "所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。"
        const val fragment_activity_communication="fragment与Activity通信"
        const val fragment_activity_communication_answer="第一种：setArguments  bundle\n" + "\n" + "activity:\n" + "MyFragment myFragment = new MyFragment();\n" + "Bundle bundle = new Bundle();\n" + "bundle.putString(\"DATA\",values);//这里的values就是我们要传的值\n" + "myFragment.setArguments(bundle);\n" + "\n" + "Fragment:\n" + "Bundle bundle = getArguments();\n" + "        if(bundle!=null){\n" + "            titles = bundle.getString(\"title\");\n" + "        }\n" + "\n" + "\n" + "第二种：接口,编写接口，定义方法，在fragment中的attach方法中获取到宿主activity并赋值\n" + "if(activity instanceof FragmentBackListener ) {\n" + "    listener = (FragmentBackListener )activity; // 2.2 获取到宿主activity并赋值\n" + "} \n" + "\n" + "//fragment按钮点击时\n" + "listener.dosomething()\n" + "\n" + "\n" + "第三种：直接调用，上下文强转\n" + "  @Override\n" + "       public void onAttach(Context context) {\n" + "           super.onAttach(context);\n" + "           titles = ((MainActivity)getActivity()).getTitles();\n" + "\t}\n" + "\n" + "\n" + "第四种：广播和eventbus"
        const val r_x_java = "介绍下RxJava"
        const val r_x_java_answer = "RxJava的作用\n" + "Rxjava是一个用来实现异步的、基于事件的第三方库，适用于程序逻辑比较复杂的场景，它能够保持代码的良好的阅读性。可以理解成Android Handler 的升级版。\n" + "\n" + "原理\n" + "RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。\n" + "\n" + "线程切换\n" + " RxJava 在切换线程时用到了两个方法 subscribeOn() 和 observeOn() \n" + "* subscribeOn() : 影响的是最开始的被观察者所在的线程。当使用多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用；\n" + "* observeOn() : 影响的是跟在后面的操作（指定观察者运行的线程）。所以如果想要多次改变线程，可以多次使用 observeOn；\n" + ".subscribeOn(Schedulers.io())\n" + ".observeOn(AndroidSchedulers.mainThread())\n" + "\n" + "map与flatMap\n" + "map() 是把发射对象转成另外一个对象发射出去\n" + "flatMap()，他调用的是个Observable，常用来解决循环嵌套，也可以用于嵌套的异步，是把发射对象转成另外一个Observable,进而把这个Observable发射的对象发射出去\n"
        const val jet_pack = "介绍下JetPack"
        const val jet_pack_answer = "Jetpack是一套组件库，它提供了核心库、架构组件、UI组件、帮助我们在不同版本的机器上实现相同的功能代码，像常用的viewPager、fragment、recyclerview这些都是它提供的。\n" + "\n" + "核心库：有appcompat、core\n" + "架构组件：databinding、lifecyle\n" + "UI组件: constraintlayout、recyclerview\n" + "\n" + "其他还有些还有像车载、打印机等不常用的组件"
        const val design_patterns = "介绍下设计模式"
        const val design_patterns_answer = "常用的有\n" + "Builder模式：比如AlertDialog.Builder、glide、okhttp、retrofit在创建时都有用到，建造者模式的意思就是说将一个复杂的对象一步一步进行建造，同样的构建过程，但可以创建不同的功能与样式\n" + "\n" + "适配器模式：比如GridView、ListView与Adapter，把一个类的接口变换成客户端所期待的另一种接口，从而可以兼容正常工作\n" + "\n" + "职责链模式：View的测量、事件分发、OK都是。使多个对象都有机会处理请求，从而避免请求的发送者和接收者直接的耦合关系。\n" + "\n" + "观察者模式：比如ContentObserve、eventbus、还有些系统广播，监听wifi状态的。定义了对象之间的一对多的关系，当触发事件后，会遍历全部的register。\n" + "\n" + "享元模式：比如Java的常量池，线程池，Message的消息池。使用享元对象有效地支持大量的细粒度对象\n" + "\n" + "工厂模式：BitmapFactory、ThreadFactory，定义一个创建对象的接口，让子类决定实例化哪个类\n" + "\n" + "还有像builder是中介者模式，activity是模板方法模式，aidl用到了代理模式，这些都算是常见的。另外还有解释器模式（PackageParser来解释AndroidManifest）、备忘录模式（onSaveInstanceState）可能用的不太多。\n" + "\n" + "设计模式整体一共有23种，其实每天都会用啊，只是没有去归纳总结。有建造型5个、结构型：7个、行为型： 11个。\n"
        const val https_process = "Https传输流程"
        const val https_process_answer = "HTTPS流程\n" + "\n" + "1、客户端向服务端发送通信请求，明确好需要确信的信息，像ssl协议的版本、支持的加密算法，压缩方法等。\n" + "\n" + "2、服务端收到请求，会确认客户端传来的信息，如果协议版本不对，会关闭加密通信。同时服务端还会向客户端传送自己的公钥证书\n" + "\n" + "3、客户端收到证书后，首先会进行验证合法性，是否过期、发行机构、域名是否匹配等。验证通过之后，就会生成一个随机的对称密钥（session key），再使用证书中的公钥进行加密，然后传递给服务器端\n" + "\n" + "4、服务器收到使用公钥加密的内容，使用私钥解密后，拿到客户端值过来的随机值，然后把内容通过该值进行对称加密，传给客户端。\n" + "\n" + "5、客户端再用之前生成的随机值来解密，拿到内容\n" + "\n" + "整体过程就是先确认信息，然后是非对称加密传输对称加密的密钥，再拿对称密钥加密解密。\n"
        const val concurrent_hash_map = "ConcurrentHashMap 原理"
        const val concurrent_hash_map_answer = "在JDK 1.7中，ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成的。使用的是分段锁技术(ReentrantLock)，然后给每一段数据配一把锁（segment），当一个线程占用一把锁（segment）访问其中一段数据的时候，其他段的数据也能被其它的线程访问，默认分配16个segment，效率要比hashtable要高很多。\n" + "\n" + "JDK1.8中ConcurrentHashMap取消了segment分段锁，而采用CAS(原子操作)和synchronized来保证并发安全。数据结构跟HashMap很像，数组+链表/红黑二叉树。\n" + "synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升了很多。"
        const val auto_adapter_screen = "屏幕适配方案"
        const val auto_adapter_screen_answer = "1、自适配图片，也就是在res下的选择相应的dpi，不过没特殊需求的话推荐xxdpi，1080*1920，这样就可以满足向上向下兼容，节省资源\n" + "\n" + "2、如果有特殊需求，可以创建指定的分辨率布局进行适配，手机会根据分辨率去找设定的不同大小的layout的布局，layout-800 * 480\n" + "\n" + "3、dp+自适应布局+weight比例布局直接适配\n" + "\n" + "4、另外还可以对value进行指定适配，比如把一些dimen值按比例进行自定义值   value-1080*1920\n" + "\n" + "5、还有一种是修改手机的设备密度 density，他是通过appDisplayMetrics.density动态设置，来使不同分辨率，来实现UI样式统一，不过这种方式只能一刀切的将整个项目进行适配，但适配范围是不可控的，一般不用。"
        const val http_error_code = "http错误码"
        const val http_error_code_answer = "1xx   信息性状态码，接受的请求正在处理\n" + "\n" + "2xx\t成功状态码，请求正常\n" + "200： 请求成功。一般用于GET与POST请求\n" + "201 - Created 服务器已经创建了文档，Location头给出了它的URL\n" + "202 - Accepted 已经接受请求，但处理尚未完成\n" + "\n" + "3xx\t重定向状态码\n" + "301 Moved Permanently：永久性重定向\n" + "302 Found：临时性重定向\n" + "\n" + "4xx\t客户端错误状态码\n" + "400：Bad Request 请求出现语法错误\n" + "401 - Unauthorized 访问被拒绝，客户试图未经授权访问受密码保护的页面。\n" + "403 - Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致\n" + "404 - Not Found 无法找到指定位置的资源。这也是一个常用的应答\n" + "\n" + "5xx\t服务端错误状态码\n" + "500 - Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求\n" + "502 - Bad Gateway 服务器用作网关或代理服务器时收到了终端服务器的无效响应\n" + "503 - Service Unavailable 服务不可用，服务器由于维护或者负载过重未能应答\n"
        const val url_process = "输入一个网址的全过程"
        const val url_process_answer = "输入网址后，首先会从浏览器、系统、路由器当中查看是否有缓存，如果有从缓存当中显示页面，没有的话再进行DNS域名解析，把域名转换成IP，然后TCP连接，进行请求，请求成功后再把数据进行解析，页面渲染。"
        const val tcp_udp_different = "TCP、UDP协议的区别"
        const val tcp_udp_different_answer = "UDP：面向无连接，速率快。不可靠\n" + "\n" + "TCP：在传递数据之前先建立连接，数据传输结束后还要释放资源。可靠但传输速率相对慢。\n" + "\n" + "TCP的可靠性体现在：在传递数据之前建立连接，在数据传递时，通过确认、窗口、重传、拥塞机制来保证数据传输的可靠性。\n" + "\n" + "适用场景：UDP：适用于实时应用（IP电话、视频会议、直播等）。TCP:适用于要求可靠传输的应用，例如文件传输"
        const val net_work_level = "网络通信一共有几层"
        const val net_work_level_answer = "OSI模型，也就是开放式系统互联通信参考模型。这个模型把网络通信的工作分为7层，分别是\n" + "物理层,\n" + "数据链路层,\n" + "网络层,\n" + "传输层,\n" + "会话层，\n" + "表示层\n" + "和应用层。\n" + "\n" + "1至4层被认为是低层，这些层与数据移动密切相关。5至7层是高层，包含应用程序级的数据。每一层负责一项具体的工作，然后把数据传送到下一层"
        const val framework_about = "介绍下Android架构"
        const val framework_about_answer ="android架构有四层（application程序层、framework程序框架层、libraris程序运行库层、linux核心层），framework处于第二层，也叫应用程序框架层，主要是为应用层的开发者提供API各种服务的。\n" + "该层包括活动管理器、窗口管理器、内容提供者、视图系统、包管理器、电话管理器、资源管理器、位置管理器、通知管理器和 XMPP 服务十个部分。\n" + "\n" + "Framework框架包含了3个主要部分：服务端、客户端、Linux驱动。\n" + "\n" + "像AMS（ActivityManagerService）WMS（WindowManagerService）这些都是常接触到的系统服务（这些系统服务都是以一个线程的方式存在于SystemServer进程中。）\n" + "\n" + "客户端：ActivityThread、Activity、PhoneWindow、WindowManager这些也算是常接触到的客户端类\n" + "\n" + "Linux驱动和Framework相关的主要包含两部分，分别是SurfaceFlingger(SF)和Binder。\n" + "每一个窗口都对应一个Surface, SF驱动的作用是把各个Surface显示在同一屏幕上。Binder驱动的作用是提供跨进程（IPC)的消息传递机制。"
        const val jvm_gc_work = "简述GC机制"
        const val jvm_gc_work_answer ="Java 中的堆是用于存放实例对象的，堆被划分成年轻代 ( Young )、老年代 ( Tenured)。\n" + "\n" + "年轻代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。配比是8：1：1。大多数刚被创建的对象会存放在伊甸园空间，当空间不足时，会触发MinorGC，MinorGC采用复制算法。首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域，清空Eden和ServicorFrom中的对象，再把ServicorTo和ServicorFrom互换。将在指定次数回收后仍然存在的对象移动到老年代中,MinorGC执行完后，会得到一个空的可用的年经代。\n" + "\n" + "在年轻代经历多次垃圾回收后仍然存活的对象，会被放到老年代，老年代空间不足时会触发Full GC，所采用的是标记-清除算法，或者标记整理算法。\n" + "首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。\n" + "\n" + "老年代触发Full GC的频率要比年轻代低，耗时要长。\n" + "\n" + "之前还有持久代，用于存放静态文件，如今Java类、方法等，JAVA8 开始持久代也已经被彻底删除了。现在取代它的是方法区。"
        const val mark_rubbish = "标记垃圾的算法："
        const val mark_rubbish_answer ="主要是可达性分析算法：通过栈中的引用、方法区中的常量和静态变量这些根节点开始向下搜索，当没有被这个引用链相关联，也就是从GC Roots到这个对象不可达时，则证明对象是不可用的。\n" + "\n" + "了解  --->引用计数算法：对象有一个引用，就增加一个计数，删除一个引用，就减少一个计数。垃圾回收时，只回收计数为0的对象。此算法无法处理循环引用的对象。"
        const val clean_rubbish = "清除垃圾的算法："
        const val clean_rubbish_answer ="1、标记清除法：第一阶段从根节点标记所有引用对象，第二阶段遍历整个堆，对未做标记的对象进行清除。缺点此算法会暂停整个应用，stop the world，而且会产生内存碎片。老年代\n" + "\n" + "2、复制算法：此算法把内存划为两个相等的区域，每次只使用其中一个区域，垃圾回收时，把正在使用的对象复制到另外一个区域，算法可以整理相应的内存，缺点是需要2倍的区域。一般用于年轻代。\n" + "\n" + "3、标记整理：第一阶段从根节点标记所有引用对象，第二阶段清除未标记对象，然后把堆中的存活对象向一端按顺序存放。一般用于老年代"
        const val rubbish_robot = "垃圾收集器介绍下"
        const val rubbish_robot_answer ="JVM1.5以上支持CMS垃圾收集器，最新JDK9之后默认使用的是G1收集器，\n" + "\n" + "CMS使用的是标记-清除算法，会有内存碎片，范围是老年代，而G1采用“标记-整理”算法，进行了空间整合，降低了内存空间碎片\n" + "\n" + "另外G1可以控制回收垃圾的时间，还可以建立停顿的时间模型，选择一组合适的Regions作为回收目标，达到实时收集的目的，而CMS只能是尽量减少STW为目的，时间不可控"
        const val android_base = "简述Android系统的基本架构"
        const val android_base_answer ="Android 系统架构分从下往上为 Linux 内核层、系统运行库层、应用程序框架层 和 应用程序层，各层的功能为：\n" + "\n" + "Linux 内核层负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能；\n" + "\n" + "系统运行库层通过一些 C/C++ 库来为 Android 系统提供主要的特性支持；\n" + "\n" + "应用程序框架层提供构建应用程序时可能用到的各种 API，开发人员主要是使用该层封装好的 API 进行快速开发；\n" + "\n" + "应用程序层提供一些核心应用程序包。"
        const val view_draw_process = "view的绘制流程"
        const val view_draw_process_answer ="view的绘制是从根视图 ViewRoot 的 performTraversals() 方法开始，从上到下遍历整个视图树，具体操作是分发给 ViewGroup 的，ViewGroup 通过遍历自身所有的子 View，并逐个调用子 View 的 measure、layout、draw 方法实现测量、定位、绘制操作。\n" + "\n" + "如果想自定义View的测量，需要重写onMeasure()方法，我们可以通过mesureSpec获取到view的尺寸，改写过后还需要调用setmeasuredimension方法来配置他的宽高。(布局文件是warp，但我们想改成固定值就可以用onMesure)\n" + "\n" + "layout的作用就是为整个View树计算实际的位置，他和mesure一样，需要递归的去计算每一个子视图的位置。如果需要重写，可以调用onLayout方法，要传入标识，还有左上右下这4个相对于父view的距离参数。\n" + "\n" + "draw作用就是绘制View 的背景、子View、还有前景跟滚动条等。还有一个onDraw空方法，自定义View的话需要重写，在里面绘制自己需要添加的内容"
        const val surfaceView_about = "介绍下SurfaceView"
        const val surfaceView_about_answer ="SurfaceView在单独线程中进行绘图，有独立的绘图表面。适用于界面频繁更新、对帧率要求较高的情况。像相机预览、地图之类的都可以使用。\n" + "\n" + "SurfaceView可以控制刷新频率。\n" + "SurfaceView底层利用双缓存机制，绘图时不会出现闪烁问题。双缓冲技术是游戏开发中的一个重要的技术，主要是为了解决 反复局部刷屏带来的闪烁，surfaceView是通过surfaceHolder.lockCanvas锁定画布，实现下一张图片的绘制，再通过另外的线程刷新界面，绘制图片。\n" + "View是直接在ondraw里绘制图片，刷新界面。\n" + "\n" + "View适用主动更新，SurfaceView 适用被动更新"
        const val surfaceView_use = "SurfaceView的使用"
        const val surfaceView_use_answer ="首先要继承SurfaceView，实现SurfaceHolder.Callback接口。\n" + "\n" + "重写方法：\n" + "surfaceChanged：surface大小或格式发生变化时触发，在surfaceCreated调用后该函数至少会被调用一次。\n" + "surfaceCreated：Surface创建时触发，一般在这个函数开启绘图线程（新的线程，不要再这个线程中绘制Surface）。\n" + "surfaceDestroyed：销毁时触发，一般不可见时就会销毁。\n" + "\n" + "利用getHolder()获取SurfaceHolder对象，调用SurfaceHolder.addCallback添加回调\n" + "\n" + "SurfaceHolder.lockCanvas 获取Canvas对象并锁定画布，调用Canvas绘图，SurfaceHolder.unlockCanvasAndPost 结束锁定画布，提交改变。"
        const val list_diff = "RecyclerView 与 ListView 的区别"
        const val list_diff_answer="一. RecyclerView多了一些LayoutManager工作，但实现了布局效果多样化\n" + "1、ListView 的布局比较单一，只有一个纵向效果。\n" + "2、RecyclerView 可以在LayoutMananger中设置：线性布局（纵向，横向），表格布局，瀑布流布局\n" + "\n" + "二.一些常用功能的api不同，比如 Listview可以通过addHeaderView() 与 addFooterView()来添加头部item与底部item，但RecyclerView需要在Adapter中自己编写。还有Listview有onItemClickListener、onItemLongClickListener(),但RecyclerView需要通过addOnItemTouchListener或在item中实现。其他还有Listview没有局部刷新（notifyItemChanged），setTag()、getTag()等。\n" + "\n" + "三.ViewHolder的编写规范化，ListView是需要自己定义的，而RecyclerView是规范好的\n" + "\n" + "四.RecyclerView有嵌套滚动机制，但Listview没有：\n" + "在事件分发机制中，Touch事件在进行分发的时候，由父View向子View传递，一旦子View消费这个事件的话，那么接下来的事件分发的时候，父View将不接受，由子View进行处理；但是与Android的事件分发机制不同，嵌套滚动机制（Nested Scrolling）可以弥补这个不足，能让子View与父View同时处理这个Touch事件，主要实现在于NestedScrollingChild与NestedScrollingParent这两个接口；而在RecyclerView中，实现的是NestedScrollingChild，所以能实现嵌套滚动机制；"
        const val butter_knife = "ButterKnife作用及原理"
        const val butter_knife_answer="可以用来做View绑定和Click事件处理功能，\n" + "\n" + "编译代码时，butterKnife会扫描Java代码中所有的ButterKnife注解@Bind、@OnClick、@OnItemClicked这些类，然后ButterKnifeProcessor会帮你生成一个Java类，这个ViewBinder类中包含了所有对应的代码，比如@Bind注解对应findViewById(), @OnClick对应了view.setOnClickListener()等等 。我们会调用ButterKnife.bind(this)，动态注入所有的注解过的View属性和click方法"
        const val mvc = "介绍下MVC及优缺点"
        const val mvc_answer="视图层(View) 对应于xml布局文件和java代码动态view部分 \n" + "\n" + "控制层(Controller) MVC中Android的控制层是由Activity来承担的，Activity本来主要是作为初始化页面，展示数据的操作，但是因为XML视图功能太弱，所以Activity既要负责视图的显示又要加入控制逻辑，承担的功能过多。 \n" + "\n" + "模型层(Model) 针对业务模型，建立数据结构和相关的类，它主要负责网络请求，数据库处理，I/O的操作。 \n" + "\n" + "优点：具有一定分层，灵活性强部署快、便于理解\n" + "缺点：MVC的视图层和控制层无法完全解耦，都要由Activity来承担，结构复杂，不好解耦。"
        const val mvvm = "介绍下MVVM及优缺点"
        const val mvvm_answer="数据的获取、存储、数据状态变化都是Model层的任务，Model提供数据获取接口供ViewModel调用，经数据转换和操作并最终映射绑定到View层某个UI元素的属性上。\n" + "\n" + "ViewModel层做的事情刚好和View层相反，ViewModel只做和业务逻辑和业务数据相关的事\n" + "\n" + "View层做的就是和UI相关的工作，我们只在XML、Activity和Fragment写View层的代码，View层不做和业务相关的事\n" + "\n" + "优点：MVVM的优势是进一步解耦UI逻辑与业务逻辑. \n" + "相比于mvp各层的耦合度更低，一个viewmodel层可以给多个view层共用。\n" + "缺点：数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。\n" + "对于过大的项目，数据绑定需要花费更多的内存"
        const val hot_repair = "介绍下热修复"
        const val hot_repair_answer = "热更新常用的方案有两种，热启动的底层替换方案及冷启动的类加载方案\n" + "\n" + "Qzone、Tinker都是利用类替换的修复方式，Qzone是把修改后的dex补丁文件，通过反射放在dexElemets这个数组的第一个元素，这样当ClassLoader查找类的时候，会优选选择排在前面的dex文件中的类。Tinker在这个基础上稍稍做了些优化，它不再将dex增加到elements数组中，而是将dex与应用的classes.dex合并，然后整体替换掉旧的DEX，达到修复的目的。这两种都是重启生效的。（他们都支持类替换、资源替换，Tinker还支持so替换）\n" + "\n" + "Robust利用字节码插桩，对每个函数在编译打包阶段自动插入了一段代码，类似于代理，将方法执行的代码重定向到其它方法中。通过这种方式达到即时修复的目的。（不支持类、资源、so的替换，但支持时时更新）\n" + "\n" + "Sophix同时支底层替换与类加载，类加载的方案和Qzong的相似，也是放到dexElemets数组中优先加载。底层替换是在native层利用Hook钩子在事件传送到终点前截获并监控事件的传输，直接替换有bug的方法，通俗点说就是通过虚拟机注入修改ArtMethod，与Java反射的方式，达到Java函数重定向的目的。"
        const val retrofit_about = "介绍retrofit"
        const val retrofit_about_answer ="首先，通过Builder创建Retrofit对象\n" + "\n" + "在create方法中，通过JDK动态代理的方式，生成实现类，在调用接口方法时，会触发InvocationHandler的invoke方法，将接口的空方法转换成ServiceMethod, \n" + "\n" + "然后生成okhttp请求，通过callAdapterFactory找到对应的执行器，最后通过ConverterFactory将返回数据解析成JavaBena，\n" + "\n" + "使用者只需要关心请求参数，内部实现由retrofit封装完成，底层请求还是基于okhttp实现的。"
        const val retrofit_principle = "retrofit原理"
        const val retrofit_principle_answer ="首先，通过Builder创建Retrofit对象\n" + "\n" + "在create方法中，通过JDK动态代理的方式，生成实现类，在调用接口方法时，会触发InvocationHandler的invoke方法，将接口的空方法转换成ServiceMethod, \n" + "\n" + "然后生成okhttp请求，通过callAdapterFactory找到对应的执行器，最后通过ConverterFactory将返回数据解析成JavaBena，\n" + "\n" + "使用者只需要关心请求参数，内部实现由retrofit封装完成，底层请求还是基于okhttp实现的。"
        const val dynamic_proxy_good = "动态代理的优点"
        const val dynamic_proxy_good_answer ="retrofit网络请求：调用apiServer方法时，直接获取到方法的所有信息，然后进行一系列解析，最后通过okhttp3完成网络请求。网络请求完全封装在一个类中，最大程度降低耦合性。\n" + "如果想实现一组方法无论在哪里调用，都在主线程执行。通过动态代理接管执行方法，判断当前线程是否为主线程。是则执行，不是则切到主线程执行。就不需要再每一个方法执行的时候单独去判断。\n" + "事务的实现，在方法被执行时通过其他条件判断该方法是不是真的应该被执行。如果应该，再执行。"
        const val sleep_0 = "sleep(0)的作用"
        const val sleep_0_answer ="在线程中，调用sleep（0）可以释放cpu时间，让线程马上重新回到就绪队列而非等待队列，sleep(0)释放当前线程所剩余的时间片（如果有剩余的话），这样可以让操作系统切换其他线程来执行，提升效率。"
        const val thread_create = "线程创建方式"
        const val thread_create_answer = "创建线程有三种方式，最后都是start();\n" + "\n" + "一、继承 Thread 类，扩展线程。\n" + "\n" + "二、实现 Runnable 接口，\n" + "\n" + "三、实现 Callable 接口，与Runnable区别可以有返回结果，允许抛异常（runnable异常只能内部消化，不能上抛）"
        const val thread_stop = "关闭线程"
        const val thread_stop_answer ="1、使用boolean标志位终止线程，让线程自己完成运行，要用volatile声明。\n" + "\n" + "2、使用Interrupte方法标记停止，然后while循环和isInterrupted判断是否被中断，并添加中断逻辑。\n" + "\n" + "3、是已经过时的stop方法。不推荐STOP的原因：线程被杀掉，马上被别的线程上锁，数据写还一半就被别的线程上锁，连清理的机会都没有，拿到异常数据，一定会出问题。"
        const val thread_change = "线程的切换"
        const val thread_change_answer ="切换方法：join()、yeild()、wait()notify、reentraintLock和condition的await()、singin()\n" + "\n" + "sleep()使当前线程进入停滞状态(阻塞当前线程)，让出CUP的使用，不释放锁\n" + "\n" + "wait() 方法 暂停线程，释放 cpu 控制权，同时释放对象锁的控制\n" + "\n" + "yield() 只是给相同优先级的线程让出 cpu 资源，如果没有相同优先级的线程，那么它还是会得到执行\n" + "\n" + "join()可以放参数，表示等多久，也可以线程来调，谁调谁先执行   下面代码表示  thread1先执行     join (0) 等价于 join ()无限等待\n" + "    private val thread1 = Thread{\n" + "        Thread.sleep(1000)\n" + "        println(join1)\n" + "    }\n" + "    private val thread2 =Thread{\n" + "        thread1.join()\n" + "        println(join2)\n" + "    }"
        const val thread_safe = "线程安全"
        const val thread_safe_answer ="主要是保证线程中途不被其他线程干扰，可以通过synchronized或使用lock来保证线程同步，还可以使用ThreadLocal来维护变量\n" + "\n" + "还可以保证内存可见性，可以使用volatile修饰变量"
        const val kotlin_good = "Kotlin优点"
        const val kotlin_good_answer = "Kotlin相比较Java优点还是比较明显的，它完全兼容JAVA，AS就提供了JAVA项目转Kotlin的功能。首先它是空指针安全的，对于非空引用类型，Kotlin在编译时就会进行检测，如果值是null，会编译失败。如果想要允许为null，我们需要在变量的类型后面加上一个?号，表明它是可空类型。\n" + "\n" + "还有就是数据类 Data Class，它们可以自动生成样板，像equals，hashCode，toString，getter / setter等可以直接使用等。\n" + "\n" + "再有就是扩展函数，我们可以不通过继承、不修改源码等方式，给对象类增加属性和方法，比如一个TextView，我们只是用扩展属性调用的方式就可以给它进行加粗操作。最后还有像智能转换，支持lamda等比较快捷的特性"
        const val kotlin_coroutines = "介绍下Kotlin Coroutines(协程)"
        const val kotlin_coroutines_answer = "协程可以理解是轻量级的线程，它依赖于线程，但不像线程，切换或阻塞的开销都比较大，协程挂起时不需要阻塞线程，还有就是一个线程中可以创建任意个协程。\n" + "\n" + "另外它不需要多次回调，有点类似rxjava，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样（协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来）"
        const val coroutines_create = "async与launch 创建的区别"
        const val coroutines_create_answer = "launch - 创建协程\n" + "async - 创建带返回值的协程，返回的是 Deferred 类\n" + "\n" + "在概念上，async 就类似于 launch。它启动了⼀个单独的协程，这是⼀个轻量级的线程并与其它所有的 协程⼀起并发的⼯作。不同之处在于 launch 返回⼀个 Job 并且不附带任何结果值，⽽ async 返回 ⼀个 Deferred⼀个轻量级的⾮阻塞 future，这代表了⼀个将会在稍后提供结果的 promise。你可 以使⽤ .await() 在⼀个延期的值上得到它的最终结果\n" + "（runBlocking单元测试用）"
        const val coroutines_stop = "协程体、挂起函数"
        const val coroutines_stop_answer ="协程体是一个用suspend关键字修饰的一个无参，无返回值的函数类型。被suspend修饰的函数称为挂起函数,与之对应的是关键字resume（恢复），注意：挂起函数只能在协程中和其他挂起函数中调用，不能在其他地方使用。\n" + "suspend函数会将整个协程挂起，而不仅仅是这个suspend函数，也就是说一个协程中有多个挂起函数时，它们是顺序执行的。另外delay(time) 也可以挂起\n" + "\n" + "取消\n" + "cancel()"
        const val flutter_about = "介绍下flutter"
        const val flutter_about_answer = "Flutter 是由Google 开发的一个响应式、跨平台的开发工具，它主要聚焦在在UI搭建和渲染层的事情，架构是采用的分层设计。\n" + "\n" + "从下到上依次为：Embedder（嵌入器）主要是适配各平台的、Engine是些基础库，包括skia和dart等、最上层是Framework，我们的应用围绕 Framework 层来构建的。\n" + "\n" + "我觉得Flutter有两个特性是比较出众的，一是支持热重载，我们在开发时，能把代码文件注入正在运行的Dart虚拟机（VM）中。Flutter框架会自动重新构建widget树，我们可以快速查看更改的效果。\n" + "\n" + "还有就是Widget，widget是整个视图描述的基础，像基础组件、布局、手势等，都是由Widget组件来实现的，通过Widget组件，能够让我们非常轻松的实现Android或者IOS风格的UI效果。"
        const val content_provider = "什么是ContentProvider"
        const val content_provider_answer = "ContentProvider为存储和获取数据提供了统一的接口，供外部调用\n" + "\n" + "外部应用通过getContentResolver().delete(uri,String,String[])(直接调不用继承和实现ContentResolver)"
        const val content_resolver = "介绍下ContentResolver"
        const val content_resolver_answer = "是数据调用者，ContentProvider将数据发布出来，通过ContentResolver对象结合Uri进行调用\\n\" + \"\\n\" + \"通过ContentResolver对象可以调用ContentProvider的增删改查"
        const val content_provider_uri = "什么是URI"
        const val content_provider_uri_answer = "Uri（通用资源标识符 Universal Resource Identifer），代表数据操作的地址，每一个ContentProvider发布数据时都会有唯一的地址。"
        const val content_provider_steps = "创建自定义ContentProvider的步骤"
        const val content_provider_steps_answer = "1.使用SQLite技术，创建好数据库和数据表\n" + "\n" + "2.新建类继承ContentProvider\n" + "\n" + "3.重写6个抽象方法 onCreate、delete、insert、query、update、getType\n" + "\n" + "4.创建UriMatcher，定义Uri规则\n" + "\n" + "5.在Manifest中注册provider\n" + "\n" + "6.ContentResolver对ContentProvider中共享的数据进行增删改查操作"
        const val android_annotation = "什么是注解"
        const val android_annotation_answer = "注解就是一种类似注释的机制，用来将信息或元数据与程序元素(类、方法、成员变量等)进行关联，为程序加以说明。\n" + "\n" + "原理：注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象 \$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用 AnnotationInvocationHandler 的 invoke 方法。该方法会从 memberValues 这个 Map 中索引出对应的值。而 memberValues 的来源是 Java 常量池。\n" + "\n" + "系统内置标准注解：Override、Deprecated、SuppressWarnnings\n" + "\n" + "注释：元数据是指用来描述数据的数据，更通俗一点，就是描述代码间关系，或者代码与其他资源(例如数据库表)之间内在联系的数据。"
    }
}

