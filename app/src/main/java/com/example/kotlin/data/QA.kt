package com.example.kotlin.data

/**
 * Author: sym
 * Date: 2021/7/13 8:11 PM
 * Describe:
 */
 class QA{

    companion object {
        const val performance_optimization = "性能优化"
        const val performance_optimization_answer = "性能优化：Android的性能优化，主要是从以下几个方面进行优化的：\n" + " \n" + "一是稳定性，是否有内存溢出、崩溃的情况\n" + "\n" + "二是流畅性，有没有卡顿，冷启动时间长不长\n" + "\n" + "三是耗损是否严重，耗电、流量多不多啊\n" + "\n" + "四是安装包体积等，有没有冗余可优化空间 \n\n\n内存优化\n1.使用leakcanery先解决程序中内存占用较大的业务模块中的内存泄漏\n" + "2.移除程序中多余的代码和引用，这里使用默认的lint检测再配合shrinkResources来删除无效资源\n" + "3.优化图片，保证图片放置在合理的文件夹，根据View大小加载合适的图片大小，根据手机状态配置bitmap和回收策略\n" + "4.优化对象创建，比如string，使用对象池等\n\nAndroid官方对象池的简单实现：SimplePool，也是用得最多的实现\n" + "原理：使用了“懒加载”的思想。当SimplePool初始化时，不会生成N个T类型的对象存放在对象池中。而是当每次外部调用release()时，才把释放的T类型对象存放在对象池中。要先放入，才能取出来。   这样就避免了内存抖动。\n\nMemory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。\n" + "瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。\n"
        const val tcp_shake_hands = "Tcp握手过程"
        const val tcp_shake_hands_answer = "TCP三次握手：\n" + "\n" + "1：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；\n" + "\n" + "2：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n" + "\n" + "3：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n" + "\n" + "四次挥手：\n" + "1、主动关闭方会发一个长度为0的数据包以及FIN关闭标识。\n" + "\n" + "2、被动方收到FIN后，会发一个ACK确认包，确认序号+1。\n" + "\n" + "3、确认无需要发送数据后，被动关闭方也会发一个FIN包，告诉主动关闭方，我也不会再发数据了。\n" + "\n" + "4主动关闭方发ACK确认，确认序号+1。\n\n" + "两次不行，为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。\n" + "\n" + "确认号要加1，因为报文不一定会按发送的时序到达目标，为了区分所以要加1\n" + "\n" + "出现大量的close_wait是因为被动关闭方没有发送FIN包确认关闭，是程序的问题。\n" + "如果是server主动关闭链接,那么Client则有可能进入CLOSE_WAIT,如果Client不发送FIN包，该关不关,那么client就一直会处在CLOSE_WAIT状态\n" + "\n" + "为什么是4次握手，因为被动方收到FIN后，需要先确认，防止主动方因等待时间过长再发FIN，被动方处理完数据后再发FIN"
        const val draw_view = "View的绘制流程"
        const val draw_view_answer = "介绍下实现一个自定义View的基本流程\n" + "①.自定义View的属性 编写attr.xml文件 ②.在layout布局文件中引用，同时引用命名空间 ③.在View的构造方法中获得我们自定义的属性 ，在自定义控件中进行读取（构造方法拿到attr.xml文件值） ④.重写onMesure 、onDraw    如果有需要还可以重写onTouchEvent"
        const val lock_type_use = "锁的分类及用法"
        const val lock_type_use_answer = "Synchronized的用法 ：\n" + "锁主要有三种\n" + "\n" + "类锁:像synchronized(class)或是锁静态方法，这种都是类锁，作用范围比较大，类的所有对象都会被作用到。\n" + "\n" + "第二种是对象锁，像普通方法锁就是，他的作用范围就是一个对象，不同线程不能同时执行一个对象的不同synchronized方法。\n" + "\n" + "还是就是同步代码块，synchronized（obj），这个的作用范围就是被作用的代码块上。"
        const val four_components = "四大组件"
        const val four_components_answer = "Activity【活动】：用于表现功能。 \n" + "Service【服务】：后台运行服务，不提供界面呈现。 \n" + "BroadcastReceiver【广播接收器】：用来接收广播。 \n" + "Content Provider【内容提供商】：支持在多个应用中存储和读取数据，相当于数据库。\n"
        const val activity_life = "Activity生命周期及跳转"
        const val activity_life_answer = "onCreate:create表示创建\n" + "onStart:start表示启动\n" + "onResume:resume表示继续、重新开始\n" + "onPause:pause表示暂停\n" + "onStop：stop表示停止\n" + "onDestroy：destroy表示销毁\n" + "onRestart：restart表示重新开始\n" + "\n" + "当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume，最后才执行A的onStop!!!\n" + "\n" + "当B按下返回键，B先执行onPause，然后是A再执行onRestart -> onStart -> onResume，最后才是B执行onStop  -> onDestroy\n" + "\n" + "如果B是dialog或透明的，A只会执行onPause，不会执行onStop。当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume。（注意：A的 onStop 不会执行）\n" + "\n" + "当B按下返回键，B先执行onPause，然后是A只会执行 onResume，最后 B 执行onStop  -> onDestroy。\n\n Activity弹出 Dialog 对生命周期\n" + "生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响"
        const val android_configChanges = "activity横纵向切换，或页面发生改变时"
        const val android_configChanges_answer = "程序在运行时，一些设备的配置可能会发生改变，如：横竖屏切换、键盘的可用性等这样的事情发生的时候，activity在没有配置android:configChanges属性时会重新启动\n" + "生命周期：onSaveInstanceState-->onPause-->onStop-->onDestroy-->onCreate-->onStart-->onRestoreInstanceState-->onResume\n" + "\n" + "但如果给configChanges配置了orientation|keyboardHidden|screenSize这些属性后，再发生屏幕改变会调用onConfigurationChanged方法，我们可以通过Configuration里的orientation属性判断是横向还是纵向。\n" +"\n"+"onNewIntent 什么时候调用\n"+"如果此次启动不创建该Activity的新实例,则系统会调用原有实例的onNewIntent()方法来处理此intent"
        const val fragment_life = "fragment生命周期及切换时变化"
        const val fragment_life_answer = "onAttach() 在Fragment 和 Activity 建立关联是调用（Activity 传递到此方法内）\n" + "onCreateView() 当Fragment 创建视图时调用\n" + "onActivityCreated() 在相关联的 Activity 的 onCreate() 方法已返回时调用。\n" + "onStart() ：Fragment对用户可见的时候调用，前提是Activity已经started。\n" + "onResume()：Fragment和用户之前可交互时会调用，前提是Activity已经resumed。\n" + "onPause()：Fragment和用户之前不可交互时会调用。\n" + "onStop()：Fragment不可见时会调用。\n" + "onDestroyView() 当Fragment中的视图被移除时调用\n" + "onDetach() 当Fragment 和 Activity 取消关联时调用。\n" + "\n" + "fragment切换时的生命周期变化\n" + "\n" + "1、使用replace方法,没加回退栈transaction.addToBackStack(null);的Fragment，用replace替换后Fragment都是销毁重新创建的。加了回退栈的，只是销毁视图重新创建视图。这种方法会消耗流量和性能\n" + "FragmentTransaction transaction = fragmentManager.beginTransaction();\n" + "transaction.replace(R.id.layout_fragment, fragment);\n" + "transaction.commit();\n" + "\n" + "2、add  hide  show------onHiddenChange()，使用hide() show()方法切换fragment  不会走任何的生命周期 无法通过生命周期进行刷新，需要监听onHiddenChanged方法，来判断fragment显示与否。add  与 remove，会走正常创建与销毁周期。\n" + "FragmentTransaction transaction = fragmentManager.beginTransaction();\n" + "transaction.hide(currentFrament).add(R.id.layout_content, newFragmeent).commit();"
        const val service_life_stop = "Service生命周期与终止方法"
        const val service_life_stop_answer = "startService   生命周期       \n" + "onCreate()：创建服务  、\n" + "onStartCommand()：服务开始运行、\n" + "onDestroy() ：服务被停止\n" + "\n" + "bindService     生命周期\n" + " onCreate()：创建服务  、\n" + "onBind()：绑定服务，服务开始运行   、\n" + "onUnbind()：取消绑定   、\n" + "onDestroy() ：服务被停止\n" + "\n" + "终止的话使用stopSelf()或stopService(intent)\n" + "\n" + "混合启动如何停止：同时使用 startService 与 bindService Service 的终止，需要unbindService与stopService同时调用，才能终止 Service。不管 startService 与 bindService 的调用顺序\n\n两种启动方式：\n" + "通过StartService启动Service：startService(new Intent(this, NormalService.class));\n" + "通过bingService启动Service:bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);\n" + "\n" + "区别：\n" + "是生命周期不同，startService一旦服务开启跟开启者就没有任何关系，而bindService可以通过unBindService来停掉Service。而且调用者挂了，服务也会跟着挂掉。\n" + "\n" + "activity与service通信：\n" + "一、通过Intent，startService（intent）来启动Service，在intent中放入数据，在Service的onStartCommant()中接收通过intent传过来的值。（性能差）\n" + "二、binder+回调\n" + "在Activity中实现ServiceConnection，在onServiceConnected()中获取Service的实例，通过这个实例就能调用Service的方法和变量了。\n" + "通过回调可以将Service主动将变化通知Activity。\n" + "三、Broadcase方式\n" + "在Service中需要通知更新UI的地方，发送广播，在Activity中注册广播，在BroadcaseRecever中接受广播，更新UI。\n" + "四、EventBus"
        const val activity_launchMode = "Activity启动模式"
        const val activity_launchMode_answer = "Task是指将相关的Activity组合到一起，以Activity Stack的方式进行管理。一个Task是可以有一个或多个Android Application组成的\n" + "\n" + "\n" + "standard 模式:这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。\n" + "\n" + "singleTop 模式:如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的\n" + "\n" + "\n" + "singleTask 模式:如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建\n" + "\n" + "\n" + "singleInstance 模式\n" + "     在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再启动该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。\n" + "设置启动模式的位置在 AndroidManifest.xml 文件中 Activity 元素的 Android:launchMode 属性。singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，按返回会直接从C跳到A"
        const val http_https = "Http与Https的区别"
        const val http_https_answer = "主要有3点不同\n" + "1、安全性：HTTPS不是明文传输的，会通过SSL数据加密、TLS验证身份，以及数据完整性保护（收方或非法者不能伪造、篡改报文，运营商加广告）而HTTP是明文传输无状态的（比较独立，服务器与客户端都不会记录信息），所以安全性要高于HTTP\n" + "2、HTTPS需要申请CA证书，而HTTP不需要\n" + "3、用的端口也不一样，HTTP是80，HTTPS是443"
        const val jvm_model = "JVM模型"
        const val jvm_model_answer = "程序计数器\n" + "一块较小的内存空间，是字节码解释器的行为指示器。程序执行的过程中会有分支、循环、跳转、异常处理、线程恢复等基础功能，也就是程序运行碰到了关键字或特殊行为，字节码解释器就需要进行特殊处理，而字节码需要怎么做正是由程序计数器去通知。程序计数器是线程私有的\n" + "\n" + "虚拟机栈\n" + "Java 方法执行的内存模型，每个方法执行的时候，都会创建一个栈帧用于保存局部变量表，操作数栈，动态链接，方法出口信息等。一个方法调用的过程就是一个栈帧从 VM 栈入栈到出栈的过程。VM 栈主要用于存储方法包含的信息如，基本数据类型、局部变量等，VM 栈也是线程私有的\n" + "\n" + " 本地方法栈\n" + "执行 Native 方法的栈，与 VM 栈发挥的作用非常相似，VM 栈执行Java 方法（字节码）服务，Native 方法栈执行的是 Native 方法服务。Native 栈也是线程私有的\n" + "\n" + "Java 堆 \n" + "所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象都在这分配内存。Java 堆是线程共享的。\n" + "\n" + "方法区 \n" + "存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。这部分区域包含「运行时常量池」，所以这个区域主要存储常量。方法区是线程共享的\n"
        const val jvm_gc_root = "GC root 对象"
        const val jvm_gc_root_answer = "1.虚拟机栈(栈帧中的本地变量表)中引用的对象\n" + "2.方法区中类静态属性引用的对象\n" + "3.方法区中常量引用的对象\n" + "4.本地方法栈中 JNI(一般说的 Native 方法)引用的对象"
        const val volatile_synchronize_use = "volatile特性、与synchronize区别"
        const val volatile_synchronize_use_answer = "Volatile关键字可以修饰变量，用于多线程的访问\n\nvolatile的作用，保证内存可见性和有序性，但不能保证原子性\n\n" + "内存可见性：如果对变量加上volatile关键字修饰的话，它可以保证当有线程对变量值做了变动之后，会立即刷回到主内存中，所有线程都能读到相同的值\n" + "\n" + "有序性：JVM为了保证执行上的效率，可能会对指令进行重排序，而加上volatile关键字修饰后，在指令间插入一个屏障点，就告诉JVM和CPU，不能进行重排优化。其实volatile有序性是通过内存屏障实现的\n" + "\n" + "不保证原子性：有个例子，1000个线程同时去对被volatile修饰过的变量进行+1操作，但值确肯定不是1000，也就是说volatile并不能保证一个线程执行完，另一个线程才开始执行，不能保证操作并不是不可分割的。\n\n区别：\n" + "1、volatile本质上是直接从主内存中读取值，无法保证同步\n" + "2、volatile只能实现变量的修改可见性，并不能保证原子性；而synchronizedl则因为能保证线程安全，可以保证变量的修改可见性和原子性。\n" + "3、volatile只能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。\n" + "4、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。\n\nsynchronized原理\n" + "\n" + "在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。所有锁都是存储在 Java 对象头里的，Java 对象头里的 Mark Word 里默认存储对象的 HashCode，分代年龄和锁标记位。也就是说 Mark Word 记录了锁的状态\n" + "\n" + "Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，\n" + "\n" + "如果是代码块同步是利用 monitorenter 和 monitorexit 这两个字节码指令来实现的。进入后锁的计数器+1，在执行monitorexit指令时会将锁的计数器减1，当减为0的时候就释放锁。同步方法的字节码指令中没有monitorenter和monitorexit指令，是通过方法修饰符上的ACC_SYNCHRONIZED标识符来实现方法的同步。原理类似。"
        const val handler_four_components_use = "Handler四大组件及使用"
        const val handler_four_components_use_answer = "Message\n" + "Message是在线程之间传递的消息，它可以在内部携带信息，用于在不同线程之间交换数据。\n" + "\n" + "Handler\n" + "处理者，它主要用来发送和处理消息。发送消息一般是使用Handler的sendMessage()方法，消息经过处理后，最终传递到Handler的handlerMessage()方法中。\n" + "\n" + "MessageQueue\n" + "消息队列，它主要用来存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理。每个线程只有一个Messgequeue\n" + "\n" + "Looper\n" + "是每个线程中MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，每当发现MessageQueue中存在一条消息，就会将其取出传递到Handler的handleMessage()方法当中。注意：每个线程中只会有一个Looper对象。\n\nHandler异步消息处理流程：\n" + "首先在UI线程我们创建了一个Handler实例对象，重写handleMessage方法，我们可以通过这个方法的参数msg来实现接受消息过后Ui线程的逻辑处理。在子线程中需要更新UI的时候，可以通过obtain获取一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理。Looper会不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法 \n\n 子线程中创建Handler的方法：需要调用Looper.prepare()创建一个looper,并调用looper.loop来启动循环\n\n一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？\n" + "\n" + "一个Thread只能有一个Looper，一个MessageQueen，可以有多个Handler。\n" + "以一个线程为基准，他们的数量级关系是：Thread(1) : Looper(1) : MessageQueue(1) : Handler(N)。\n"
        const val solve_anr = "ANR是什么？怎样避免和解决ANR"
        const val solve_anr_answer = "1、5秒主要类型按键或触摸事件在特定时间内无响应 \n" + "2、10秒广播在特定的时间内无法处理 \n" + "3、20秒小概率类型Service在特定的时间内无法处理完成\n" + "\n" + "避免ANR最核心的一点就是在主线程减少耗时操作。\n" + "\n" + " a）使用子线程处理耗时IO操作 \n" + " b）降低子线程优先级，使用Thread或者HandlerThread时，调用Process.setThreadPriority（Process.THREAD_PRIORITY_BACKGROUND）设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同 \n" + " c）使用Handler处理子线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程\n" + " d）Activity的onCreate和onResume回调中尽量避免耗时的代码\n" + " e）BroadcastReceiver中onReceiver代码也要尽量减少耗时操作，建议使用intentService处理。intentService是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题\n"
        const val touch_event = "事件分发流程"
        const val touch_event_answer = "Android的UI界面由Activity、ViewGroup、View 及其派生类组成，1个点击事件发生后，如果我们没有对控件里面的方法进行重写或更改返回值，而直接用super调用父类的默认实现，该事件会先传到Activity、再传到ViewGroup、最终再传到 View，再从最底层开始往上传，那这个传递模型就类似于一个U型。\n" + "\n" + "\n" + "其中共涉及3个方法，分发方法dispachTouchEvent、拦截onIntercepteorTouchEvent、处理onTouchEvent。其中分发和处理是三层都有的，拦截方法是ViewGrop独有的。\n" + "\n" + "\n" + "分发方法 和 处理方法 一旦return true,事件就停止传递了，直接消费掉，而返回 false的时候事件都回传给父控件的onTouchEvent处理。\n" + "而拦截方法返回true会给到本层的onTouchEvent处理,false和默认方法都不拦截，会向下走。\n" + "\n" + "ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。\n\n" + "\n" + "在ViewGroup源码中使用了一个全局变量mFirstTouchTarget来记录是否有View处理了Down事件。mFirstTouchTarget默认为null，如果发现了View可以处理，那么就会把mFirstTouchTarget的值设置为对应的View。那么随之而来的Down和Up都会交给该View处理，（mFirstTouchTarget为单链表结构）\n\ngetX()是表示Widget相对于自身左上角的x坐标。\n" + "getRawX()是表示相对于屏幕左上角的x坐标值，这个屏幕左上角是手机屏幕左上角,不管activity是否有titleBar或是否全屏幕 \n\n滑动冲突解决方案：\n" + "1、可以考虑从父布局的拦截方法onInterceptTouchEvent来处理，如果需要拦截返回true.\n" + "2、如果不修复父布局，可以当前view.getParent().requestDisallowInterceptTouchEvent(true/false);如果传true表示父布局不做处理"
        const val memory_leak = "内存泄漏原因及如何解决"
        const val memory_leak_answer = "一、 非静态内部类会隐式地持有外部类的引用，比较典型的就是Handler，消息会持有Handler对象，Handler对象又隐式地持有了Activity对象，当发生GC是以为message - handler - activity 的引用链导致Activity无法被回收，所以发生了内存泄漏的问题\n" + "解决：把Handler使用完后，调用了removeCallbackMessage清空了它的队列。或将Handler声明为静态内部类，就不会持有外部类的引用，其生命周期就和外部类无关， 如果Handler里面需要context的话，可以通过弱引用方式引用外部类 \n" + "\n" + "二、单例模式引起的内存泄漏。 解决：Context是ApplicationContext，由于ApplicationContext的生命周期是和app一致的，不会导致内存泄漏 \n" + "\n" + "三、注册广播接受器、EventBus等，记得解绑。 \n" + "\n" + "四、资源对象没有关闭引起的内存泄漏。 在这些资源不使用的时候，记得关闭，像字节流FileOutputStream调用close（）、多媒体MediaPlayer调用release（）等方法释放等。 \n" + "\n" + "五、集合对象没有及时清理引起的内存泄漏。 通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用。\n\n\n"
        const val animations = "Android动画"
        const val animations_answer = "逐帧动画(Frame Animation) 加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间\n\n" + "补间动画(Tween Animation)也叫视图动画 Tween可以对View对象实现一系列动画效果，比如平移，缩放，旋转，透明度等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。\n\n" + "属性动画(Property Animation) 动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了\n\n\n属性动画\n\nValueAnimator是整个属性动画机制当中最核心的一个类，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。\n" + "\n" + "但如果只是些常规动画，还是使用ObjectAnimator多一些，它会把我们常用的位移、旋转、缩放、透明等效果都做为属性参数直接调用。还可以通过addListener，添加个动画的adapter，来监听它的执行状态。还可以通过setInerpolator来配置插值器，实现些加速或掉落回弹等效果。（通过时间百分比来实现非线性需求）"
        const val hash_map="hashmap工作原理"
        const val hash_map_answer="Hashmap\n" + "HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry<K,V>接口）实现，HashMap 通过 put & get 方法存储和获取。\n" + "\n" + "存储对象时，将 K/V 键值传给 put() 方法：\n" + "①、调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；②、调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；\n" + "③、i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；\n" + "ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；\n" + "iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。\n" + "\n" + "如何计算hash值\n" + "采用高位16位组成的数字与源哈希值取异或而生成的哈希值作为用来计算的\n" + "\n" + "为什么要用异或？减少碰撞。可以将高低位二进制特征混合起来\n" + "\n" + "异或：两个值相同结果为0，不同结果为1\n" + "\n" + "HashMap的默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。\n" + "\n" + "hash 函数，即散列函数，或叫哈希函数。它可以将不定长的输入，通过散列算法转换成一个定长的输出，这个输出就是散列值。需要注意的是，不同的输入通过散列函数，也可能会得到同一个散列值。因此我们不能使用散列函数来获取唯一值。\n"
        const val aidl = "aidl"
        const val aidl_answer = "AIDL是进程间通讯的一种方式，一般会与Service、Binder共同完成交互通信。\n" + "\n" + "首先服务端需要先创建AIDL接口文件，定义自己所需要的方法，配置好后build项目，生成aidl JAVA文件，里面会自动生成一个静态的抽像类Stub，继承了Binder，而且还实现了自己所定制aidl接口\n" + "\n" + "然后客户端需要先配置一个与服务端相同的aidl-java文件，并与服务端通过BindService的方式启动一个远程服务，服务端在onBind方法中，传给客户端一个stub代理对象，客户端在ServiceCnection的回调中得到了这个stub代理对象，就可以通过stub里定义好的接口进行通信了。\n" + "\n" + "客户端向服务端：直接用ServiceCnected里返回的bind调用就可以了。\n" + "服务端向客户端：通过接口回调，在客户端ServiceCnected里注册个callback，然后进行通信。"
        const val thread_pool = "线程池相关"
        const val thread_pool_answer = "程序刚启动的时候，会用到线程池，主要是用他批处理任务，也可以顺序执行任务\n\n\n创建线程池的方式一般有两种：\n" + "* 通过Executors工厂方法创建\n" + "* 通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)自定义创建\n" + "\n" + "一、通过Executors工厂方法创建\n" + "Executors.newSingleThreadExecutor()：单线程的线程池，只有一个线程在工作，任务按顺利执行\n" + "Executors.newFixedThreadPool(3)：构建固定线程数的线程池，默认情况下，空闲线程不会被回收\n" + "Executors.newCachedThreadPool():创建一个会根据需要创建新线程的线程池，线程数随着任务量而变动，空闲线程超过60秒将被回收\n" + "Executors.newScheduledThreadPool(空或int):创建定时线程任务的线程池，可以通过传参设置固定数量，它的实例可以调用scheduleAtFixRate(runnable,第一次执行延迟时间，每隔多久执行，时间单位)来周期性执行任务。\n" + "\n" + "二、通过ThreadPoolExecutor构造函数创建：这个就主要是对构造函数的参数要有一定了解，ThreadPoolExecutor 线程池构造函数的七个参数\n" + "\n" + "1、corePoolSize 线程池核心线程大小\n" + "2、maximumPoolSize 线程池最大线程数量\n" + "3、keepAliveTime 空闲线程存活时间\n" + "4、unit 空闲线程存活时间单位\n" + "5、workQueue 工作队列，JDK提供了四种\n" + "6、threadFactory 线程工厂\n" + "7、handler 拒绝策略，JDK提供了四种\n" + "\n" + "线程池任务提交过程,核心流程其实就是走的ThreadPoolExcutor类中的execute(runnable)方法\n" + "\n" + "a. 首先判断核心线程池中的线程是否已经满了，如果没满，则创建一个核心线程执行任务，否则进入下一步\n" + "b. 判断工作队列是否已满，没有满则加入工作队列，否则执行下一步\n" + "c. 判断线程数是否达到了最大值，如果不是，则创建非核心线程执行任务，否则执行饱和策略，默认抛出异常\n" + "\n" + "\n" + "如何关闭线程池\n" + "\n" + "1. shutdown() 不接收新任务,会处理已添加任务\n" + "2. shutdownNow() 不接受新任务,不处理已添加任务,中断正在处理的任务\n" + "\n" + "\n" + "wordQueue\n" + "\n" + "SynchronousQueue:无缓冲等待队列.从队列中取和放都是阻塞方法,如果队列满了再往里放,会进入阻塞.如果队列中没有任务在往出取也会进入阻塞.类似于生产者与消费者模式那种的.这个队列只能装一个任务.\n" + "LinkedBlockingQueue:无界缓存队列. 长度是Integer.MAX_VALUE,当执行的线程数量等于核心线程数量的时候,剩余的任务会在阻塞队列中等待.所以在使用这个队列的时候,最大线程数的参数相当于无效了.\n" + "ArrayBlockingQueue:有界缓存队列可以定义队列的长度.\n" + "PriorityBlockingQueue（具有优先级的无界阻塞队列，优先级通过参数Comparator实现）\n" + "\n" + "注意\n" + "1. 当workQueue使用的是无界限队列时，maximumPoolSize参数就变的无意义了，比如new LinkedBlockingQueue(),或者new ArrayBlockingQueue(Integer.MAX_VALUE);\n" + "2. 使用SynchronousQueue队列时由于该队列没有容量的特性，所以不会对任务进行排队，如果线程池中没有空闲线程，会立即创建一个新线程来接收这个任务。maximumPoolSize要设置大一点。\n" + "3. 核心线程和最大线程数量相等时keepAliveTime无作用.\n" + "\n" + "\n" + "拒绝策略\n" + "\n" + "CallerRunsPolicy：不抛弃线程 调用线程池的线程帮助执行，如果线程池已经shutdown，则直接抛弃任务。\n" + "AbortPolicy：该策略下，直接丢弃任务，并抛出RejectedExecutionException异常\n" + "DiscardPolicy：该策略下，直接丢弃任务，什么都不做。\n" + "DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\n\n非核心线程是如何回收的:工作线程启动后，会进入一个runWorker的方法里。里面是一个while循环，循环判断任务是否为空，若不为空，执行任务；若取不到任务，或发生异常，退出循环，执行processWorkerExit(w, completedAbruptly); 在这个方法里把工作线程移除掉。"
        const val leak_canary="LeakCanary原理"
        const val leak_canary_answer="Leakcanary在初始化时会返回一个refWatcher监听器，他会注册一个callback来监听Activity的onDestroy方法。activity在执行onDestroy后需要被回收，监听机制将Activity包装到WeakReference中，被WeakReference包装过的Activity对象如果被回收，该WeakReference引用会被放到ReferenceQueue中。如果过5秒没有回收，监听机制会手动触发次GC，如果还没有被回收，那就说明Activity可能已经泄露。  这个时候就可以抓取内存dump文件来分析展示了。"
        const val java_reference = "java引用类型"
        const val java_reference_answer = "按引用强度排序\n" + "强引用：当我们使用new创建对象时，被创建的对象就是强引用，如Object object = new Object()，其中的object就是一个强引用了。如果一个对象具有强引用，JVM就不会去GC它，JVM宁可会报OOM来终止程序，也不回收该对象。 \n" + "软引用: 如果一个对象只具备软引用，如果内存空间足够，那么JVM就不会GC它，如果内存空间不足了，就会GC该对象。 \n" + "弱引用: 如果一个对象只具有弱引用，只要JVM的GC线程检测到了，就会立即回收。弱引用的生命周期要比软引用短很多。不过，如果垃圾回收器是一个优先级很低的线程，也不一定会很快就会释放掉软引用的内存。 \n" + "虚引用：如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行GC。\n" + "\n" + "当软引用对象被GC之后，虽然这个SoftReference对象指向的对象已不存在,但这个SoftReference对象本身还占用内存，如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法。ReferenceQueue的poll()方法来检查是否有它所关心的非强引用对象被回收。\n" + "\n" + "软引用一般用于图片缓存，场景，图片编辑bitmap，用法类似于SoftReference<String> sr = new SoftReference<String>(new String(\"hello\"));      System.out.println(sr.get());\n" + "WeakReference<Car> weakCar = new WeakReference<Car>(car);      if(weakCar.get()!=null)，虚引用可以解决一些内存泄漏的问题，如Handler之类的。"
        const val synchronize_lock = "synchronized和Lock的区别,原理，适用场景"
        const val synchronize_lock_answer = "区别：\n" + "1、定义和使用：synchronized是java的关键字，可以作用于类、函数、对象，但lock是接口，需要线程去持有使用实现lock的对象来使用。\n" + "2、操作性：synchronized加锁和解锁都是自动进行的，易于操作，但lock（或实现接口的reentrantlock）都需要手动上锁解锁，最好还要配合try-finaly来使用，防止死锁\n" + "3、灵活性：最重要的，synchronized的是不可终断锁，等待锁过程是固定的，等不到就会一直等，但lock可以trylock尝试上锁，而且能够拿到锁定与否的状态(boolean=lock.trylock())，会有更多的选择，可以提高多个线程进行读操作的效率。\n" + "4、性能：如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized\n" + "\n" + "适用场景：少量线程同步适合用synchronized，大量线程适合用lock"
        const val thread_about = "线程启动、关闭、安全等"
        const val thread_about_answer = "创建线程有两种方式\n" + "\n" + "一、继承 Thread 类，扩展线程。\n" + "二、实现 Runnable 接口。\n" + "\n" + "\n" + "暂停线程的方法\n" + "\n" + "1、使用blooean标志位终止线程，让线程自己完成运行，要用volatile声明。\n" + "2、使用Interrupte方法标记停止，然后while循环和isInterrupted判断是否被中断，并添加中断逻辑。\n" + "3、是已经过时的stop方法。不推荐STOP的原因：线程被杀掉，马上被别的线程上锁，数据写还一半就被别的线程上锁，连清理的机会都没有，拿到异常数据，一定会出问题。\n" + "\n" + "\n" + "线程安全\n" + "\n" + "线程安全问题主要围绕三个特性\n" + "1是原子性，也可以理解成相关操作不会被中途被其他线程干扰，可以通过synchronized或使用lock来保证线程同步，还可以使用ThreadLocal来维护变量，也可以阻隔其他线程的干扰\n" + "2是保证内存可见性，一个线程修改了某个共享变量，其状态能立即被其他线程知晓，vollatile就可以保证可见性\n" + "3是有序性，也就是保证线程要执行的指令，不会被JVM或CUP优化重新排序，Volatile也能保证这一点。\n" + "\n" + "除此之外，像synchronized和lock的适用场景也要区分好，wait/notify方法的使用时机等也要注意\n" + "\n"+"线程有哪些状态：New、Runnable、Running、Blocked、Dead。\n" + "\n"
        const val thread_local="ThreadLocal原理"
        const val thread_local_answer = "ThreadLocal是一个关于创建线程局部变量的类。使用场景如下所示：\n" + "\n" + "* 有助于线程安全，因为每个线程都会有一个对应的实例。承载一些线程相关的数据，避免在方法中来回传递参数。\u2028\n" + "* 实现单个线程单例以及单个线程上下文信息存储，比如交易id等。\n" + "\n" + "\n" + "什么是ThreadLocal\n" + "\n" + "ThreadLocal 是 Thread 的共享变量。有助于线程安全，因为每个线程都会有一个对应的实例。承载一些线程相关的数据，避免在方法中来回传递参数，或加synchronized上锁那么麻烦。\n" + "\n" + "\n" + "ThreadLocal的原理\n" + "\n" + "ThreadLocal中有一个ThreadLocalMap中有一个table数组，元素是Entry。根据ThreadLocal(需要转换获取到Hash Key)能get到对应的Enrty。\u2028 Entry中key为ThreadLocal, value就是存储的数值。\n"
        const val sleep_wait = "sleep、wait、notify、notifyAll区别"
        const val sleep_wait_answer = "sleep、wait最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。\n" + "\n" + "1. sleep是Thread类的静态方法,wait是Object类中定义的方法\n" + "2. Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁,而wait 会释放当前线程锁\n" + "3. Thread.sleep需要设定休眠时间.Object.wait也可以设定wait时间,或者通过线程执行notify/notifyAll进行唤醒\n\nnotify与notifyAll\n\n1. notify唤醒一个线程,如果有多线程在wait,可能是随机一个\n" + "\n" + "2. notifyAll唤醒所有在等待的线程,\n" + "\n" + "3. 使用中尽量使用notifyAll,因为notify容易导致线程死锁(nofity只唤醒一个,其他等待的线程没有唤醒)"
        const val version_features = "android版本特性"
        const val version_features_answer = "6.0增加运行时权限\n" + "7.0分屏多任务、夜间模式\n" + "8.0画中画android:supportsPictureInPicture=ture，调用接口、指纹手势\n" + "9.0“刘海”屏幕支持，可以通过windowInsets.getDisplayCutout()、增加ImageDecoder替换BitmapFactory，代码更优雅\n" + "\n" + "//裁剪图像\n" + "imageDecoder.setCrop();\n" + "//调整大小\n" + " imageDecoder.setResize();\n" + "\n" + "10支持可折叠设备、5G 网络\n"
        const val handler_thread = "HandlerThread"
        const val handler_thread_answer = "HandlerThread继承自Thread，因此HandlerThread其实就是一个线程。他和优点就是，HandlerThread的run方法里就调用了Looper.preper()，和looper.loop()方法，为我们创建好了消息Looper.可以直接拿来用。使用场景就是，在子线程中执行耗时的、可能有多个任务的操作。比如说多个网络请求操作，或者多文件 I/O 等等。使用 HandlerThread 的典型例子就是 IntentService\n" + "\n" + "\n" + "HandlerThread handlerThread = new HandlerThread(\"handlerThread\");\n" + "handlerThread.start(); \n" + "\n" + "创建Handler\n" + "Handler mCheckMsgHandler = new Handler(mHandlerThread.getLooper()){\n" + "     @Override\n" + "     public void handleMessage(Message msg){\n" + "         // 进行耗时操作\n" + "     }\n" + "};"
        const val invalidate = "postInvalidate和Invalidate的区别"
        const val invalidate_answer = "一般来说，如果View确定自身不再适合当前区域，比如说它的LayoutParams发生了改变，需要父布局对其进行重新测量、布局、绘制这三个流程，往往使用requestLayout。而invalidate则是刷新当前View，使当前View进行重绘，不会进行测量、布局流程，因此如果View只需要重绘而不需要测量，布局的时候，使用invalidate方法往往比requestLayout方法更高效\n" + "\n" + "postInvalidate\n" + "这个方法与invalidate方法的作用是一样的，都是使View树重绘，但两者的使用条件不同，postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。"
        const val app_start = "APP启动过程及优化"
        const val app_start_answer = "启动过程：\n" + "1、Launcher响应用户点击，通知AMS，需要启动一个应用\n" + "2、AMS响应Launcher进程请求，新建一个Task去准备启动Activity，并通知Launcher要进入Paused状态\n" + "3、Launcher收到通知会挂起，并通知AMS，已就绪\n" + "4、AMS通过Socket去和Zygote通信，由Zygote.fock创建新的进程，并导入ActivityThread类\n" + "5、进程创建好了，会执行 ActivityThread 类的 main 方法，这是应用程序的入口。Application的创建也是在这个main()方法中（反射），\n" + "6、因为四大组建的启动都需要AMS去启动，还需要将上述的应用进程信息注册到AMS中，AMS 保存应用进程的一个代理对象，然后 AMS通过代理对象通知应用进程创建入口 Activity 的实例，并执行它的生命周期函数\n" + "\n" + "ActivityManagerService：（AMS）AMS是Android中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。\n" + "\n" + "ActivityThread：应用的入口类，通过调用main方法，开启消息循环队列。ActivityThread所在的线程被称为主线程；\n" + "\n" + "ApplicationThread：ApplicationThread提供Binder通讯接口，AMS则通过代理调用此App进程的本地方法\n" + "\n" + "Application：通过反射的方式创建了一个Application对象，并且调用了Appliction的attach()方法，而attach方法又调用了attachBaseContext方法，现在应该明白为什么该方法在Application的onCreate之前调用了。\n" + "\n" + "\n" + "计算启动时间\n" + "\n" + "1、本地调试的话，直接一个命令就可以了，adb shell am start -W com.example.kotlin/com.example.kotlin.activity.MainActivity，其中有个TotalTime 表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，本地用这个就可以了。\n" + "\n" + "2、统计线上应用的话，就需要打点了，起始时间点比较容易记录：\n" + "\n" + "\t冷启动的话在Application.attachBaseContext() 开始的位置记录就可以，因为在这之前 Context 还没有初始化， App 的具体业务逻辑还没开始执行。\n" + "\n" + "\t热启动启动时间点可以在 Activity.onRestart() 中记录起始时间点。\n" + "\n" + "2.结束时间点可以在 Activity.onWindowFocusChanged 记录应用启动的结束时间点，从onWindowFocusChanged被执行起，用户可以与应用进行交互了，真正的visible时间点。如果后面有焦点变化，也会调这个方法，需要区分好。\n" + "\n" + "\n" + "冷启动优化：\n" + "在application中配置一个theme，在style中定义广告页或默认图，让用户先看默认图。在Application和activity的onCreat方法中，1.耗时操作子线程中进行。2.非必要初始化懒加载。3.还有布局层次也要减少\n" + "\n" + "\n" + "方法调用顺序：\n" + "\n" + "-> Application 构造函数\n" + "\n" + "-> Application.attachBaseContext()\n" + "\n" + "-> Application.onCreate()\n" + "\n" + "-> Activity 构造函数\n" + "\n" + "-> Activity.setTheme()\n" + "\n" + "-> Activity.onCreate()\n" + "\n" + "-> Activity.onStart\n" + "\n" + "-> Activity.onResume\n" + "\n" + "-> Activity.onAttachedToWindow\n" + "\n" + "-> Activity.onWindowFocusChanged"
        const val assets_res = "Assets目录与res目录的区别"
        const val assets_res_answer = "res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即可，assets文件夹下的文件不会被映射到R文件中，访问的时候需要AssetManager类。\n" + "\n" + "res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹。"
        const val intent_service = "介绍下IntentService"
        const val intent_service_answer = "IntentService其本质上是一个Service，因为它是继承至Service，所以开启IntentService和普通的Service一致。但是他和普通的Service不同之处在于它可以处理异步任务，在任务处理完之后会自动结束。另外，我们可以启动多次IntentService，而每一个耗时任务会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且是串行执行。其实IntentService的内部是通过HandleThread和Handle来实现异步操作的。"
        const val mvp = "介绍下MVP"
        const val mvp_answer = "MVP模式分离了视图逻辑和业务逻辑，Activity只是用来相应生命周期，其他工作都丢到Presenter中完成，Presenter是Model和View之间的桥梁，为了让结构变得更加简单，View并不能直接对Model进行操作，这也是MVP与MVC最大的不同之处。"
        const val final_finally_finalize = "Java 中的 final, finally 和 finalize?"
        const val final_finally_finalize_answer = "\n" + "final：对基本类型而言，你不能改变其数值，对于引用，你不能将其指向一个新的引用，即用final关键字修饰方法，它表示该方法不能被覆盖，用final修饰的类是无法被继承的\n" + "finally：是异常处理中进行收场处理的代码块，比如关闭一个数据库连接，清理一些资源占用的问题。不管有没有异常被捕获，finally子句中的代码都会被执行。\n" + "finalize：finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，定位bug"
        const val equals_deng = " == 和 equals() 有什么区别？"
        const val equals_deng_answer = " ==用法\n" + "    1. 判断基本类型变量是否相等，且都是数值类型（不一定要求数据类型严格相同），只要两个变量的值相等，就返回true\n" + "    2. 对于两个引用类型变量，只有当他们指向同一个对象时，判断才会返回true。且不能用于比较类型上没有父子关系的两个变量\n" + "\n" + "equals用法\u2028\n" + "    equals（）是Object类提供的一个示例方法，因此所有的引用类型变量都能用它来判断是否和其他的引用类型变量相等。\n" + "    1. Object类的equals（）和==运算符几乎一样，也是要求两个引用类型变量指向同一个对象时才会返回true;\n" + "    2. string类的equals（）已经进行了重写，所以str1.euqals(str2)比较的是str1和str2的内容，而不是比较引用类型变量指向的对象\u2028此外：\n" + "\n" + "默认equals在比较两个对象时，是看他们是否指向同一个地址的。\n" + "但有时，我们希望两个对象只要是某些属性相同就认为他们的quals为true。"
        const val overloading_overriding = "重载和重写的区别"
        const val overloading_overriding_answer = "重载：方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。\n" + "\n" + "重写：是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。如果父类的方法有异常声明，那么子类重写这个方法时候，所要声明的异常不应该比父类的大。只能是小等，或者可以没有\n" + "\n" + "可否重写父类的静态方法\n" + "\n" + "静态方法，是在运行时，虚拟机已经认定此方法属于哪个类。 静态方法的调用不需要实例化， \"重写\"只能适用于实例方法.不能用于静态方法.对于静态方法,只能隐藏... "
        const val polymorphism_extends = "什么是多态？什么是继承？"
        const val polymorphism_extends_answer = "多态是：多态是同一个行为具有多个不同表现形式或形态的能力。代码上表现就是同一个接口，使用不同的实例而执行不同操作。多态存在的三个必要条件：继承、重写、父类引用指向子类对象：Parent p = new Child();\n" + "\n" + "继承是：子类继承父类的特征和行为，使得子类具有父类的各种属性和方法。\n"
        const val generic_reflection = "介绍下 泛型、反射"
        const val generic_reflection_answer = "泛型：\n" + "在集合中存储对象并在使用前进行类型转换是很不方便的，并且容易出错，为了防止这种情况，泛型产生。泛型提供了编译期的类型安全，确保我们只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException（类型转换异常）\n" + "\n" + "反射：就是动态加载一个指定的类，并获取该类中的所有的内容，比如有些第三方的JAR文件中的资源，我们没法直接调用，就可以用反射这种比较原始的方法来调用。\n" + "\n" + "1、获得Class对象，就是获取到指定的名称的字节码文件对象。\n" + "Class c = Class.forName(className);\n" + "\n" + "2、实例化对象，获得类的属性、方法或构造函数。\n" + "\u2028Field[] fields = c.getDeclaredFields();\u2028\u2028for (int i = 0; i < fields.length; i++) {\n" + "\n" + "// 打印属性的 修饰符 类型 名称\n" + "System.out.println(Modifier.toString(fields[i].getModifiers()) + \" \" + fields[i].getGenericType() + \" \"+ fields[i].getName());}\n" + "\n" + "\n" + "\n" + "3、访问属性、调用方法、调用构造函数创建对象。"
        const val join_about = "如何让线程按顺序执行"
        const val join_about_answer = "可以用线程类的join()方法，join()方法的作用，是等待这个线程结束；在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕.\n" + "\n" + "newSingleThreadExecutor()方法创建的线程池是一个基于FIFO先进先出的队列，也就是说，当我们依次将thread1，thread2，thread3加入队列中时，实际在就绪状态的只有thread1这个线程，thread2，thread3则会被添加到队列中等待，当thread1执行完毕后，则会按进入队列的先后顺序执行队列中的其他线程。"
        const val deadlock_about = "什么是死锁？死锁的四个条件，如何避免死锁"
        const val deadlock_about_answer = "死锁：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程都处于阻塞状态，无法继续。\n" + "\n" + "\n" + "四个条件\n" + "1、互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。\n" + "\n" + "2、请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n" + "\n" + "3、不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。\n" + "\n" + "4、循环等待条件:若干进程间形成首尾相接循环等待资源的关系\n" + "\n" + "\n" + "如何避免\n" + "在设计阶段就应该考虑如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。比较常用的方法：\n" + "\n" + "1、避免多次锁定。尽量避免同一个线程对多个 Lock 进行锁定。\n" + "\n" + "2、具有相同的加锁顺序。如果多个线程需要对多个 Lock 进行锁定，则应该保证它们以相同的顺序请求加锁\n" + "\n" + "3、使用定时锁。程序在调用 acquire() 方法加锁时可指定 timeout 参数，该参数指定超过 timeout 秒后会自动释放对 Lock 的锁定，这样就可以解开死锁了\n" + "\n" + "4、用算法来做死锁检测。这个了解一些，服务端可能会用到，客户端用的不多。"
        const val sum_link = "数组和链表的区别"
        const val sum_link_answer = "数组：是将元素在内存中连续存储的；它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效率比较高；它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低。\n" + "\n" + "链表：是动态申请内存空间，不需要像数组需要提前申请好内存的大小，链表只需在用的时候申请就可以，根据需要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）"
        const val array_link = "ArrayList和LinkedList的区别，以及应用场景"
        const val array_link_answer = "Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中后面的所有数据。最差情况是ON\n" + "\n" + "linkedList是基于双链表的，他的特点就是插入和删除非常快，只需要改变相邻节点的指针就可以了，但他如果用来查询就很慢了，最差情况是ON，因为他需要一个一个去找。\n" + "\n" + "除此之外像ArrayList是数组结构，所以他的起始容量是10，当数组需要增长时，就会新增一个为原来1.5倍容量的新数组，然后把原数组的数据原封不动的复制到新数组中，再把新数组赋值给原来的数组对象就完成了。所以会有空间浪费的情况\n" + "\n" + "一般情况下，LinkedList的占用空间更大，因为每个节点要维护指向前后地址的两个节点，但也不是绝对，如果刚好数据量超过ArrayList默认的临时值时，ArrayList占用的空间也是不小的，因为扩容的原因会浪费将近原来数组一半的容量\n"
        const val string_string_buffer = "介绍下String，为什么要设计成不可变的？以及StringBuffer、StringBuilder"
        const val string_string_buffer_answer = "String并不是基础类型，是final修饰的java类，之所以被设计成不可变主要是为了保证数据不被污据，方法区中的字符串池，当一个字符串已经被创建并且该字符串在池中，该字符串的引用会立即返回给变量，而不是重新创建一个字符串再将引用返回给变量。如果字符串不是不可变的，那么改变一个引用（如:string2）的字符串将会导致另一个引用（如:string1）出现脏数据。\n" + "\n" + "string不是基本数据类型，那么一个string的内存位置是什么呢？一共有两种情况：\n" + "　　1、string直接赋值：\n" + "　　　　String s = \"haha\";\n" + "　　　　s的引用存在栈内存中，引用指向的haha存在方法区的常量池中（先判断常量池中是否有一个haha，存在则直接指向）\n" + "　　2、string对象new创建\n" + "　　　　String s = new String(\"haha\");\n" + "　　　　s的引用存在于栈内存中，引用指向的haha对象，存在堆内存中（每new一次，在堆中创建一个新的haha对象）\n" + "\n" + "和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象\n" + "\n" + "StringBuffer是线程安全的，可以在多线程操作字符串\n" + "StringBuilder是非线程安全的，性能会比StringBuffer好些"
        const val thread_application = "进程和线程的区别"
        const val thread_application_answer = "首先是定义：进程是执行中的一段程序，一个应用至少有一个进程，而线程是用来执行任务的。他们之间是包含关系，一个进程中能有一个或多个线程。\n" + "\n" + "二是进程可以拥有系统分配的资源，但线程只涉及运行栈和程序计数器。\n" + "\n" + "还有就是开销上，线程要比进程小很多，主要就是这三点。\n" + "\n" + "（每当有线程被创建的时候，JVM就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。）\n"
        const val hash_map_hashtable = "HashMap与HashTable的区别"
        const val hash_map_hashtable_answer = " Hashtable 数据结构是table数组，用元素Entry来保存数据，基中的方法是Synchronize的，而HashMap是不加锁的，在多线程并发的环境下，可以直接使用Hashtable，但使用HashMap时就必须要自己增加同步处理\n" + "\n" + " Hashtable中，key和value都不允许出现null值。HashMap中key和value都可以为null\n" + "\n" + "HashMap 要比 HashTable 效率高，现在用hashtable比较少。\n\n\n jdk8以前：使用链地址法(拉链法)\n" + "从 jdk8开始，使用的是链表与红黑数转换\n" + "HashMap:\n" + "1、如果冲突数量小于等于8，则是以链表方式解决冲突。\n" + "2、而当冲突大于8时且数组size>64，就会将冲突的Entry转换为红黑树进行存储。 3.而又当数量小于6时，则又转化为链表存储。\n" + "\n" + " 而在Hashtable中， 都是以链表方式存储。 遍历方法也不一样 HashMap：iterator Hashtable：enumeration "
        const val clean_apk = "APK体积优化"
        const val clean_apk_answer = "1、使用Lint工具查找没有使用到的资源\n" + "\n" + "2、对图片进行过滤，能用.9就用.9，不能用的可以把图片进行压缩，像tinypng就挺好用的，如果可以就使用一套图就行，我一般用xxhdpi的\n" + "\n" + "3、对lib库进行精简，只保留有用的库\n" + "\n" + "4、使用proguard混淆代码"
        const val interrupt_interrupted = "interrupt(),interrupted() 和 isinterrupted() 的区别"
        const val interrupt_interrupted_answer = "interrupt方法主要作用是将线程的中断状态设置为true，如果遇到被阻塞的线程会抛出InterruptedException异常（同时中断状态为false）。\n" + "\n" + "interrupted()用来清除当前线程的中断状态，还会返回当前线程的状态，如果线程已中断，则返回true，否则返回false。而且会清除当前Thread的中断状态，置为false。\n" + "\n" + "isInterrupted是用来获取调用线程的中断状态的，但不会重置中断状态\n" + "\n" + "一般interrupt会和isInterrupted，配合while循环、try、catch一起来使用\n"
        const val thread_status = "线程有几种状态"
        const val thread_status_answer = "在 Thread 类里有一个枚举类型 State，定义了线程的几种状态，分别有：\n" + "\n" + "New: new 一个实例出来，线程就进入了初始状态。\n" + "\n" + "Runnable: 就绪状态，像调用start() 、sleep（）结束、他线程 join() 结束都会进入runnable。线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态\n" + "\n" + "Blocked： 没有获取到锁被阻塞的状态\n" + "\n" + "WAITING： 处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n" + "\n" + "TIMED_WAITING： 处于这种状态的线程不会被分配 CPU 执行时间，在达到一定时间后它们会自动唤醒。\n" + "\n" + "TERMINATED： 当线程的 run() 方法完成时，或者主线程的 main() 方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。"
        const val binder_info = "介绍下Binder机制"
        const val binder_info_answer = "有些铺垫信息，我先讲下，我们开发的应用程序所运行的空间可以叫用户空间，Linux 内核的运行空间叫内核空间，为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。\n" + "\n" + "应用程序如果想访问内核空间，需要通过系统调用，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定\n" + "\n" + "如果一个用户空间想与另外一个用户空间通信，Android系统可以通过添加一个内核模块运行在内核空间，也就是（Loadable Kernel Module，LKM），用户进程之间的通过这个模块作为桥梁，就可以完成通信了。这个内核模块叫做 Binder 驱动;\n" + "\n" + "还有个ServerManager需要讲下，他是个进程，它里面维护了一张表，表里面存储的是向他注册过的进程信息。也可以简单的理解成像一个电话本，我们要和别人打电话时，一定要有电话号码。所以，服务端需要先在ServerManager中去注册信息。\n" + "\n" + "客户端进程就会通过Binder驱动向ServerManger查询服务端进程的信息，ServerManage就会将服务端进程的信息返回给客户端进程，客户端与服务端进程之间就可以通过这些信息，利用Binder驱动来进行通信了；\n" + "\n" + "所以，总结来说，Binder通信机制分三步：\n" + "第一步：ServerManager在其内部维护一张表；\u2028\n" + "第二步：服务端进程向ServerManager注册信息；\n" + "第三步：客户端进程向ServerManager取得信息，通过Binder驱动与服务端进程通信；\n" + "\n" + "（1）通常意义上来说，Binder就是指Andriod的通信机制；\n" + "（2）对于服务端进程来说，Binder指的是Binder本地对象，对于客户端进程来说，Binder指的是Binder代理对象。\n" + "（3）对于传输过程来说，Binder是可以进行跨进程传递的对象；"
        const val catch_exception = "如何捕捉异常"
        const val catch_exception_answer = "Exception分为两类：一种是CheckedException，一种是UncheckedException，如果是CheckedException，可以用try\\catch来捕捉，如果是运行时异常，可以自定义一个工具类，实现UncaughtExceptionHandler接口，然后在application中初始化，用这个工具来捕获unchecked异常。里面需要重写一个uncaughtException方法，在里面完成错误信息收集，发送错误报告等操作"
        const val ui_block = "UI卡顿原因及优化"
        const val ui_block_answer = "Android系统每隔16ms发出VSYNC垂直同步信号，不能在16ms内完成界面的渲染，那么就会出现丢帧卡顿现象。严重的话就会被用户感知到。\n" + "\n" + "\n" + "引起卡顿主要有以下几点原因\n" + "\n" + "1、主线程被阻塞\n" + "2、资源紧张，比如频繁GC引起的内存抖动，或CPU、GPU负荷过重\n" + "3、UI页面太复杂，过度绘制，导致无法在16MS内渲染完\n" + "\n" + "\n" + "UI卡顿的优化\n" + "\n" + "布局优化：\n" + "1、对大图做压缩、增加复用，使用include、ViewStub、merge标签\n" + "2、减少布局的嵌套、去除冗余的布局\n" + "3、在层级一样的情况下，可以优先选用开销更小的布局，如Linearlayout\n" + "\n" + "\n" + "如何检测\n" + "\n" + "1、可以使用android sdk带的Systrace工具，它可以抓trace文件，然后用Chrom来做分析。里面会包含每个CPU，以及图形渲染，输入事件等等内容。还会给出性能分析结果和优化建议\n" + "2、还可以通过Looper r 消息处理前后的日志输出作为检测点，计算出消息处理的耗时，如果超出16ms，说明发生了卡顿，此时就可以把UI线程的堆栈日志打印出来。"
        const val not_ui_refresh = "为什么非 UI 线程不能更新 UI"
        const val not_ui_refresh_answer = "因为一旦多线程抢着更新UI，那么界面将会乱套更新了，所以在Android中规定必须在主线程更新UI。\n" + "\n" + "他的原理是在根视图ViewRootImpl源码中的requestLayout方法中有个checkThread()方法，他在那做了个检测，如果非UI线程调用会报错。（ViewRootImpl对象是在onResume方法回调之后才创建）\n" + "\n" + "SurfaceView是一个特例。\n" + "SurfaceView是存在于独立UI线程的，它拥有surface(表面)的canvas，在绘制时，可以通过加锁和解锁来绘制，所以当界面如果更新操作时间较长，而且数据量较大的话，一般采用SurfaceView方式更新屏幕，而少用View"
        const val serializable_parcelable = "Serializable和Parcelable的区别"
        const val serializable_parcelable_answer = "所谓的序列化指的是把对象转换成字节流的过程，可以保存到文件中，也可以用来网络传输数据。\n" + "反序列化既是相反的过程，可以从我们的文件中把字节流读出来，转换为对象供我们使用。\n" + "\n" + "\n" + "序列化有两个方法，一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，但在序列化的时候会产生大量的临时变量，内部会执行大量的i/o操作，效率很低。而实现Parcelable接口稍微复杂一些，但效率更高，在内存中读写，但对象不能保存到磁盘中，因为Parcelable在外界有变化的情况下不能很好的保证数据的持续性\n" + "\n" + "Parcelable用法\n" + "\n" + "1）implements Parcelable\n" + "2）实现接口中的两个方法，一个是描述内容的，返回0就行。还有个是重写writeToParcel方法，将你的对象序列化为一个Parcel对象，把属性都写入Parcel对象中\n" + "4）实例化静态内部对象CREATOR实现接口Parcelable.Creator，实例化CREATOR时要实现其中的两个方法，其中createFromParcel的功能就是从Parcel中读取我们的对象（另一个是供外部类反序列化本类数组使用）\n" + "\n" + "调用方法\n" + "\n" + "存：intent.putExtra(\"key\", new Book(\"哈\", \"鸿\", 8));\n" + "取： Book book = intent.getParcelableExtra(\"key\");"
        const val more_process = "应用内多进程"
        const val more_process_answer = "优点\n" + "1、让一个组件运行在单独的进程中，可以减少主进程所占用的内存，降低被系统杀死的概率。\n" + "2、如果子进程因为某种原因崩溃了，不会直接导致主程序的崩溃，可以降低我们程序的崩溃率。\n" + "3、即使主进程退出了，我们的子进程仍然可以继续工作\n" + "\n" + "\n" + "实现：只需要添加 android:process 的属性即可，属性名可以自定义，相同的属性名的进程在同一个里面运行。\n" + "\n" + "1 . 如果android:process的值以冒号开头的话，那么该进程就是私有进程，其他应用的组件不可以和它跑在同一个进程中。\n" + "\n" + "2 . 如果以.开头，那么就是公有进程，其他应用的组件不可以和它跑在同一个进程中。其他应用通过设置相同的ShareUID可以和它跑在同一个进程。\n" + "\n" + "ShareUserId的作用，数据共享、调用其他程序资源。在manifest里可以配置android:sharedUserId=\"com.mythou.share\"\n" + "\n" + "\n" + "多进程的问题\n" + "\n" + "问题1：Application的多次重建，会初始化两回\n" + "解决：判断是否为主进程，只有主进程的时候才执行下面的操作\n" + "String processName = this.getProcessName();\n" + "processName.equals(this.getPackageName())\n" + "\n" + "问题2：静态成员的失效，设置了process属性后，产生了两个隔离的内存空间，一个内存空间里值的修改并不会影响到另外一个内存空间。所以就算是静态成员也是两个不同的成员值。\n" + "\n" + "问题3：文件共享问题，多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等，即便上锁，排队等机制，对多进程也较难实现\n" + "解决：解决方法就是统一由主进程来处理，子进程通知主进程来操作。\n" + "\n" + "问题4：调试断点，调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试。\n" + "解决：临时去掉process标签，统一在一个进程里调试，结束后再还原标签\n"
        const val sp_about = "SharedPreFerences原理、安全性"
        const val sp_about_answer = "简介：\n" + "SharedPreFerences作为Android存储数据方式之一，只支持java基本数据类型，且在进程内数据共享\n" + "\n" + "\n" + "为什么说是轻量级存储\n" + "之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会一次性把整个文件全部加载进内存，如果SharedPreference文件比较大，会导致阻塞线程、产生大量临时对象引起GC、key和value会占用大量内存\n" + "\n" + "\n" + " 使用sharedpreferences保存key-values的步骤：\n" + "\n" + "  1）使用activity类的getSharedPreferences方法获得SharedPreference对象，\n" + "  2）使用sharedpreferences接口的edit获得Sharedpreferences.Editor对象\n" + "  3）通过sharedpreferences.editor接口的putXxx方法保存键值对，\n" + "  4）通过Sharedpreferences.editor接口的commit（）方法保存键值对\n" + "\n" + "\n" + "SharedPrefereces内部工作原理\n" + "\n" + "调用getSharedPreferences（）；创建一个SharedPreferences对象，其中会先判断是否存在对应\n" + "xml文件，如果对应的xml不存在则重新创建一个对应xml文件，如果存在则会把xml文件解析后存入一个map对象中(通过I/O流操作和xmlUtil，map为ArrayMap)。EditorImpl的putXXX方法，主要是将数据保存在一个Map中，这些数据是存储在内存中，只有调用了commit()或apply()方法之后，才会同步到磁盘中。\n" + "\n" + "\n" + "两个提交方式：\n" + "\n" + "commit会立即并同步保存数据。\n" + "apply则异步保存数据，从而提高了性能。如果你不关心它的返回类型，则apply优先于commit\n" + "\n" + "\n" + "进程是否安全\n" + "\n" + "在进程间是不安全的。原因是系统对SharedPreferences的读写有一定的缓存策略，即内存中有一份SharedPreferences文件的缓存，在多进程模式下，系统对它的读写变的不可靠，当面对高并发的读写访问，SharedPreferences很很大几率会造成数据丢失，所以，不建议在进程通信中使用SharedPreferences。\n" + "\n"
        const val lazy_fragment = "fragment懒加载"
        const val lazy_fragment_answer="fragment懒加载\n" + "\n" + "原因：viewpager+fragment结合使用等场景下，因为viewpager有着预加载机制：默认一次加载当前页面前后两个页面，如果不进行懒加载会导致多个fragment页面的生命周期被调用，这样一是会消耗内存、CPU资源，二是造成流量浪费。\n" + "\n" + "\n" + "support包方法：\n" + "1、viewpager+fragment场景时，主要的方法是Fragment中的setUserVisibleHint()，此方法会在onCreateView(）之前执行。使用getUserVisibleHint() 可以返回fragment是否可见状态。  通过在setUserVisibleHint中判断显示与否，再进行异步初始化，初始化后显示正常UI。\n" + "onCreateView—> lazyLoad()异步初始化方法\n" + "setUserVisibleHint—>if (isVisibleToUser)—>lazyLoad()异步初始化方法\n" + "\n" + "2、add+show+hide场景时，我们可以利用onHiddenChanged 来完成懒加载机制\n" + "\n" + "3、当add+hide+show和viewpager+fragment 嵌套组合时，也可以配合setUserVisibleHint+onHiddenChanged来进行懒加载，但需要设置些变量来管理状态\n" + "\n" + "\n" + "Androidx\n" + "1、ViewPager+Fragment，在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有behavior字段的构造函数，当mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT\n" + "也就是fragment显示后只调用onResume，我们只需要在onResume中，加个标识，通过标识来进行懒加载就可以了。原理FragmentPagerAdapter 在其 setPrimaryItem 方法中调用了 setMaxLifecycle 方法，可以在其中配置\n" + "mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);\n" + "\n" + "2、add+show+hide在add fragment时仅把要显示的fragment通过setMaxLifecycle设置为只调用resume，其他fragment均设置为STARTED。\n" + "在show、hide切换显示的fragment时仅把show的fragment通过setMaxLifecycle设置为只调用onResume，其他hide的fragment再还原成STARTED\n" + "\n" + "3、复杂嵌套\n" + "当fragment嵌套fragment等复杂情况下，只要父fragment回调onresume生命周期函数那被嵌套的所有同级子fragment都会回调onresume，所以我们需要再加上fragment是否隐藏的标识，来判断是否要进行懒加载\n" + "\n" + "ViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法"
        const val class_load = "类加载机制、流程"
        const val class_load_answer = "类加载指的是将类的class文件动态的加载到内存中，最终可以被虚拟机直接使用， 这些工作是通过加载器来完成的\n" + "\n" + "JVM采用的是双亲委派加载，也就是有任务会先委派给父加载器，这样从下到上逐层委派，最终会给到根类加载器，如果父类无法加载，子类才会自己尝试加载。双亲委派机制的好处一是可以避免重复加载，二是防止核心API被随意篡改。\n" + "\n" + "整体加载流程也可以叫生命周期有七步：\n" + "1、加载：把class文件加载到内存里，转换成二进制字节流\n" + "2、验证：格式、字节码等验证，保证符合虚拟机要求\n" + "3、准备：在方法区为类变量分配内存设默认值\n" + "4、解析：把虚拟机常量池中的符号引用转换为直接引用也就是内存地址\n" + "5、初始化：为类的静态变量赋初值\n" + "6、使用：\n" + "7、卸载：执行完成\n" + "\n" + "解析这一步是不固定的，有可能会放在初始化之后，为了支持JAVA语言的动态绑定"
        const val abstract_interface = "抽像类与接口的差别"
        const val abstract_interface_answer = "抽象类是对整个类进行抽象，包括属性和方法，是一种模板设计。我们可以有选择地重写需要用到的方法。而接口是对行为的抽象，实现接口的一定要实现接口里定义的所有方法，里面不能有私有的方法或变量，是用于让别人使用的。还有就是一个具体类只能extends一个抽象类，可以implements多个接口。\n" + "\n" + "还有些就是定义上的区别，比如抽像类可以有构造器，但接口没有，访问修饰符抽像类可以有public protected  default等，但接口默认修饰符是public，不可以用其他修饰符。"
        const val blocking_queue = "阻塞队列的原理"
        const val blocking_queue_answer = "阻塞队列实际上是使用了Condition来模拟线程间协作，调用Condition的await()和signal()方法也都是上锁的，原理就是类似于Looper，那种生产者与消费者的场景，当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程会被唤醒，就可insert了"
        const val handler_async = "Handler同步屏障"
        const val handler_async_answer = "Handler有几个构造方法，可以传入async标志为true，这样构造的Handler发送的消息就是异步消息\n" + "同步屏障是通过MessageQueue的postSyncBarrier方法插入到消息队列的。\n" + "移除屏障可以通过MessageQueue的removeSyncBarrier方法：\n" + "\n" + "屏障消息和普通消息的区别在于屏障没有tartget，普通消息有target是因为它需要将消息分发给对应的target，而屏障不需要被分发，它就是用来挡住普通消息来保证异步消息优先处理的。"
        const val delay_message = "延迟消息处理"
        const val delay_message_answer = "实现原理在sendMessageAtTime()方法里，消息被处理的时间 = 当前时间+延迟的时间，\n" + "在MessageQueue的enqueueMessage方法中，将延迟时间封装到msg内部.如果此队列中头部元素是null，或者此消息不是延时的消息，则此消息需要被立即处理。如果此消息是延时的消息，则将其添加到队列中，原理就是链表的添加新元素，按照when，也就是延迟的时间来插入的，延迟的时间越长，越靠后，这样就得到一条有序的延时消息链表。然后在MessageQueue的next方法中\n" + "如果链表头部的消息还没有到时间，则会重新设置超时时间并赋值给nextPollTimeoutMillis，然后调用nativePollOnce(ptr, nextPollTimeoutMillis)进行阻塞，这是一个本地方法，会调用底层C++代码，C++代码最终会通过Linux的epoll监听文件描述符的写入事件来实现延迟的。当时间到后，会唤醒线程，通过Looper把消息取出，再通过dispatchMessage分发出去。\n" + "\n" + "当前时间是用SystemClock.uptimeMillis() 来获取的，表示系统开机到当前的时间总数，这个时钟是保证单调性,适用于计算不跨越设备的时间间隔。\n" + "System.currentTimeMillis()   从1970年1月1日 UTC到现在的毫秒数，是可以通过System.setCurrentTimeMillis修改的"
        const val why_no_die = "为什么Looper.loop不会卡死"
        const val why_no_die_answer = "这个和我们平时理解的卡死有些区别，像平时因为在activity生命周期中执行去执行任务，他是会消耗大量CPU资源的，被阻塞了也就会报ANR异常。\n" + "\n" + "但在主线程中，如果我们想让程序一直运行下去，就需要代码是能一直执行下去的，死循环便能保证不会被退出。当主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，这是一个本地方法，会调用底层C++代码，C++代码最终会通过Linux的epoll监听文件描述符的写入事件来实现阻塞。直到下个消息到达或者有事务发生，通过往pipe管道写入数据来唤醒主线程工作，在这期间，主线程是处于休眠状态的，并不会消耗大量CPU资源，也就不会引起卡死。"
        const val content_provider = "介绍下ContentProvider"
        const val content_provider_answer = "ContentProvider是用来完成进程间 进行数据交互 与数据共享的，一般会通过ContentProvider来完成对具体数据库操作的封装，里面有创建、增删改查、返回mime类型等待。然后在在manifest中通过android:authorities属性配置provider的统一资源标识符URI，\n" + "\n" + "在使用者中，先getContentResolver();得到一个contentresolver的实例，使用该实例就可以调用指定URI的provider的增删改查方法了\n" + "\n" + "例如\n" + "Cursor mCursor = mcContentResolver.query(Uri.parse(\"content://com.example.aboutdata.myprovider\"), string[] 查询字段,string 查询条件,string[] 查询条件参数,String 查询结果排序方式);\n" + "\n" + "ContentProvider的底层是采用 Android中的Binder机制"
        const val how_many_string = "string在使用时会创建几个对象"
        const val how_many_string_answer = "String str1 = \"abc\";  // 在常量池中\n" + "\n" + "String str2 = new String(\"abc\"); // 在堆上 str2   常量池中“abc”  abc如果有不需要创建\n" + "\n" + "String str = \"abc\" + \"def\";  //在编译时已经被合并成“abcdef”字符串，因此，只会创建1个对象。\n" + "\n" + "String str = \"abc\" + new String(\"def\"); //“abc”和“def”，堆中对象new String(\"def\")和“abcdef”。还会创建一个StringBuilder来进行字符串的拼接\u2028"
        const val volatile_principle = "volatile原理"
        const val volatile_principle_answer = "为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。\n" + "\n" + "当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。\n" + "\n" + "为了保证各个处理器的缓存是一致的，还涉及到缓存一致性协议。每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。\n" + "\n" + "所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。"
        const val fragment_activity_communication="fragment与Activity通信"
        const val fragment_activity_communication_answer="第一种：setArguments  bundle\n" + "\n" + "activity:\n" + "MyFragment myFragment = new MyFragment();\n" + "Bundle bundle = new Bundle();\n" + "bundle.putString(\"DATA\",values);//这里的values就是我们要传的值\n" + "myFragment.setArguments(bundle);\n" + "\n" + "Fragment:\n" + "Bundle bundle = getArguments();\n" + "        if(bundle!=null){\n" + "            titles = bundle.getString(\"title\");\n" + "        }\n" + "\n" + "\n" + "第二种：接口,编写接口，定义方法，在fragment中的attach方法中获取到宿主activity并赋值\n" + "if(activity instanceof FragmentBackListener ) {\n" + "    listener = (FragmentBackListener )activity; // 2.2 获取到宿主activity并赋值\n" + "} \n" + "\n" + "//fragment按钮点击时\n" + "listener.dosomething()\n" + "\n" + "\n" + "第三种：直接调用，上下文强转\n" + "  @Override\n" + "       public void onAttach(Context context) {\n" + "           super.onAttach(context);\n" + "           titles = ((MainActivity)getActivity()).getTitles();\n" + "\t}\n" + "\n" + "\n" + "第四种：广播和eventbus"
        const val r_x_java = "介绍下RxJava"
        const val r_x_java_answer = "RxJava的作用\n" + "Rxjava是一个用来实现异步的、基于事件的第三方库，适用于程序逻辑比较复杂的场景，它能够保持代码的良好的阅读性。可以理解成Android Handler 的升级版。\n" + "\n" + "原理\n" + "RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。\n" + "\n" + "线程切换\n" + " RxJava 在切换线程时用到了两个方法 subscribeOn() 和 observeOn() \n" + "* subscribeOn() : 影响的是最开始的被观察者所在的线程。当使用多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用；\n" + "* observeOn() : 影响的是跟在后面的操作（指定观察者运行的线程）。所以如果想要多次改变线程，可以多次使用 observeOn；\n" + ".subscribeOn(Schedulers.io())\n" + ".observeOn(AndroidSchedulers.mainThread())\n" + "\n" + "map与flatMap\n" + "map() 是把发射对象转成另外一个对象发射出去\n" + "flatMap()，他调用的是个Observable，常用来解决循环嵌套，也可以用于嵌套的异步，是把发射对象转成另外一个Observable,进而把这个Observable发射的对象发射出去\n"
        const val jet_pack = "介绍下JetPack"
        const val jet_pack_answer = "Jetpack是一套组件库，它提供了核心库、架构组件、UI组件、帮助我们在不同版本的机器上实现相同的功能代码，像常用的viewPager、fragment、recyclerview这些都是它提供的。\n" + "\n" + "核心库：有appcompat、core\n" + "架构组件：databinding、lifecyle\n" + "UI组件: constraintlayout、recyclerview\n" + "\n" + "其他还有些还有像车载、打印机等不常用的组件"
        const val design_patterns = "介绍下设计模式"
        const val design_patterns_answer = "常用的有\n" + "Builder模式：比如AlertDialog.Builder、glide、okhttp、retrofit在创建时都有用到，建造者模式的意思就是说将一个复杂的对象一步一步进行建造，同样的构建过程，但可以创建不同的功能与样式\n" + "\n" + "适配器模式：比如GridView、ListView与Adapter，把一个类的接口变换成客户端所期待的另一种接口，从而可以兼容正常工作\n" + "\n" + "职责链模式：View的测量、事件分发、OK都是。使多个对象都有机会处理请求，从而避免请求的发送者和接收者直接的耦合关系。\n" + "\n" + "观察者模式：比如ContentObserve、eventbus、还有些系统广播，监听wifi状态的。定义了对象之间的一对多的关系，当触发事件后，会遍历全部的register。\n" + "\n" + "享元模式：比如Java的常量池，线程池，Message的消息池。使用享元对象有效地支持大量的细粒度对象\n" + "\n" + "工厂模式：BitmapFactory、ThreadFactory，定义一个创建对象的接口，让子类决定实例化哪个类\n" + "\n" + "还有像builder是中介者模式，activity是模板方法模式，aidl用到了代理模式，这些都算是常见的。另外还有解释器模式（PackageParser来解释AndroidManifest）、备忘录模式（onSaveInstanceState）可能用的不太多。\n" + "\n" + "设计模式整体一共有23种，其实每天都会用啊，只是没有去归纳总结。有建造型5个、结构型：7个、行为型： 11个。\n"
        const val https_process = "Https传输流程"
        const val https_process_answer = "HTTPS流程\n" + "\n" + "1、客户端向服务端发送通信请求，明确好需要确信的信息，像ssl协议的版本、支持的加密算法，压缩方法等。\n" + "\n" + "2、服务端收到请求，会确认客户端传来的信息，如果协议版本不对，会关闭加密通信。同时服务端还会向客户端传送自己的公钥证书\n" + "\n" + "3、客户端收到证书后，首先会进行验证合法性，是否过期、发行机构、域名是否匹配等。验证通过之后，就会生成一个随机的对称密钥（session key），再使用证书中的公钥进行加密，然后传递给服务器端\n" + "\n" + "4、服务器收到使用公钥加密的内容，使用私钥解密后，拿到客户端值过来的随机值，然后把内容通过该值进行对称加密，传给客户端。\n" + "\n" + "5、客户端再用之前生成的随机值来解密，拿到内容\n" + "\n" + "整体过程就是先确认信息，然后是非对称加密传输对称加密的密钥，再拿对称密钥加密解密。\n"
        const val concurrent_hash_map = "ConcurrentHashMap 原理"
        const val concurrent_hash_map_answer = "1.8版本之前底层用的是HashEntry数组去存储元素。使用的是分段锁技术,将ConcurrentHashMap将锁一段一段的存储，然后给每一段数据配一把锁（segment），当一个线程占用一把锁（segment）访问其中一段数据的时候，其他段的数据也能被其它的线程访问，默认分配16个segment，效率要比hashtable要高很多。\n" + "\n" + "JDK1.8中ConcurrentHashMap取消了segment分段锁，而采用CAS(原子操作)和synchronized来保证并发安全。数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。\n" + "synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升了很多。"
        const val auto_adapter_screen = "屏幕适配方案"
        const val auto_adapter_screen_answer = "1、自适配图片，也就是在res下的选择相应的dpi，不过没特殊需求的话推荐xxdpi，1080*1920，这样就可以满足向上向下兼容，节省资源\n" + "\n" + "2、如果有特殊需求，可以创建指定的分辨率布局进行适配，手机会根据分辨率去找设定的不同大小的layout的布局，layout-800 * 480\n" + "\n" + "3、dp+自适应布局+weight比例布局直接适配\n" + "\n" + "4、另外还可以对value进行指定适配，比如把一些dimen值按比例进行自定义值   value-1080*1920\n" + "\n" + "5、还有一种是修改手机的设备密度 density，他是通过appDisplayMetrics.density动态设置，来使不同分辨率，来实现UI样式统一，不过这种方式只能一刀切的将整个项目进行适配，但适配范围是不可控的，一般不用。"
    }
}

