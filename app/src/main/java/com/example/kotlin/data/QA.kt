package com.example.kotlin.data

/**
 * Author: sym
 * Date: 2021/7/13 8:11 PM
 * Describe:
 */
 class QA{

    companion object {
        const val performance_optimization = "性能优化"
        const val performance_optimization_answer = "性能优化：Android的性能优化，主要是从以下几个方面进行优化的：\n" + " \n" + "一是稳定性，是否有内存溢出、崩溃的情况\n" + "\n" + "二是流畅性，有没有卡顿，冷启动时间长不长\n" + "\n" + "三是耗损是否严重，耗电、流量多不多啊\n" + "\n" + "四是安装包体积等，有没有冗余可优化空间 \n\n\n内存优化\n1.使用leakcanery先解决程序中内存占用较大的业务模块中的内存泄漏\n" + "2.移除程序中多余的代码和引用，这里使用默认的lint检测再配合shrinkResources来删除无效资源\n" + "3.优化图片，保证图片放置在合理的文件夹，根据View大小加载合适的图片大小，根据手机状态配置bitmap和回收策略\n" + "4.优化对象创建，比如string，使用对象池等\n\nAndroid官方对象池的简单实现：SimplePool，也是用得最多的实现\n" + "原理：使用了“懒加载”的思想。当SimplePool初始化时，不会生成N个T类型的对象存放在对象池中。而是当每次外部调用release()时，才把释放的T类型对象存放在对象池中。要先放入，才能取出来。   这样就避免了内存抖动。\n\nMemory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。\n" + "瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。\n"
        const val tcp_shake_hands = "Tcp握手过程"
        const val tcp_shake_hands_answer = "TCP三次握手：\n" + "\n" + "1：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；\n" + "\n" + "2：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n" + "\n" + "3：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n" + "\n" + "四次挥手：\n" + "1、主动关闭方会发一个长度为0的数据包以及FIN关闭标识。\n" + "\n" + "2、被动方收到FIN后，会发一个ACK确认包，确认序号+1。\n" + "\n" + "3、确认无需要发送数据后，被动关闭方也会发一个FIN包，告诉主动关闭方，我也不会再发数据了。\n" + "\n" + "4主动关闭方发ACK确认，确认序号+1。\n\n" + "两次不行，为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。\n" + "\n" + "确认号要加1，因为报文不一定会按发送的时序到达目标，为了区分所以要加1\n" + "\n" + "出现大量的close_wait是因为被动关闭方没有发送FIN包确认关闭，是程序的问题。\n" + "如果是server主动关闭链接,那么Client则有可能进入CLOSE_WAIT,如果Client不发送FIN包，该关不关,那么client就一直会处在CLOSE_WAIT状态\n" + "\n" + "为什么是4次握手，因为被动方收到FIN后，需要先确认，防止主动方因等待时间过长再发FIN，被动方处理完数据后再发FIN"
        const val draw_view = "View的绘制流程"
        const val draw_view_answer = "介绍下实现一个自定义View的基本流程\n" + "①.自定义View的属性 编写attr.xml文件 ②.在layout布局文件中引用，同时引用命名空间 ③.在View的构造方法中获得我们自定义的属性 ，在自定义控件中进行读取（构造方法拿到attr.xml文件值） ④.重写onMesure 、onDraw    如果有需要还可以重写onTouchEvent"
        const val lock_type_use = "锁的分类及用法"
        const val lock_type_use_answer = "Synchronized的用法 ：\n" + "锁主要有三种\n" + "\n" + "类锁:像synchronized(class)或是锁静态方法，这种都是类锁，作用范围比较大，类的所有对象都会被作用到。\n" + "\n" + "第二种是对象锁，像普通方法锁就是，他的作用范围就是一个对象，不同线程不能同时执行一个对象的不同synchronized方法。\n" + "\n" + "还是就是同步代码块，synchronized（obj），这个的作用范围就是被作用的代码块上。"
        const val four_components = "四大组件"
        const val four_components_answer = "Activity【活动】：用于表现功能。 \n" + "Service【服务】：后台运行服务，不提供界面呈现。 \n" + "BroadcastReceiver【广播接收器】：用来接收广播。 \n" + "Content Provider【内容提供商】：支持在多个应用中存储和读取数据，相当于数据库。\n"
        const val activity_life = "Activity生命周期及跳转"
        const val activity_life_answer = "onCreate:create表示创建\n" + "onStart:start表示启动\n" + "onResume:resume表示继续、重新开始\n" + "onPause:pause表示暂停\n" + "onStop：stop表示停止\n" + "onDestroy：destroy表示销毁\n" + "onRestart：restart表示重新开始\n" + "\n" + "当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume，最后才执行A的onStop!!!\n" + "\n" + "当B按下返回键，B先执行onPause，然后是A再执行onRestart -> onStart -> onResume，最后才是B执行onStop  -> onDestroy\n" + "\n" + "如果B是dialog或透明的，A只会执行onPause，不会执行onStop。当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume。（注意：A的 onStop 不会执行）\n" + "\n" + "当B按下返回键，B先执行onPause，然后是A只会执行 onResume，最后 B 执行onStop  -> onDestroy。\n\n Activity弹出 Dialog 对生命周期\n" + "生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响"
        const val android_configChanges = "activity横纵向切换，或页面发生改变时"
        const val android_configChanges_answer = "程序在运行时，一些设备的配置可能会发生改变，如：横竖屏切换、键盘的可用性等这样的事情发生的时候，activity在没有配置android:configChanges属性时会重新启动\n" + "生命周期：onSaveInstanceState-->onPause-->onStop-->onDestroy-->onCreate-->onStart-->onRestoreInstanceState-->onResume\n" + "\n" + "但如果给configChanges配置了orientation|keyboardHidden|screenSize这些属性后，再发生屏幕改变会调用onConfigurationChanged方法，我们可以通过Configuration里的orientation属性判断是横向还是纵向。\n" +"\n"+"onNewIntent 什么时候调用\n"+"如果此次启动不创建该Activity的新实例,则系统会调用原有实例的onNewIntent()方法来处理此intent"
        const val fragment_life = "Fragment生命周期"
        const val service_life_stop = "Service生命周期与终止方法"
        const val service_life_stop_answer = "startService   生命周期       \n" + "onCreate()：创建服务  、\n" + "onStartCommand()：服务开始运行、\n" + "onDestroy() ：服务被停止\n" + "\n" + "bindService     生命周期\n" + " onCreate()：创建服务  、\n" + "onBind()：绑定服务，服务开始运行   、\n" + "onUnbind()：取消绑定   、\n" + "onDestroy() ：服务被停止\n" + "\n" + "终止的话使用stopSelf()或stopService(intent)\n" + "\n" + "混合启动如何停止：同时使用 startService 与 bindService Service 的终止，需要unbindService与stopService同时调用，才能终止 Service。不管 startService 与 bindService 的调用顺序\n\n两种启动方式：\n" + "通过StartService启动Service：startService(new Intent(this, NormalService.class));\n" + "通过bingService启动Service:bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);\n" + "\n" + "区别：\n" + "是生命周期不同，startService一旦服务开启跟开启者就没有任何关系，而bindService可以通过unBindService来停掉Service。而且调用者挂了，服务也会跟着挂掉。\n" + "\n" + "activity与service通信：\n" + "一、通过Intent，startService（intent）来启动Service，在intent中放入数据，在Service的onStartCommant()中接收通过intent传过来的值。（性能差）\n" + "二、binder+回调\n" + "在Activity中实现ServiceConnection，在onServiceConnected()中获取Service的实例，通过这个实例就能调用Service的方法和变量了。\n" + "通过回调可以将Service主动将变化通知Activity。\n" + "三、Broadcase方式\n" + "在Service中需要通知更新UI的地方，发送广播，在Activity中注册广播，在BroadcaseRecever中接受广播，更新UI。\n" + "四、EventBus"
        const val activity_launchMode = "Activity启动模式"
        const val activity_launchMode_answer = "Task是指将相关的Activity组合到一起，以Activity Stack的方式进行管理。一个Task是可以有一个或多个Android Application组成的\n" + "\n" + "\n" + "standard 模式:这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。\n" + "\n" + "singleTop 模式:如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的\n" + "\n" + "\n" + "singleTask 模式:如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建\n" + "\n" + "\n" + "singleInstance 模式\n" + "     在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再启动该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。\n" + "设置启动模式的位置在 AndroidManifest.xml 文件中 Activity 元素的 Android:launchMode 属性。singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，按返回会直接从C跳到A"
        const val http_https = "Http与Https的区别"
        const val http_https_answer = "主要有3点不同\n" + "1、安全性：HTTPS不是明文传输的，会通过SSL数据加密、TLS验证身份，以及数据完整性保护（收方或非法者不能伪造、篡改报文，运营商加广告）而HTTP是明文传输无状态的（比较独立，服务器与客户端都不会记录信息），所以安全性要高于HTTP\n" + "2、HTTPS需要申请CA证书，而HTTP不需要\n" + "3、用的端口也不一样，HTTP是80，HTTPS是443"
        const val jvm_model = "JVM模型"
        const val jvm_model_answer = "程序计数器\n" + "一块较小的内存空间，是字节码解释器的行为指示器。程序执行的过程中会有分支、循环、跳转、异常处理、线程恢复等基础功能，也就是程序运行碰到了关键字或特殊行为，字节码解释器就需要进行特殊处理，而字节码需要怎么做正是由程序计数器去通知。程序计数器是线程私有的\n" + "\n" + "虚拟机栈\n" + "Java 方法执行的内存模型，每个方法执行的时候，都会创建一个栈帧用于保存局部变量表，操作数栈，动态链接，方法出口信息等。一个方法调用的过程就是一个栈帧从 VM 栈入栈到出栈的过程。VM 栈主要用于存储方法包含的信息如，基本数据类型、局部变量等，VM 栈也是线程私有的\n" + "\n" + " 本地方法栈\n" + "执行 Native 方法的栈，与 VM 栈发挥的作用非常相似，VM 栈执行Java 方法（字节码）服务，Native 方法栈执行的是 Native 方法服务。Native 栈也是线程私有的\n" + "\n" + "Java 堆 \n" + "所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象都在这分配内存。Java 堆是线程共享的。\n" + "\n" + "方法区 \n" + "存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。这部分区域包含「运行时常量池」，所以这个区域主要存储常量。方法区是线程共享的\n"
        const val jvm_gc_root = "GC root 对象"
        const val jvm_gc_root_answer = "1.虚拟机栈(栈帧中的本地变量表)中引用的对象\n" + "2.方法区中类静态属性引用的对象\n" + "3.方法区中常量引用的对象\n" + "4.本地方法栈中 JNI(一般说的 Native 方法)引用的对象"
        const val volatile_synchronize_use = "volatile特性、与synchronize区别"
        const val volatile_synchronize_use_answer = "Volatile关键字可以修饰变量，用于多线程的访问\n\nvolatile的作用，保证内存可见性和有序性，但不能保证原子性\n\n" + "内存可见性：如果对变量加上volatile关键字修饰的话，它可以保证当有线程对变量值做了变动之后，会立即刷回到主内存中，所有线程都能读到相同的值\n" + "\n" + "有序性：JVM为了保证执行上的效率，可能会对指令进行重排序，而加上volatile关键字修饰后，在指令间插入一个屏障点，就告诉JVM和CPU，不能进行重排优化。其实volatile有序性是通过内存屏障实现的\n" + "\n" + "不保证原子性：有个例子，1000个线程同时去对被volatile修饰过的变量进行+1操作，但值确肯定不是1000，也就是说volatile并不能保证一个线程执行完，另一个线程才开始执行，不能保证操作并不是不可分割的。\n\n区别：\n" + "1、volatile本质上是直接从主内存中读取值，无法保证同步\n" + "2、volatile只能实现变量的修改可见性，并不能保证原子性；而synchronizedl则因为能保证线程安全，可以保证变量的修改可见性和原子性。\n" + "3、volatile只能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。\n" + "4、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。\n\nsynchronized原理\n" + "\n" + "在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。所有锁都是存储在 Java 对象头里的，Java 对象头里的 Mark Word 里默认存储对象的 HashCode，分代年龄和锁标记位。也就是说 Mark Word 记录了锁的状态\n" + "\n" + "Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，\n" + "\n" + "如果是代码块同步是利用 monitorenter 和 monitorexit 这两个字节码指令来实现的。进入后锁的计数器+1，在执行monitorexit指令时会将锁的计数器减1，当减为0的时候就释放锁。同步方法的字节码指令中没有monitorenter和monitorexit指令，是通过方法修饰符上的ACC_SYNCHRONIZED标识符来实现方法的同步。原理类似。"
        const val handler_four_components_use = "Handler四大组件及使用"
        const val handler_four_components_use_answer = "Message\n" + "Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。\n" + "\n" + "Handler\n" + "处理者，它主要用来发送和处理消息。发送消息一般是使用Handler的sendMessage()方法，消息经过处理后，最终传递到Handler的handlerMessage()方法中。\n" + "\n" + "MessageQueue\n" + "消息队列，它主要用来存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理。每个线程只有一个Messgequeue\n" + "\n" + "Looper\n" + "是每个线程中MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，每当发现MessageQueue中存在一条消息，就会将其取出传递到Handler的handleMessage()方法当中。注意：每个线程中只会有一个Looper对象。\n\nHandler异步消息处理流程：\n" + "首先在UI线程我们创建了一个Handler实例对象，重写handleMessage方法，我们可以通过这个方法的参数msg来实现接受消息过后Ui线程的逻辑处理。在子线程中需要更新UI的时候，可以通过obtain获取一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理。Looper会不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法 \n\n 子线程中创建Handler的方法：需要调用Looper.prepare()创建一个looper,并调用looper.loop来启动循环\n\n一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？\n" + "\n" + "一个Thread只能有一个Looper，一个MessageQueen，可以有多个Handler。\n" + "以一个线程为基准，他们的数量级关系是：Thread(1) : Looper(1) : MessageQueue(1) : Handler(N)。\n"
        const val solve_anr = "ANR是什么？怎样避免和解决ANR"
        const val solve_anr_answer = "1、5秒主要类型按键或触摸事件在特定时间内无响应 \n" + "2、10秒广播在特定的时间内无法处理 \n" + "3、20秒小概率类型Service在特定的时间内无法处理完成\n" + "\n" + "避免ANR最核心的一点就是在主线程减少耗时操作。\n" + "\n" + " a）使用子线程处理耗时IO操作 \n" + " b）降低子线程优先级，使用Thread或者HandlerThread时，调用Process.setThreadPriority（Process.THREAD_PRIORITY_BACKGROUND）设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同 \n" + " c）使用Handler处理子线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程\n" + " d）Activity的onCreate和onResume回调中尽量避免耗时的代码\n" + " e）BroadcastReceiver中onReceiver代码也要尽量减少耗时操作，建议使用intentService处理。intentService是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题\n"
        const val touch_event = "事件分发流程"
        const val touch_event_answer = "android的UI界面由Activity、ViewGroup、View 及其派生类组成，1个点击事件发生后，先传到Activity、再传到ViewGroup、最终再传到 View，如果每层都未对该事件进行处理或者消费那么该事件会从最底层开始往上传，最终会再给到Activity，那这个传递模型就类似于一个U型。\n" + "\n" + "事件的分发中共涉及3个方法，分发方法dispachTouchEvent、拦截onIntercepteorTouchEvent、处理onTouchEvent。其中分发和处理是三层都有的，拦截方法是ViewGrop独有的。\n" + "\n" + "Activity的分发方法如果返回true和flase都会直接消费，返回父类同名方法会向下传递给ViewGrop层的分发方法，ViewGrop层的分发方法返回true会直接消费，返回false，会交给父布局的处理方法，返回父类同名方法，会交给本层的拦截方法，拦截方法返回true会直接消费，返回false或父类同名方法，就会交给下一层的分发方法。View层的分发方法返回true会直接消费，返回false会交给父布局的onTouchEvent处理，返回父类同名方法会交给本层的onTouchEvent方法来处理，View和ViewGrop的onTouchEvent方法处理方式都相同，如果返回true直接消费，返回false或父类同名方法，都会向上传递，如果Activity的onTouchEvent方法也返回false，就说明这个事件不会被处理。\n\n\nACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。\n" + "\n" + "在ViewGroup源码中使用了一个全局变量mFirstTouchTarget来记录是否有View处理了Down事件。mFirstTouchTarget默认为null，如果发现了View可以处理，那么就会把mFirstTouchTarget的值设置为对应的View。那么随之而来的Down和Up都会交给该View处理，（mFirstTouchTarget为单链表结构）\n\ngetX()是表示Widget相对于自身左上角的x坐标。\n" + "getRawX()是表示相对于屏幕左上角的x坐标值，这个屏幕左上角是手机屏幕左上角,不管activity是否有titleBar或是否全屏幕 \n\n滑动冲突解决方案：\n" + "1、可以考虑从父布局的拦截方法onInterceptTouchEvent来处理，如果需要拦截返回true.\n" + "2、如果不修复父布局，可以当前view.getParent().requestDisallowInterceptTouchEvent(true/false);如果传true表示父布局不做处理"
        const val memory_leak = "内存泄漏原因及如何解决"
        const val memory_leak_answer = "一、 非静态内部类会隐式地持有外部类的引用，比较典型的就是Handler，消息会持有Handler对象，Handler对象又隐式地持有了Activity对象，当发生GC是以为message - handler - activity 的引用链导致Activity无法被回收，所以发生了内存泄漏的问题\n" + "解决：把Handler使用完后，调用了removeCallbackMessage清空了它的队列。或将Handler声明为静态内部类，就不会持有外部类的引用，其生命周期就和外部类无关， 如果Handler里面需要context的话，可以通过弱引用方式引用外部类 \n" + "\n" + "二、单例模式引起的内存泄漏。 解决：Context是ApplicationContext，由于ApplicationContext的生命周期是和app一致的，不会导致内存泄漏 \n" + "\n" + "三、注册广播接受器、EventBus等，记得解绑。 \n" + "\n" + "四、资源对象没有关闭引起的内存泄漏。 在这些资源不使用的时候，记得调用相应的类似close（）、destroy（）、recycler（）、release（）等方法释放。 \n" + "\n" + "五、集合对象没有及时清理引起的内存泄漏。 通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用。\n"
        const val animations = "Android动画"
        const val animations_answer = "逐帧动画(Frame Animation) 加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间\n\n" + "补间动画(Tween Animation)也叫视图动画 Tween可以对View对象实现一系列动画效果，比如平移，缩放，旋转，透明度等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。\n\n" + "属性动画(Property Animation) 动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了\n\n\n属性动画\n\nValueAnimator是整个属性动画机制当中最核心的一个类，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。\n" + "\n" + "但如果只是些常规动画，还是使用ObjectAnimator多一些，它会把我们常用的位移、旋转、缩放、透明等效果都做为属性参数直接调用。还可以通过addListener，添加个动画的adapter，来监听它的执行状态。还可以通过setInerpolator来配置插值器，实现些加速或掉落回弹等效果。（通过时间百分比来实现非线性需求）"
        const val hash_map="hashmap工作原理"
        const val hash_map_answer="Hashmap\n" + "HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry<K,V>接口）实现，HashMap 通过 put & get 方法存储和获取。\n" + "\n" + "存储对象时，将 K/V 键值传给 put() 方法：\n" + "①、调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；②、调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；\n" + "③、i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；\n" + "ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；\n" + "iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。\n"
        const val aidl = "aidl"
        const val aidl_answer = "AIDL是进程间通讯的一种方式，一般会与Service、Binder共同完成交互通信。\n" + "\n" + "首先服务端需要先创建AIDL接口文件，定义自己所需要的方法，配置好后build项目，生成aidl JAVA文件，里面会自动生成一个静态的抽像类Stub，继承了Binder，而且还实现了自己所定制aidl接口\n" + "\n" + "然后客户端需要先配置一个与服务端相同的aidl-java文件，并与服务端通过BindService的方式启动一个远程服务，服务端在onBind方法中，传给客户端一个stub代理对象，客户端在ServiceCnection的回调中得到了这个stub代理对象，就可以通过stub里定义好的接口进行通信了。\n" + "\n" + "客户端向服务端：直接用ServiceCnected里返回的bind调用就可以了。\n" + "服务端向客户端：通过接口回调，在客户端ServiceCnected里注册个callback，然后进行通信。"
        const val thread_pool = "线程池相关"
        const val thread_pool_answer = "程序刚启动的时候，会用到线程池，主要是用他批处理任务，也可以顺序执行任务\n\n\n创建线程池的方式一般有两种：\n" + "* 通过Executors工厂方法创建\n" + "* 通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)自定义创建\n" + "\n" + "一、通过Executors工厂方法创建\n" + "Executors.newSingleThreadExecutor()：单线程的线程池，只有一个线程在工作，任务按顺利执行\n" + "Executors.newFixedThreadPool(3)：构建固定线程数的线程池，默认情况下，空闲线程不会被回收\n" + "Executors.newCachedThreadPool():创建一个会根据需要创建新线程的线程池，线程数随着任务量而变动，空闲线程超过60秒将被回收\n" + "Executors.newScheduledThreadPool(空或int):创建定时线程任务的线程池，可以通过传参设置固定数量，它的实例可以调用scheduleAtFixRate(runnable,第一次执行延迟时间，每隔多久执行，时间单位)来周期性执行任务。\n" + "\n" + "二、通过ThreadPoolExecutor构造函数创建：这个就主要是对构造函数的参数要有一定了解，ThreadPoolExecutor 线程池构造函数的七个参数\n" + "\n" + "1、corePoolSize 线程池核心线程大小\n" + "2、maximumPoolSize 线程池最大线程数量\n" + "3、keepAliveTime 空闲线程存活时间\n" + "4、unit 空闲线程存活时间单位\n" + "5、workQueue 工作队列，JDK提供了四种\n" + "6、threadFactory 线程工厂\n" + "7、handler 拒绝策略，JDK提供了四种\n" + "\n" + "线程池任务提交过程,核心流程其实就是走的ThreadPoolExcutor类中的execute(runnable)方法\n" + "\n" + "a. 首先判断核心线程池中的线程是否已经满了，如果没满，则创建一个核心线程执行任务，否则进入下一步\n" + "b. 判断工作队列是否已满，没有满则加入工作队列，否则执行下一步\n" + "c. 判断线程数是否达到了最大值，如果不是，则创建非核心线程执行任务，否则执行饱和策略，默认抛出异常\n" + "\n" + "\n" + "如何关闭线程池\n" + "\n" + "1. shutdown() 不接收新任务,会处理已添加任务\n" + "2. shutdownNow() 不接受新任务,不处理已添加任务,中断正在处理的任务\n" + "\n" + "\n" + "wordQueue\n" + "\n" + "SynchronousQueue:无缓冲等待队列.从队列中取和放都是阻塞方法,如果队列满了再往里放,会进入阻塞.如果队列中没有任务在往出取也会进入阻塞.类似于生产者与消费者模式那种的.这个队列只能装一个任务.\n" + "LinkedBlockingQueue:无界缓存队列. 长度是Integer.MAX_VALUE,当执行的线程数量等于核心线程数量的时候,剩余的任务会在阻塞队列中等待.所以在使用这个队列的时候,最大线程数的参数相当于无效了.\n" + "ArrayBlockingQueue:有界缓存队列可以定义队列的长度.\n" + "PriorityBlockingQueue（具有优先级的无界阻塞队列，优先级通过参数Comparator实现）\n" + "\n" + "注意\n" + "1. 当workQueue使用的是无界限队列时，maximumPoolSize参数就变的无意义了，比如new LinkedBlockingQueue(),或者new ArrayBlockingQueue(Integer.MAX_VALUE);\n" + "2. 使用SynchronousQueue队列时由于该队列没有容量的特性，所以不会对任务进行排队，如果线程池中没有空闲线程，会立即创建一个新线程来接收这个任务。maximumPoolSize要设置大一点。\n" + "3. 核心线程和最大线程数量相等时keepAliveTime无作用.\n" + "\n" + "\n" + "拒绝策略\n" + "\n" + "CallerRunsPolicy：不抛弃线程 调用线程池的线程帮助执行，如果线程池已经shutdown，则直接抛弃任务。\n" + "AbortPolicy：该策略下，直接丢弃任务，并抛出RejectedExecutionException异常\n" + "DiscardPolicy：该策略下，直接丢弃任务，什么都不做。\n" + "DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\n\n非核心线程是如何回收的:工作线程启动后，会进入一个runWorker的方法里。里面是一个while循环，循环判断任务是否为空，若不为空，执行任务；若取不到任务，或发生异常，退出循环，执行processWorkerExit(w, completedAbruptly); 在这个方法里把工作线程移除掉。"
        const val leak_canary="LeakCanary原理"
        const val leak_canary_answer="Leakcanary在初始化时会返回一个refWatcher监听器，他会注册一个callback来监听Activity的onDestroy方法。activity在执行onDestroy后需要被回收，监听机制将Activity包装到WeakReference中，被WeakReference包装过的Activity对象如果被回收，该WeakReference引用会被放到ReferenceQueue中。如果过5秒没有回收，监听机制会手动触发次GC，如果还没有被回收，那就说明Activity可能已经泄露。  这个时候就可以抓取内存dump文件来分析展示了。"
        const val java_reference = "java引用类型"
        const val java_reference_answer = "按引用强度排序\n" + "强引用：当我们使用new创建对象时，被创建的对象就是强引用，如Object object = new Object()，其中的object就是一个强引用了。如果一个对象具有强引用，JVM就不会去GC它，JVM宁可会报OOM来终止程序，也不回收该对象。 \n" + "软引用: 如果一个对象只具备软引用，如果内存空间足够，那么JVM就不会GC它，如果内存空间不足了，就会GC该对象。 \n" + "弱引用: 如果一个对象只具有弱引用，只要JVM的GC线程检测到了，就会立即回收。弱引用的生命周期要比软引用短很多。不过，如果垃圾回收器是一个优先级很低的线程，也不一定会很快就会释放掉软引用的内存。 \n" + "虚引用：如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行GC。\n" + "\n" + "当软引用对象被GC之后，虽然这个SoftReference对象指向的对象已不存在,但这个SoftReference对象本身还占用内存，如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法。ReferenceQueue的poll()方法来检查是否有它所关心的非强引用对象被回收。\n" + "\n" + "软引用一般用于图片缓存，场景，图片编辑bitmap，用法类似于SoftReference<String> sr = new SoftReference<String>(new String(\"hello\"));      System.out.println(sr.get());\n" + "WeakReference<Car> weakCar = new WeakReference<Car>(car);      if(weakCar.get()!=null)，虚引用可以解决一些内存泄漏的问题，如Handler之类的。"
        const val synchronize_lock = "synchronized和Lock的区别,原理，适用场景"
        const val synchronize_lock_answer = "区别：\n" + "1、定义和使用：synchronized是java的关键字，可以作用于类、函数、对象，但lock是接口，需要线程去持有使用实现lock的对象来使用。\n" + "2、操作性：synchronized加锁和解锁都是自动进行的，易于操作，但lock（或实现接口的reentrantlock）都需要手动上锁解锁，最好还要配合try-finaly来使用，防止死锁\n" + "3、灵活性：最重要的，synchronized的是不可终断锁，等待锁过程是固定的，等不到就会一直等，但lock可以trylock尝试上锁，而且能够拿到锁定与否的状态(boolean=lock.trylock())，会有更多的选择，可以提高多个线程进行读操作的效率。\n" + "4、性能：如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized\n" + "\n" + "适用场景：少量线程同步适合用synchronized，大量线程适合用lock"
        const val thread_about = "线程启动、关闭、安全等"
        const val thread_about_answer = "创建线程有两种方式\n" + "\n" + "一、继承 Thread 类，扩展线程。\n" + "二、实现 Runnable 接口。\n" + "\n" + "\n" + "暂停线程的方法\n" + "\n" + "1、使用blooean标志位终止线程，让线程自己完成运行，要用volatile声明。\n" + "2、使用Interrupte方法标记停止，然后再判断是否被中断，并为它增加相应的中断处理代码。\n" + "3、是已经过时的stop方法。不推荐STOP的原因：线程被杀掉，马上被别的线程上锁，数据写还一半就被别的线程上锁，连清理的机会都没有，拿到异常数据，一定会出问题。\n" + "\n" + "\n" + "线程安全\n" + "\n" + "线程安全问题主要围绕三个特性\n" + "1是原子性，也可以理解成相关操作不会被中途被其他线程干扰，可以通过synchronized或使用lock来保证线程同步，还可以使用ThreadLocal来维护变量，也可以阻隔其他线程的干扰\n" + "2是保证内存可见性，一个线程修改了某个共享变量，其状态能立即被其他线程知晓，vollatile就可以保证可见性\n" + "3是有序性，也就是保证线程要执行的指令，不会被JVM或CUP优化重新排序，Volatile也能保证这一点。\n" + "\n" + "除此之外，像synchronized和lock的适用场景也要区分好，wait/notify方法的使用时机等也要注意\n" + "\n"+"线程有哪些状态：New、Runnable、Running、Blocked、Dead。\n" + "\n"
        const val thread_local="ThreadLocal原理"
        const val thread_local_answer = "ThreadLocal是一个关于创建线程局部变量的类。使用场景如下所示：\n" + "\n" + "* 有助于线程安全，因为每个线程都会有一个对应的实例。承载一些线程相关的数据，避免在方法中来回传递参数。\u2028\n" + "* 实现单个线程单例以及单个线程上下文信息存储，比如交易id等。\n" + "\n" + "\n" + "什么是ThreadLocal\n" + "\n" + "ThreadLocal 是 Thread 的共享变量。有助于线程安全，因为每个线程都会有一个对应的实例。承载一些线程相关的数据，避免在方法中来回传递参数，或加synchronized上锁那么麻烦。\n" + "\n" + "\n" + "ThreadLocal的原理\n" + "\n" + "ThreadLocal中有一个ThreadLocalMap中有一个table数组，元素是Entry。根据ThreadLocal(需要转换获取到Hash Key)能get到对应的Enrty。\u2028 Entry中key为ThreadLocal, value就是存储的数值。\n"
        const val sleep_wait = "sleep、wait、notify、notifyAll区别"
        const val sleep_wait_answer = "sleep、wait最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。\n" + "\n" + "1. sleep是Thread类的静态方法,wait是Object类中定义的方法\n" + "2. Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁,而wait 会释放当前线程锁\n" + "3. Thread.sleep需要设定休眠时间.Object.wait也可以设定wait时间,或者通过线程执行notify/notifyAll进行唤醒\n\nnotify与notifyAll\n\n1. notify唤醒一个线程,如果有多线程在wait,可能是随机一个\n" + "\n" + "2. notifyAll唤醒所有在等待的线程,\n" + "\n" + "3. 使用中尽量使用notifyAll,因为notify容易导致线程死锁(nofity只唤醒一个,其他等待的线程没有唤醒)"
        const val version_features = "android版本特性"
        const val version_features_answer = "6.0增加运行时权限\n" + "7.0分屏多任务、夜间模式\n" + "8.0画中画android:supportsPictureInPicture=ture，调用接口、指纹手势\n" + "9.0“刘海”屏幕支持，可以通过windowInsets.getDisplayCutout()、增加ImageDecoder替换BitmapFactory，代码更优雅\n" + "\n" + "//裁剪图像\n" + "imageDecoder.setCrop();\n" + "//调整大小\n" + " imageDecoder.setResize();\n" + "\n" + "10支持可折叠设备、5G 网络\n"
        const val handler_thread = "HandlerThread"
        const val handler_thread_answer = "HandlerThread继承自Thread，因此HandlerThread其实就是一个线程。他和优点就是，HandlerThread的run方法里就调用了Looper.preper()，和looper.loop()方法，为我们创建好了消息Looper.可以直接拿来用。使用场景就是，在子线程中执行耗时的、可能有多个任务的操作。比如说多个网络请求操作，或者多文件 I/O 等等。使用 HandlerThread 的典型例子就是 IntentService\n" + "\n" + "\n" + "HandlerThread handlerThread = new HandlerThread(\"handlerThread\");\n" + "handlerThread.start(); \n" + "\n" + "创建Handler\n" + "Handler mCheckMsgHandler = new Handler(mHandlerThread.getLooper()){\n" + "     @Override\n" + "     public void handleMessage(Message msg){\n" + "         // 进行耗时操作\n" + "     }\n" + "};"
        const val invalidate = "postInvalidate和Invalidate的区别"
        const val invalidate_answer = "一般来说，如果View确定自身不再适合当前区域，比如说它的LayoutParams发生了改变，需要父布局对其进行重新测量、布局、绘制这三个流程，往往使用requestLayout。而invalidate则是刷新当前View，使当前View进行重绘，不会进行测量、布局流程，因此如果View只需要重绘而不需要测量，布局的时候，使用invalidate方法往往比requestLayout方法更高效\n" + "\n" + "postInvalidate\n" + "这个方法与invalidate方法的作用是一样的，都是使View树重绘，但两者的使用条件不同，postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。"
        const val app_start = "APP启动过程及优化"
        const val app_start_answer = "启动过程：\n" + "1、Launcher响应用户点击，通知AMS\n" + "2、AMS响应Launcher进程请求，通知Launcher要进入Paused状态\n" + "3、Launcher进程挂起Launcher，再次通知AMS\n" + "4、AMS创建新的进程，是通过Zygote.fock创建的，要启动的Activity就是在这个APP进程中运行的。\n" + "5、应用进程初始化\n"
        const val assets_res = "Assets目录与res目录的区别"
        const val assets_res_answer = "res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即可，assets文件夹下的文件不会被映射到R文件中，访问的时候需要AssetManager类。\n" + "\n" + "res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹。"
        const val intent_service = "介绍下IntentService"
        const val intent_service_answer = "IntentService其本质上是一个Service，因为它是继承至Service，所以开启IntentService和普通的Service一致。但是他和普通的Service不同之处在于它可以处理异步任务，在任务处理完之后会自动结束。另外，我们可以启动多次IntentService，而每一个耗时任务会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且是串行执行。其实IntentService的内部是通过HandleThread和Handle来实现异步操作的。"
        const val mvp = "介绍下MVP"
        const val mvp_answer = "MVP模式分离了视图逻辑和业务逻辑，Activity只是用来相应生命周期，其他工作都丢到Presenter中完成，Presenter是Model和View之间的桥梁，为了让结构变得更加简单，View并不能直接对Model进行操作，这也是MVP与MVC最大的不同之处。"
        const val final_finally_finalize = "Java 中的 final, finally 和 finalize?"
        const val final_finally_finalize_answer = "\n" + "final：对基本类型而言，你不能改变其数值，对于引用，你不能将其指向一个新的引用，即用final关键字修饰方法，它表示该方法不能被覆盖，用final修饰的类是无法被继承的\n" + "finally：是异常处理中进行收场处理的代码块，比如关闭一个数据库连接，清理一些资源占用的问题。不管有没有异常被捕获，finally子句中的代码都会被执行。\n" + "finalize：finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，定位bug"
        const val equals_deng = " == 和 equals() 有什么区别？"
        const val equals_deng_answer = " ==用法\n" + "    1. 判断基本类型变量是否相等，且都是数值类型（不一定要求数据类型严格相同），只要两个变量的值相等，就返回true\n" + "    2. 对于两个引用类型变量，只有当他们指向同一个对象时，判断才会返回true。且不能用于比较类型上没有父子关系的两个变量\n" + "\n" + "equals用法\u2028\n" + "    equals（）是Object类提供的一个示例方法，因此所有的引用类型变量都能用它来判断是否和其他的引用类型变量相等。\n" + "    1. Object类的equals（）和==运算符几乎一样，也是要求两个引用类型变量指向同一个对象时才会返回true;\n" + "    2. string类的equals（）已经进行了重写，所以str1.euqals(str2)比较的是str1和str2的内容，而不是比较引用类型变量指向的对象\u2028此外：\n" + "\n" + "默认equals在比较两个对象时，是看他们是否指向同一个地址的。\n" + "但有时，我们希望两个对象只要是某些属性相同就认为他们的quals为true。"
        const val overloading_overriding = "重载和重写的区别"
        const val overloading_overriding_answer = "重载：方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。\n" + "\n" + "重写：是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。如果父类的方法有异常声明，那么子类重写这个方法时候，所要声明的异常不应该比父类的大。只能是小等，或者可以没有\n" + "\n" + "可否重写父类的静态方法\n" + "\n" + "静态方法，是在运行时，虚拟机已经认定此方法属于哪个类。 静态方法的调用不需要实例化， \"重写\"只能适用于实例方法.不能用于静态方法.对于静态方法,只能隐藏... "
        const val polymorphism_extends = "什么是多态？什么是继承？"
        const val polymorphism_extends_answer = "多态是：多态是同一个行为具有多个不同表现形式或形态的能力。代码上表现就是同一个接口，使用不同的实例而执行不同操作。多态存在的三个必要条件：继承、重写、父类引用指向子类对象：Parent p = new Child();\n" + "\n" + "继承是：子类继承父类的特征和行为，使得子类具有父类的各种属性和方法。\n"
        const val generic_reflection = "介绍下 泛型、反射"
        const val generic_reflection_answer = "泛型：\n" + "在集合中存储对象并在使用前进行类型转换是很不方便的，并且容易出错，为了防止这种情况，泛型产生。泛型提供了编译期的类型安全，确保我们只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException（类型转换异常）\n" + "\n" + "反射：就是动态加载一个指定的类，并获取该类中的所有的内容，比如有些第三方的JAR文件中的资源，我们没法直接调用，就可以用反射这种比较原始的方法来调用。\n" + "\n" + "1、获得Class对象，就是获取到指定的名称的字节码文件对象。\n" + "Class c = Class.forName(className);\n" + "\n" + "2、实例化对象，获得类的属性、方法或构造函数。\n" + "\u2028Field[] fields = c.getDeclaredFields();\u2028\u2028for (int i = 0; i < fields.length; i++) {\n" + "\n" + "// 打印属性的 修饰符 类型 名称\n" + "System.out.println(Modifier.toString(fields[i].getModifiers()) + \" \" + fields[i].getGenericType() + \" \"+ fields[i].getName());}\n" + "\n" + "\n" + "\n" + "3、访问属性、调用方法、调用构造函数创建对象。"
        const val join_about = "如何让线程按顺序执行"
        const val join_about_answer = "可以用线程类的join()方法，join()方法的作用，是等待这个线程结束；在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕.\n" + "\n" + "newSingleThreadExecutor()方法创建的线程池是一个基于FIFO先进先出的队列，也就是说，当我们依次将thread1，thread2，thread3加入队列中时，实际在就绪状态的只有thread1这个线程，thread2，thread3则会被添加到队列中等待，当thread1执行完毕后，则会按进入队列的先后顺序执行队列中的其他线程。"
        const val deadlock_about = "什么是死锁？死锁的四个条件，如何避免死锁"
        const val deadlock_about_answer = "死锁：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程都处于阻塞状态，无法继续。\n" + "\n" + "\n" + "四个条件\n" + "1、互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。\n" + "\n" + "2、请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n" + "\n" + "3、不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。\n" + "\n" + "4、循环等待条件:若干进程间形成首尾相接循环等待资源的关系\n" + "\n" + "\n" + "如何避免\n" + "在设计阶段就应该考虑如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。比较常用的方法：\n" + "\n" + "1、避免多次锁定。尽量避免同一个线程对多个 Lock 进行锁定。\n" + "\n" + "2、具有相同的加锁顺序。如果多个线程需要对多个 Lock 进行锁定，则应该保证它们以相同的顺序请求加锁\n" + "\n" + "3、使用定时锁。程序在调用 acquire() 方法加锁时可指定 timeout 参数，该参数指定超过 timeout 秒后会自动释放对 Lock 的锁定，这样就可以解开死锁了\n" + "\n" + "4、用算法来做死锁检测。这个了解一些，服务端可能会用到，客户端用的不多。"
        const val sum_link = "数组和链表的区别"
        const val sum_link_answer = "数组：是将元素在内存中连续存储的；它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效率比较高；它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低。\n" + "\n" + "链表：是动态申请内存空间，不需要像数组需要提前申请好内存的大小，链表只需在用的时候申请就可以，根据需要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）"
        const val array_link = "ArrayList和LinkedList的区别，以及应用场景"
        const val array_link_answer = "Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中后面的所有数据。最差情况是ON\n" + "\n" + "linkedList是基于双链表的，他的特点就是插入和删除非常快，只需要改变相邻节点的指针就可以了，但他如果用来查询就很慢了，最差情况是ON，因为他需要一个一个去找。\n" + "\n" + "除此之外像ArrayList是数组结构，所以他的起始容量是10，当数组需要增长时，就会新增一个为原来1.5倍容量的新数组，然后把原数组的数据原封不动的复制到新数组中，再把新数组赋值给原来的数组对象就完成了。所以会有空间浪费的情况\n" + "\n" + "一般情况下，LinkedList的占用空间更大，因为每个节点要维护指向前后地址的两个节点，但也不是绝对，如果刚好数据量超过ArrayList默认的临时值时，ArrayList占用的空间也是不小的，因为扩容的原因会浪费将近原来数组一半的容量\n"
        const val string_string_buffer = "String、StringBuffer、StringBuilder的区别"
        const val string_string_buffer_answer = "String:\n" + "字符串常量不适用于经常要改变值得情况，每次改变相当于生成一个新的对象\n\n" + "StringBuffer:\n" + "字符串变量（线程安全）\n" + "StringBuilder:\n" + "字符串变量\n" + "（\n" + "线程不安全）\n" + "确保单线程下可用，\n" + "效率略高于\n" + "StringBuffer"
        const val thread_application = "进程和线程的区别"
        const val thread_application_answer = "进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。一个进程内可拥有多个线程，进程可开启进程，也可开启线程。一个线程只能属于一个进程，线程可直接使用同进程的资源,线程依赖于进程而存在。"
        const val hash_map_hashtable = "HashMap与HashTable的区别"
        const val hash_map_hashtable_answer = " Hashtable 中的方法是Synchronize的，而HashMap是不加锁的，在多线程并发的环境下，可以直接使用Hashtable，但使用HashMap时就必须要自己增加同步处理\n" + "\n" + " Hashtable中，key和value都不允许出现null值。但是如果在Hashtable中有类似put(null,null)的操作\n" + "\n" + "HashMap 要比 HashTable 效率高，现在用hashtable比较少。"
    }
}

