package com.example.kotlin.data

/**
 * Author: sym
 * Date: 2021/7/13 8:11 PM
 * Describe:
 */
 class QA{

    companion object {
        const val performance_optimization = "性能优化"
        const val performance_optimization_answer = "性能优化：Android的性能优化，主要是从以下几个方面进行优化的：\n" + " \n" + "一是稳定性，是否有内存溢出、崩溃的情况\n" + "\n" + "二是流畅性，有没有卡顿，冷启动时间长不长\n" + "\n" + "三是耗损是否严重，耗电、流量多不多啊\n" + "\n" + "四是安装包体积等，有没有冗余可优化空间 \n\n\n内存优化\n1.使用leakcanery先解决程序中内存占用较大的业务模块中的内存泄漏\n" + "2.移除程序中多余的代码和引用，这里使用默认的lint检测再配合shrinkResources来删除无效资源\n" + "3.优化图片，保证图片放置在合理的文件夹，根据View大小加载合适的图片大小，根据手机状态配置bitmap和回收策略\n" + "4.优化对象创建，比如string，使用对象池等\n\nAndroid官方对象池的简单实现：SimplePool，也是用得最多的实现\n" + "原理：使用了“懒加载”的思想。当SimplePool初始化时，不会生成N个T类型的对象存放在对象池中。而是当每次外部调用release()时，才把释放的T类型对象存放在对象池中。要先放入，才能取出来。   这样就避免了内存抖动。\n\nMemory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。\n" + "瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。\n"
        const val tcp_shake_hands = "Tcp握手过程"
        const val tcp_shake_hands_answer = "TCP三次握手：\n" + "\n" + "1：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；\n" + "\n" + "2：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n" + "\n" + "3：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n" + "\n" + "四次挥手：\n" + "1、主动关闭方会发一个长度为0的数据包以及FIN关闭标识。\n" + "\n" + "2、被动方收到FIN后，会发一个ACK确认包，确认序号+1。\n" + "\n" + "3、确认无需要发送数据后，被动关闭方也会发一个FIN包，告诉主动关闭方，我也不会再发数据了。\n" + "\n" + "4主动关闭方发ACK确认，确认序号+1。\n\n" + "两次不行，为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。\n" + "\n" + "确认号要加1，因为报文不一定会按发送的时序到达目标，为了区分所以要加1\n" + "\n" + "出现大量的close_wait是因为被动关闭方没有发送FIN包确认关闭，是程序的问题。\n" + "如果是server主动关闭链接,那么Client则有可能进入CLOSE_WAIT,如果Client不发送FIN包，该关不关,那么client就一直会处在CLOSE_WAIT状态\n" + "\n" + "为什么是4次握手，因为被动方收到FIN后，需要先确认，防止主动方因等待时间过长再发FIN，被动方处理完数据后再发FIN"
        const val draw_view = "View的绘制流程"
        const val draw_view_answer = "介绍下实现一个自定义View的基本流程\n" + "①.自定义View的属性 编写attr.xml文件 ②.在layout布局文件中引用，同时引用命名空间 ③.在View的构造方法中获得我们自定义的属性 ，在自定义控件中进行读取（构造方法拿到attr.xml文件值） ④.重写onMesure 、onDraw    如果有需要还可以重写onTouchEvent"
        const val lock_type_use = "锁的分类及用法"
        const val lock_type_use_answer = "Synchronized的用法 ：\n" + "锁主要有三种\n" + "\n" + "类锁:像synchronized(class)或是锁静态方法，这种都是类锁，作用范围比较大，类的所有对象都会被作用到。\n" + "\n" + "第二种是对象锁，像普通方法锁就是，他的作用范围就是一个对象，不同线程不能同时执行一个对象的不同synchronized方法。\n" + "\n" + "还是就是同步代码块，synchronized（obj），这个的作用范围就是被作用的代码块上。"
        const val four_components = "四大组件"
        const val four_components_answer = "Activity【活动】：用于表现功能。 \n" + "Service【服务】：后台运行服务，不提供界面呈现。 \n" + "BroadcastReceiver【广播接收器】：用来接收广播。 \n" + "Content Provider【内容提供商】：支持在多个应用中存储和读取数据，相当于数据库。\n"
        const val activity_life = "Activity生命周期及跳转"
        const val activity_life_answer = "onCreate:create表示创建\n" + "onStart:start表示启动\n" + "onResume:resume表示继续、重新开始\n" + "onPause:pause表示暂停\n" + "onStop：stop表示停止\n" + "onDestroy：destroy表示销毁\n" + "onRestart：restart表示重新开始\n" + "\n" + "当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume，最后才执行A的onStop!!!\n" + "\n" + "当B按下返回键，B先执行onPause，然后是A再执行onRestart -> onStart -> onResume，最后才是B执行onStop  -> onDestroy\n" + "\n" + "如果B是dialog或透明的，A只会执行onPause，不会执行onStop。当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume。（注意：A的 onStop 不会执行）\n" + "\n" + "当B按下返回键，B先执行onPause，然后是A只会执行 onResume，最后 B 执行onStop  -> onDestroy。\n\n Activity弹出 Dialog 对生命周期\n" + "生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响"
        const val android_configChanges = "activity横纵向切换，或页面发生改变时"
        const val android_configChanges_answer = "程序在运行时，一些设备的配置可能会发生改变，如：横竖屏切换、键盘的可用性等这样的事情发生的时候，activity在没有配置android:configChanges属性时会重新启动\n" + "生命周期：onSaveInstanceState-->onPause-->onStop-->onDestroy-->onCreate-->onStart-->onRestoreInstanceState-->onResume\n" + "\n" + "但如果给configChanges配置了orientation|keyboardHidden|screenSize这些属性后，再发生屏幕改变会调用onConfigurationChanged方法，我们可以通过Configuration里的orientation属性判断是横向还是纵向。\n" +"\n"+"onNewIntent 什么时候调用\n"+"如果此次启动不创建该Activity的新实例,则系统会调用原有实例的onNewIntent()方法来处理此intent"
        const val fragment_life = "Fragment生命周期"
        const val service_life_stop = "Service生命周期与终止方法"
        const val service_life_stop_answer = "startService   生命周期       \n" + "onCreate()：创建服务  、\n" + "onStartCommand()：服务开始运行、\n" + "onDestroy() ：服务被停止\n" + "\n" + "bindService     生命周期\n" + " onCreate()：创建服务  、\n" + "onBind()：绑定服务，服务开始运行   、\n" + "onUnbind()：取消绑定   、\n" + "onDestroy() ：服务被停止\n" + "\n" + "终止的话使用stopSelf()或stopService(intent)\n" + "\n" + "混合启动如何停止：同时使用 startService 与 bindService Service 的终止，需要unbindService与stopService同时调用，才能终止 Service。不管 startService 与 bindService 的调用顺序\n\n两种启动方式：\n" + "通过StartService启动Service：startService(new Intent(this, NormalService.class));\n" + "通过bingService启动Service:bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);\n" + "\n" + "区别：\n" + "是生命周期不同，startService一旦服务开启跟开启者就没有任何关系，而bindService可以通过unBindService来停掉Service。而且调用者挂了，服务也会跟着挂掉。\n" + "\n" + "activity与service通信：\n" + "一、通过Intent，startService（intent）来启动Service，在intent中放入数据，在Service的onStartCommant()中接收通过intent传过来的值。（性能差）\n" + "二、binder+回调\n" + "在Activity中实现ServiceConnection，在onServiceConnected()中获取Service的实例，通过这个实例就能调用Service的方法和变量了。\n" + "通过回调可以将Service主动将变化通知Activity。\n" + "三、Broadcase方式\n" + "在Service中需要通知更新UI的地方，发送广播，在Activity中注册广播，在BroadcaseRecever中接受广播，更新UI。\n" + "四、EventBus"
        const val activity_launchMode = "Activity启动模式"
        const val activity_launchMode_answer = "Task是指将相关的Activity组合到一起，以Activity Stack的方式进行管理。一个Task是可以有一个或多个Android Application组成的\n" + "\n" + "\n" + "standard 模式:这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。\n" + "\n" + "singleTop 模式:如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的\n" + "\n" + "\n" + "singleTask 模式:如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建\n" + "\n" + "\n" + "singleInstance 模式\n" + "     在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再启动该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。\n" + "设置启动模式的位置在 AndroidManifest.xml 文件中 Activity 元素的 Android:launchMode 属性。singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，按返回会直接从C跳到A"
        const val http_https = "Http与Https的区别"
        const val http_https_answer = "主要有3点不同\n" + "1、安全性：HTTPS不是明文传输的，会通过SSL数据加密、TLS验证身份，以及数据完整性保护（收方或非法者不能伪造、篡改报文，运营商加广告）而HTTP是明文传输无状态的（比较独立，服务器与客户端都不会记录信息），所以安全性要高于HTTP\n" + "2、HTTPS需要申请CA证书，而HTTP不需要\n" + "3、用的端口也不一样，HTTP是80，HTTPS是443"
        const val jvm_model = "JVM模型"
        const val jvm_model_answer = "程序计数器\n" + "一块较小的内存空间，是字节码解释器的行为指示器。程序执行的过程中会有分支、循环、跳转、异常处理、线程恢复等基础功能，也就是程序运行碰到了关键字或特殊行为，字节码解释器就需要进行特殊处理，而字节码需要怎么做正是由程序计数器去通知。程序计数器是线程私有的\n" + "\n" + "虚拟机栈\n" + "Java 方法执行的内存模型，每个方法执行的时候，都会创建一个栈帧用于保存局部变量表，操作数栈，动态链接，方法出口信息等。一个方法调用的过程就是一个栈帧从 VM 栈入栈到出栈的过程。VM 栈主要用于存储方法包含的信息如，基本数据类型、局部变量等，VM 栈也是线程私有的\n" + "\n" + " 本地方法栈\n" + "执行 Native 方法的栈，与 VM 栈发挥的作用非常相似，VM 栈执行Java 方法（字节码）服务，Native 方法栈执行的是 Native 方法服务。Native 栈也是线程私有的\n" + "\n" + "Java 堆 \n" + "所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象都在这分配内存。Java 堆是线程共享的。\n" + "\n" + "方法区 \n" + "存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。这部分区域包含「运行时常量池」，所以这个区域主要存储常量。方法区是线程共享的\n"
        const val jvm_gc_root = "GC root 对象"
        const val jvm_gc_root_answer = "1.虚拟机栈(栈帧中的本地变量表)中引用的对象\n" + "2.方法区中类静态属性引用的对象\n" + "3.方法区中常量引用的对象\n" + "4.本地方法栈中 JNI(一般说的 Native 方法)引用的对象"
        const val volatile_synchronize_use = "volatile特性、与synchronize区别"
        const val volatile_synchronize_use_answer = "Volatile关键字可以修饰变量，用于多线程的访问\n\nvolatile的作用，保证内存可见性和有序性，但不能保证原子性\n\n" + "内存可见性：如果对变量加上volatile关键字修饰的话，它可以保证当有线程对变量值做了变动之后，会立即刷回到主内存中，所有线程都能读到相同的值\n" + "\n" + "有序性：JVM为了保证执行上的效率，可能会对指令进行重排序，而加上volatile关键字修饰后，在指令间插入一个屏障点，就告诉JVM和CPU，不能进行重排优化。其实volatile有序性是通过内存屏障实现的\n" + "\n" + "不保证原子性：有个例子，1000个线程同时去对被volatile修饰过的变量进行+1操作，但值确肯定不是1000，也就是说volatile并不能保证一个线程执行完，另一个线程才开始执行，不能保证操作并不是不可分割的。\n\n区别：\n" + "1、volatile本质上是直接从主内存中读取值，无法保证同步\n" + "2、volatile只能实现变量的修改可见性，并不能保证原子性；而synchronizedl则因为能保证线程安全，可以保证变量的修改可见性和原子性。\n" + "3、volatile只能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。\n" + "4、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。\n\nsynchronized原理\n" + "\n" + "在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。所有锁都是存储在 Java 对象头里的，Java 对象头里的 Mark Word 里默认存储对象的 HashCode，分代年龄和锁标记位。也就是说 Mark Word 记录了锁的状态\n" + "\n" + "Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，\n" + "\n" + "如果是代码块同步是利用 monitorenter 和 monitorexit 这两个字节码指令来实现的。进入后锁的计数器+1，在执行monitorexit指令时会将锁的计数器减1，当减为0的时候就释放锁。同步方法的字节码指令中没有monitorenter和monitorexit指令，是通过方法修饰符上的ACC_SYNCHRONIZED标识符来实现方法的同步。原理类似。"
        const val handler_four_components_use = "Handler四大组件及使用"
        const val handler_four_components_use_answer = "Message\n" + "Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。\n" + "\n" + "Handler\n" + "处理者，它主要用来发送和处理消息。发送消息一般是使用Handler的sendMessage()方法，消息经过处理后，最终传递到Handler的handlerMessage()方法中。\n" + "\n" + "MessageQueue\n" + "消息队列，它主要用来存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理。每个线程只有一个Messgequeue\n" + "\n" + "Looper\n" + "是每个线程中MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，每当发现MessageQueue中存在一条消息，就会将其取出传递到Handler的handleMessage()方法当中。注意：每个线程中只会有一个Looper对象。\n\nHandler异步消息处理流程：\n" + "首先在UI线程我们创建了一个Handler实例对象，重写handleMessage方法，我们可以通过这个方法的参数msg来实现接受消息过后Ui线程的逻辑处理。在子线程中需要更新UI的时候，可以通过obtain获取一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理。Looper会不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法 \n\n 子线程中创建Handler的方法：需要调用Looper.prepare()创建一个looper,并调用looper.loop来启动循环\n\n一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？\n" + "\n" + "一个Thread只能有一个Looper，一个MessageQueen，可以有多个Handler。\n" + "以一个线程为基准，他们的数量级关系是：Thread(1) : Looper(1) : MessageQueue(1) : Handler(N)。\n"
        const val solve_anr = "ANR是什么？怎样避免和解决ANR"
        const val solve_anr_answer = "1、5秒主要类型按键或触摸事件在特定时间内无响应 \n" + "2、10秒广播在特定的时间内无法处理 \n" + "3、20秒小概率类型Service在特定的时间内无法处理完成\n" + "\n" + "避免ANR最核心的一点就是在主线程减少耗时操作。\n" + "\n" + " a）使用子线程处理耗时IO操作 \n" + " b）降低子线程优先级，使用Thread或者HandlerThread时，调用Process.setThreadPriority（Process.THREAD_PRIORITY_BACKGROUND）设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同 \n" + " c）使用Handler处理子线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程\n" + " d）Activity的onCreate和onResume回调中尽量避免耗时的代码\n" + " e）BroadcastReceiver中onReceiver代码也要尽量减少耗时操作，建议使用intentService处理。intentService是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题\n"
        const val touch_event = "事件分发流程"
        const val touch_event_answer = "Android的UI界面由Activity、ViewGroup、View 及其派生类组成，1个点击事件发生后，如果我们没有对控件里面的方法进行重写或更改返回值，而直接用super调用父类的默认实现，该事件会先传到Activity、再传到ViewGroup、最终再传到 View，再从最底层开始往上传，那这个传递模型就类似于一个U型。\n" + "\n" + "\n" + "其中共涉及3个方法，分发方法dispachTouchEvent、拦截onIntercepteorTouchEvent、处理onTouchEvent。其中分发和处理是三层都有的，拦截方法是ViewGrop独有的。\n" + "\n" + "\n" + "分发方法 和 处理方法 一旦return true,事件就停止传递了，直接消费掉，而返回 false的时候事件都回传给父控件的onTouchEvent处理。\n" + "而拦截方法返回true会给到本层的onTouchEvent处理,false和默认方法都不拦截，会向下走。\n" + "\n" + "ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。\n\n" + "\n" + "在ViewGroup源码中使用了一个全局变量mFirstTouchTarget来记录是否有View处理了Down事件。mFirstTouchTarget默认为null，如果发现了View可以处理，那么就会把mFirstTouchTarget的值设置为对应的View。那么随之而来的Down和Up都会交给该View处理，（mFirstTouchTarget为单链表结构）\n\ngetX()是表示Widget相对于自身左上角的x坐标。\n" + "getRawX()是表示相对于屏幕左上角的x坐标值，这个屏幕左上角是手机屏幕左上角,不管activity是否有titleBar或是否全屏幕 \n\n滑动冲突解决方案：\n" + "1、可以考虑从父布局的拦截方法onInterceptTouchEvent来处理，如果需要拦截返回true.\n" + "2、如果不修复父布局，可以当前view.getParent().requestDisallowInterceptTouchEvent(true/false);如果传true表示父布局不做处理"
        const val memory_leak = "内存泄漏原因及如何解决"
        const val memory_leak_answer = "一、 非静态内部类会隐式地持有外部类的引用，比较典型的就是Handler，消息会持有Handler对象，Handler对象又隐式地持有了Activity对象，当发生GC是以为message - handler - activity 的引用链导致Activity无法被回收，所以发生了内存泄漏的问题\n" + "解决：把Handler使用完后，调用了removeCallbackMessage清空了它的队列。或将Handler声明为静态内部类，就不会持有外部类的引用，其生命周期就和外部类无关， 如果Handler里面需要context的话，可以通过弱引用方式引用外部类 \n" + "\n" + "二、单例模式引起的内存泄漏。 解决：Context是ApplicationContext，由于ApplicationContext的生命周期是和app一致的，不会导致内存泄漏 \n" + "\n" + "三、注册广播接受器、EventBus等，记得解绑。 \n" + "\n" + "四、资源对象没有关闭引起的内存泄漏。 在这些资源不使用的时候，记得关闭，像字节流FileOutputStream调用close（）、多媒体MediaPlayer调用release（）等方法释放等。 \n" + "\n" + "五、集合对象没有及时清理引起的内存泄漏。 通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用。\n\n\n"
        const val animations = "Android动画"
        const val animations_answer = "逐帧动画(Frame Animation) 加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间\n\n" + "补间动画(Tween Animation)也叫视图动画 Tween可以对View对象实现一系列动画效果，比如平移，缩放，旋转，透明度等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。\n\n" + "属性动画(Property Animation) 动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了\n\n\n属性动画\n\nValueAnimator是整个属性动画机制当中最核心的一个类，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。\n" + "\n" + "但如果只是些常规动画，还是使用ObjectAnimator多一些，它会把我们常用的位移、旋转、缩放、透明等效果都做为属性参数直接调用。还可以通过addListener，添加个动画的adapter，来监听它的执行状态。还可以通过setInerpolator来配置插值器，实现些加速或掉落回弹等效果。（通过时间百分比来实现非线性需求）"
        const val hash_map="hashmap工作原理"
        const val hash_map_answer="Hashmap\n" + "HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry<K,V>接口）实现，HashMap 通过 put & get 方法存储和获取。\n" + "\n" + "存储对象时，将 K/V 键值传给 put() 方法：\n" + "①、调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；②、调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；\n" + "③、i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；\n" + "ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；\n" + "iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。\n"
        const val aidl = "aidl"
        const val aidl_answer = "AIDL是进程间通讯的一种方式，一般会与Service、Binder共同完成交互通信。\n" + "\n" + "首先服务端需要先创建AIDL接口文件，定义自己所需要的方法，配置好后build项目，生成aidl JAVA文件，里面会自动生成一个静态的抽像类Stub，继承了Binder，而且还实现了自己所定制aidl接口\n" + "\n" + "然后客户端需要先配置一个与服务端相同的aidl-java文件，并与服务端通过BindService的方式启动一个远程服务，服务端在onBind方法中，传给客户端一个stub代理对象，客户端在ServiceCnection的回调中得到了这个stub代理对象，就可以通过stub里定义好的接口进行通信了。\n" + "\n" + "客户端向服务端：直接用ServiceCnected里返回的bind调用就可以了。\n" + "服务端向客户端：通过接口回调，在客户端ServiceCnected里注册个callback，然后进行通信。"
        const val thread_pool = "线程池相关"
        const val thread_pool_answer = "程序刚启动的时候，会用到线程池，主要是用他批处理任务，也可以顺序执行任务\n\n\n创建线程池的方式一般有两种：\n" + "* 通过Executors工厂方法创建\n" + "* 通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)自定义创建\n" + "\n" + "一、通过Executors工厂方法创建\n" + "Executors.newSingleThreadExecutor()：单线程的线程池，只有一个线程在工作，任务按顺利执行\n" + "Executors.newFixedThreadPool(3)：构建固定线程数的线程池，默认情况下，空闲线程不会被回收\n" + "Executors.newCachedThreadPool():创建一个会根据需要创建新线程的线程池，线程数随着任务量而变动，空闲线程超过60秒将被回收\n" + "Executors.newScheduledThreadPool(空或int):创建定时线程任务的线程池，可以通过传参设置固定数量，它的实例可以调用scheduleAtFixRate(runnable,第一次执行延迟时间，每隔多久执行，时间单位)来周期性执行任务。\n" + "\n" + "二、通过ThreadPoolExecutor构造函数创建：这个就主要是对构造函数的参数要有一定了解，ThreadPoolExecutor 线程池构造函数的七个参数\n" + "\n" + "1、corePoolSize 线程池核心线程大小\n" + "2、maximumPoolSize 线程池最大线程数量\n" + "3、keepAliveTime 空闲线程存活时间\n" + "4、unit 空闲线程存活时间单位\n" + "5、workQueue 工作队列，JDK提供了四种\n" + "6、threadFactory 线程工厂\n" + "7、handler 拒绝策略，JDK提供了四种\n" + "\n" + "线程池任务提交过程,核心流程其实就是走的ThreadPoolExcutor类中的execute(runnable)方法\n" + "\n" + "a. 首先判断核心线程池中的线程是否已经满了，如果没满，则创建一个核心线程执行任务，否则进入下一步\n" + "b. 判断工作队列是否已满，没有满则加入工作队列，否则执行下一步\n" + "c. 判断线程数是否达到了最大值，如果不是，则创建非核心线程执行任务，否则执行饱和策略，默认抛出异常\n" + "\n" + "\n" + "如何关闭线程池\n" + "\n" + "1. shutdown() 不接收新任务,会处理已添加任务\n" + "2. shutdownNow() 不接受新任务,不处理已添加任务,中断正在处理的任务\n" + "\n" + "\n" + "wordQueue\n" + "\n" + "SynchronousQueue:无缓冲等待队列.从队列中取和放都是阻塞方法,如果队列满了再往里放,会进入阻塞.如果队列中没有任务在往出取也会进入阻塞.类似于生产者与消费者模式那种的.这个队列只能装一个任务.\n" + "LinkedBlockingQueue:无界缓存队列. 长度是Integer.MAX_VALUE,当执行的线程数量等于核心线程数量的时候,剩余的任务会在阻塞队列中等待.所以在使用这个队列的时候,最大线程数的参数相当于无效了.\n" + "ArrayBlockingQueue:有界缓存队列可以定义队列的长度.\n" + "PriorityBlockingQueue（具有优先级的无界阻塞队列，优先级通过参数Comparator实现）\n" + "\n" + "注意\n" + "1. 当workQueue使用的是无界限队列时，maximumPoolSize参数就变的无意义了，比如new LinkedBlockingQueue(),或者new ArrayBlockingQueue(Integer.MAX_VALUE);\n" + "2. 使用SynchronousQueue队列时由于该队列没有容量的特性，所以不会对任务进行排队，如果线程池中没有空闲线程，会立即创建一个新线程来接收这个任务。maximumPoolSize要设置大一点。\n" + "3. 核心线程和最大线程数量相等时keepAliveTime无作用.\n" + "\n" + "\n" + "拒绝策略\n" + "\n" + "CallerRunsPolicy：不抛弃线程 调用线程池的线程帮助执行，如果线程池已经shutdown，则直接抛弃任务。\n" + "AbortPolicy：该策略下，直接丢弃任务，并抛出RejectedExecutionException异常\n" + "DiscardPolicy：该策略下，直接丢弃任务，什么都不做。\n" + "DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列\n\n非核心线程是如何回收的:工作线程启动后，会进入一个runWorker的方法里。里面是一个while循环，循环判断任务是否为空，若不为空，执行任务；若取不到任务，或发生异常，退出循环，执行processWorkerExit(w, completedAbruptly); 在这个方法里把工作线程移除掉。"
        const val leak_canary="LeakCanary原理"
        const val leak_canary_answer="Leakcanary在初始化时会返回一个refWatcher监听器，他会注册一个callback来监听Activity的onDestroy方法。activity在执行onDestroy后需要被回收，监听机制将Activity包装到WeakReference中，被WeakReference包装过的Activity对象如果被回收，该WeakReference引用会被放到ReferenceQueue中。如果过5秒没有回收，监听机制会手动触发次GC，如果还没有被回收，那就说明Activity可能已经泄露。  这个时候就可以抓取内存dump文件来分析展示了。"
        const val java_reference = "java引用类型"
        const val java_reference_answer = "按引用强度排序\n" + "强引用：当我们使用new创建对象时，被创建的对象就是强引用，如Object object = new Object()，其中的object就是一个强引用了。如果一个对象具有强引用，JVM就不会去GC它，JVM宁可会报OOM来终止程序，也不回收该对象。 \n" + "软引用: 如果一个对象只具备软引用，如果内存空间足够，那么JVM就不会GC它，如果内存空间不足了，就会GC该对象。 \n" + "弱引用: 如果一个对象只具有弱引用，只要JVM的GC线程检测到了，就会立即回收。弱引用的生命周期要比软引用短很多。不过，如果垃圾回收器是一个优先级很低的线程，也不一定会很快就会释放掉软引用的内存。 \n" + "虚引用：如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行GC。\n" + "\n" + "当软引用对象被GC之后，虽然这个SoftReference对象指向的对象已不存在,但这个SoftReference对象本身还占用内存，如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法。ReferenceQueue的poll()方法来检查是否有它所关心的非强引用对象被回收。\n" + "\n" + "软引用一般用于图片缓存，场景，图片编辑bitmap，用法类似于SoftReference<String> sr = new SoftReference<String>(new String(\"hello\"));      System.out.println(sr.get());\n" + "WeakReference<Car> weakCar = new WeakReference<Car>(car);      if(weakCar.get()!=null)，虚引用可以解决一些内存泄漏的问题，如Handler之类的。"
        const val synchronize_lock = "synchronized和Lock的区别,原理，适用场景"
        const val synchronize_lock_answer = "区别：\n" + "1、定义和使用：synchronized是java的关键字，可以作用于类、函数、对象，但lock是接口，需要线程去持有使用实现lock的对象来使用。\n" + "2、操作性：synchronized加锁和解锁都是自动进行的，易于操作，但lock（或实现接口的reentrantlock）都需要手动上锁解锁，最好还要配合try-finaly来使用，防止死锁\n" + "3、灵活性：最重要的，synchronized的是不可终断锁，等待锁过程是固定的，等不到就会一直等，但lock可以trylock尝试上锁，而且能够拿到锁定与否的状态(boolean=lock.trylock())，会有更多的选择，可以提高多个线程进行读操作的效率。\n" + "4、性能：如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized\n" + "\n" + "适用场景：少量线程同步适合用synchronized，大量线程适合用lock"
        const val thread_about = "线程启动、关闭、安全等"
        const val thread_about_answer = "创建线程有两种方式\n" + "\n" + "一、继承 Thread 类，扩展线程。\n" + "二、实现 Runnable 接口。\n" + "\n" + "\n" + "暂停线程的方法\n" + "\n" + "1、使用blooean标志位终止线程，让线程自己完成运行，要用volatile声明。\n" + "2、使用Interrupte方法标记停止，然后while循环和isInterrupted判断是否被中断，并添加中断逻辑。\n" + "3、是已经过时的stop方法。不推荐STOP的原因：线程被杀掉，马上被别的线程上锁，数据写还一半就被别的线程上锁，连清理的机会都没有，拿到异常数据，一定会出问题。\n" + "\n" + "\n" + "线程安全\n" + "\n" + "线程安全问题主要围绕三个特性\n" + "1是原子性，也可以理解成相关操作不会被中途被其他线程干扰，可以通过synchronized或使用lock来保证线程同步，还可以使用ThreadLocal来维护变量，也可以阻隔其他线程的干扰\n" + "2是保证内存可见性，一个线程修改了某个共享变量，其状态能立即被其他线程知晓，vollatile就可以保证可见性\n" + "3是有序性，也就是保证线程要执行的指令，不会被JVM或CUP优化重新排序，Volatile也能保证这一点。\n" + "\n" + "除此之外，像synchronized和lock的适用场景也要区分好，wait/notify方法的使用时机等也要注意\n" + "\n"+"线程有哪些状态：New、Runnable、Running、Blocked、Dead。\n" + "\n"
        const val thread_local="ThreadLocal原理"
        const val thread_local_answer = "ThreadLocal是一个关于创建线程局部变量的类。使用场景如下所示：\n" + "\n" + "* 有助于线程安全，因为每个线程都会有一个对应的实例。承载一些线程相关的数据，避免在方法中来回传递参数。\u2028\n" + "* 实现单个线程单例以及单个线程上下文信息存储，比如交易id等。\n" + "\n" + "\n" + "什么是ThreadLocal\n" + "\n" + "ThreadLocal 是 Thread 的共享变量。有助于线程安全，因为每个线程都会有一个对应的实例。承载一些线程相关的数据，避免在方法中来回传递参数，或加synchronized上锁那么麻烦。\n" + "\n" + "\n" + "ThreadLocal的原理\n" + "\n" + "ThreadLocal中有一个ThreadLocalMap中有一个table数组，元素是Entry。根据ThreadLocal(需要转换获取到Hash Key)能get到对应的Enrty。\u2028 Entry中key为ThreadLocal, value就是存储的数值。\n"
        const val sleep_wait = "sleep、wait、notify、notifyAll区别"
        const val sleep_wait_answer = "sleep、wait最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。\n" + "\n" + "1. sleep是Thread类的静态方法,wait是Object类中定义的方法\n" + "2. Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁,而wait 会释放当前线程锁\n" + "3. Thread.sleep需要设定休眠时间.Object.wait也可以设定wait时间,或者通过线程执行notify/notifyAll进行唤醒\n\nnotify与notifyAll\n\n1. notify唤醒一个线程,如果有多线程在wait,可能是随机一个\n" + "\n" + "2. notifyAll唤醒所有在等待的线程,\n" + "\n" + "3. 使用中尽量使用notifyAll,因为notify容易导致线程死锁(nofity只唤醒一个,其他等待的线程没有唤醒)"
        const val version_features = "android版本特性"
        const val version_features_answer = "6.0增加运行时权限\n" + "7.0分屏多任务、夜间模式\n" + "8.0画中画android:supportsPictureInPicture=ture，调用接口、指纹手势\n" + "9.0“刘海”屏幕支持，可以通过windowInsets.getDisplayCutout()、增加ImageDecoder替换BitmapFactory，代码更优雅\n" + "\n" + "//裁剪图像\n" + "imageDecoder.setCrop();\n" + "//调整大小\n" + " imageDecoder.setResize();\n" + "\n" + "10支持可折叠设备、5G 网络\n"
        const val handler_thread = "HandlerThread"
        const val handler_thread_answer = "HandlerThread继承自Thread，因此HandlerThread其实就是一个线程。他和优点就是，HandlerThread的run方法里就调用了Looper.preper()，和looper.loop()方法，为我们创建好了消息Looper.可以直接拿来用。使用场景就是，在子线程中执行耗时的、可能有多个任务的操作。比如说多个网络请求操作，或者多文件 I/O 等等。使用 HandlerThread 的典型例子就是 IntentService\n" + "\n" + "\n" + "HandlerThread handlerThread = new HandlerThread(\"handlerThread\");\n" + "handlerThread.start(); \n" + "\n" + "创建Handler\n" + "Handler mCheckMsgHandler = new Handler(mHandlerThread.getLooper()){\n" + "     @Override\n" + "     public void handleMessage(Message msg){\n" + "         // 进行耗时操作\n" + "     }\n" + "};"
        const val invalidate = "postInvalidate和Invalidate的区别"
        const val invalidate_answer = "一般来说，如果View确定自身不再适合当前区域，比如说它的LayoutParams发生了改变，需要父布局对其进行重新测量、布局、绘制这三个流程，往往使用requestLayout。而invalidate则是刷新当前View，使当前View进行重绘，不会进行测量、布局流程，因此如果View只需要重绘而不需要测量，布局的时候，使用invalidate方法往往比requestLayout方法更高效\n" + "\n" + "postInvalidate\n" + "这个方法与invalidate方法的作用是一样的，都是使View树重绘，但两者的使用条件不同，postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。"
        const val app_start = "APP启动过程及优化"
        const val app_start_answer = "启动过程：\n" + "1、Launcher响应用户点击，通知AMS，需要启动一个应用\n" + "2、AMS响应Launcher进程请求，新建一个Task去准备启动Activity，并通知Launcher要进入Paused状态\n" + "3、Launcher收到通知会挂起，并通知AMS，已就绪\n" + "4、AMS通过Socket去和Zygote通信，由Zygote.fock创建新的进程，并导入ActivityThread类\n" + "5、进程创建好了，会执行 ActivityThread 类的 main 方法，这是应用程序的入口。Application的创建也是在这个main()方法中（反射），\n" + "6、因为四大组建的启动都需要AMS去启动，还需要将上述的应用进程信息注册到AMS中，AMS 保存应用进程的一个代理对象，然后 AMS通过代理对象通知应用进程创建入口 Activity 的实例，并执行它的生命周期函数\n" + "\n" + "ActivityManagerService：（AMS）AMS是Android中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。\n" + "\n" + "ActivityThread：应用的入口类，通过调用main方法，开启消息循环队列。ActivityThread所在的线程被称为主线程；\n" + "\n" + "ApplicationThread：ApplicationThread提供Binder通讯接口，AMS则通过代理调用此App进程的本地方法\n" + "\n" + "Application：通过反射的方式创建了一个Application对象，并且调用了Appliction的attach()方法，而attach方法又调用了attachBaseContext方法，现在应该明白为什么该方法在Application的onCreate之前调用了。\n" + "\n" + "\n" + "计算启动时间\n" + "\n" + "1、本地调试的话，直接一个命令就可以了，adb shell am start -W com.example.kotlin/com.example.kotlin.activity.MainActivity，其中有个TotalTime 表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，本地用这个就可以了。\n" + "\n" + "2、统计线上应用的话，就需要打点了，起始时间点比较容易记录：\n" + "\n" + "\t冷启动的话在Application.attachBaseContext() 开始的位置记录就可以，因为在这之前 Context 还没有初始化， App 的具体业务逻辑还没开始执行。\n" + "\n" + "\t热启动启动时间点可以在 Activity.onRestart() 中记录起始时间点。\n" + "\n" + "2.结束时间点可以在 Activity.onWindowFocusChanged 记录应用启动的结束时间点，从onWindowFocusChanged被执行起，用户可以与应用进行交互了，真正的visible时间点。如果后面有焦点变化，也会调这个方法，需要区分好。\n" + "\n" + "\n" + "冷启动优化：\n" + "在application中配置一个theme，在style中定义广告页或默认图，让用户先看默认图。在Application和activity的onCreat方法中，1.耗时操作子线程中进行。2.非必要初始化懒加载。3.还有布局层次也要减少\n" + "\n" + "\n" + "方法调用顺序：\n" + "\n" + "-> Application 构造函数\n" + "\n" + "-> Application.attachBaseContext()\n" + "\n" + "-> Application.onCreate()\n" + "\n" + "-> Activity 构造函数\n" + "\n" + "-> Activity.setTheme()\n" + "\n" + "-> Activity.onCreate()\n" + "\n" + "-> Activity.onStart\n" + "\n" + "-> Activity.onResume\n" + "\n" + "-> Activity.onAttachedToWindow\n" + "\n" + "-> Activity.onWindowFocusChanged"
        const val assets_res = "Assets目录与res目录的区别"
        const val assets_res_answer = "res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即可，assets文件夹下的文件不会被映射到R文件中，访问的时候需要AssetManager类。\n" + "\n" + "res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹。"
        const val intent_service = "介绍下IntentService"
        const val intent_service_answer = "IntentService其本质上是一个Service，因为它是继承至Service，所以开启IntentService和普通的Service一致。但是他和普通的Service不同之处在于它可以处理异步任务，在任务处理完之后会自动结束。另外，我们可以启动多次IntentService，而每一个耗时任务会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且是串行执行。其实IntentService的内部是通过HandleThread和Handle来实现异步操作的。"
        const val mvp = "介绍下MVP"
        const val mvp_answer = "MVP模式分离了视图逻辑和业务逻辑，Activity只是用来相应生命周期，其他工作都丢到Presenter中完成，Presenter是Model和View之间的桥梁，为了让结构变得更加简单，View并不能直接对Model进行操作，这也是MVP与MVC最大的不同之处。"
        const val final_finally_finalize = "Java 中的 final, finally 和 finalize?"
        const val final_finally_finalize_answer = "\n" + "final：对基本类型而言，你不能改变其数值，对于引用，你不能将其指向一个新的引用，即用final关键字修饰方法，它表示该方法不能被覆盖，用final修饰的类是无法被继承的\n" + "finally：是异常处理中进行收场处理的代码块，比如关闭一个数据库连接，清理一些资源占用的问题。不管有没有异常被捕获，finally子句中的代码都会被执行。\n" + "finalize：finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，定位bug"
        const val equals_deng = " == 和 equals() 有什么区别？"
        const val equals_deng_answer = " ==用法\n" + "    1. 判断基本类型变量是否相等，且都是数值类型（不一定要求数据类型严格相同），只要两个变量的值相等，就返回true\n" + "    2. 对于两个引用类型变量，只有当他们指向同一个对象时，判断才会返回true。且不能用于比较类型上没有父子关系的两个变量\n" + "\n" + "equals用法\u2028\n" + "    equals（）是Object类提供的一个示例方法，因此所有的引用类型变量都能用它来判断是否和其他的引用类型变量相等。\n" + "    1. Object类的equals（）和==运算符几乎一样，也是要求两个引用类型变量指向同一个对象时才会返回true;\n" + "    2. string类的equals（）已经进行了重写，所以str1.euqals(str2)比较的是str1和str2的内容，而不是比较引用类型变量指向的对象\u2028此外：\n" + "\n" + "默认equals在比较两个对象时，是看他们是否指向同一个地址的。\n" + "但有时，我们希望两个对象只要是某些属性相同就认为他们的quals为true。"
        const val overloading_overriding = "重载和重写的区别"
        const val overloading_overriding_answer = "重载：方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。\n" + "\n" + "重写：是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。如果父类的方法有异常声明，那么子类重写这个方法时候，所要声明的异常不应该比父类的大。只能是小等，或者可以没有\n" + "\n" + "可否重写父类的静态方法\n" + "\n" + "静态方法，是在运行时，虚拟机已经认定此方法属于哪个类。 静态方法的调用不需要实例化， \"重写\"只能适用于实例方法.不能用于静态方法.对于静态方法,只能隐藏... "
        const val polymorphism_extends = "什么是多态？什么是继承？"
        const val polymorphism_extends_answer = "多态是：多态是同一个行为具有多个不同表现形式或形态的能力。代码上表现就是同一个接口，使用不同的实例而执行不同操作。多态存在的三个必要条件：继承、重写、父类引用指向子类对象：Parent p = new Child();\n" + "\n" + "继承是：子类继承父类的特征和行为，使得子类具有父类的各种属性和方法。\n"
        const val generic_reflection = "介绍下 泛型、反射"
        const val generic_reflection_answer = "泛型：\n" + "在集合中存储对象并在使用前进行类型转换是很不方便的，并且容易出错，为了防止这种情况，泛型产生。泛型提供了编译期的类型安全，确保我们只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException（类型转换异常）\n" + "\n" + "反射：就是动态加载一个指定的类，并获取该类中的所有的内容，比如有些第三方的JAR文件中的资源，我们没法直接调用，就可以用反射这种比较原始的方法来调用。\n" + "\n" + "1、获得Class对象，就是获取到指定的名称的字节码文件对象。\n" + "Class c = Class.forName(className);\n" + "\n" + "2、实例化对象，获得类的属性、方法或构造函数。\n" + "\u2028Field[] fields = c.getDeclaredFields();\u2028\u2028for (int i = 0; i < fields.length; i++) {\n" + "\n" + "// 打印属性的 修饰符 类型 名称\n" + "System.out.println(Modifier.toString(fields[i].getModifiers()) + \" \" + fields[i].getGenericType() + \" \"+ fields[i].getName());}\n" + "\n" + "\n" + "\n" + "3、访问属性、调用方法、调用构造函数创建对象。"
        const val join_about = "如何让线程按顺序执行"
        const val join_about_answer = "可以用线程类的join()方法，join()方法的作用，是等待这个线程结束；在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕.\n" + "\n" + "newSingleThreadExecutor()方法创建的线程池是一个基于FIFO先进先出的队列，也就是说，当我们依次将thread1，thread2，thread3加入队列中时，实际在就绪状态的只有thread1这个线程，thread2，thread3则会被添加到队列中等待，当thread1执行完毕后，则会按进入队列的先后顺序执行队列中的其他线程。"
        const val deadlock_about = "什么是死锁？死锁的四个条件，如何避免死锁"
        const val deadlock_about_answer = "死锁：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程都处于阻塞状态，无法继续。\n" + "\n" + "\n" + "四个条件\n" + "1、互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。\n" + "\n" + "2、请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n" + "\n" + "3、不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。\n" + "\n" + "4、循环等待条件:若干进程间形成首尾相接循环等待资源的关系\n" + "\n" + "\n" + "如何避免\n" + "在设计阶段就应该考虑如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。比较常用的方法：\n" + "\n" + "1、避免多次锁定。尽量避免同一个线程对多个 Lock 进行锁定。\n" + "\n" + "2、具有相同的加锁顺序。如果多个线程需要对多个 Lock 进行锁定，则应该保证它们以相同的顺序请求加锁\n" + "\n" + "3、使用定时锁。程序在调用 acquire() 方法加锁时可指定 timeout 参数，该参数指定超过 timeout 秒后会自动释放对 Lock 的锁定，这样就可以解开死锁了\n" + "\n" + "4、用算法来做死锁检测。这个了解一些，服务端可能会用到，客户端用的不多。"
        const val sum_link = "数组和链表的区别"
        const val sum_link_answer = "数组：是将元素在内存中连续存储的；它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效率比较高；它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低。\n" + "\n" + "链表：是动态申请内存空间，不需要像数组需要提前申请好内存的大小，链表只需在用的时候申请就可以，根据需要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）"
        const val array_link = "ArrayList和LinkedList的区别，以及应用场景"
        const val array_link_answer = "Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中后面的所有数据。最差情况是ON\n" + "\n" + "linkedList是基于双链表的，他的特点就是插入和删除非常快，只需要改变相邻节点的指针就可以了，但他如果用来查询就很慢了，最差情况是ON，因为他需要一个一个去找。\n" + "\n" + "除此之外像ArrayList是数组结构，所以他的起始容量是10，当数组需要增长时，就会新增一个为原来1.5倍容量的新数组，然后把原数组的数据原封不动的复制到新数组中，再把新数组赋值给原来的数组对象就完成了。所以会有空间浪费的情况\n" + "\n" + "一般情况下，LinkedList的占用空间更大，因为每个节点要维护指向前后地址的两个节点，但也不是绝对，如果刚好数据量超过ArrayList默认的临时值时，ArrayList占用的空间也是不小的，因为扩容的原因会浪费将近原来数组一半的容量\n"
        const val string_string_buffer = "介绍下String，为什么要设计成不可变的？以及StringBuffer、StringBuilder"
        const val string_string_buffer_answer = "String并不是基础类型，是final修饰的java类，之所以被设计成不可变主要是为了保证数据不被污据，方法区中的字符串池，当一个字符串已经被创建并且该字符串在池中，该字符串的引用会立即返回给变量，而不是重新创建一个字符串再将引用返回给变量。如果字符串不是不可变的，那么改变一个引用（如:string2）的字符串将会导致另一个引用（如:string1）出现脏数据。\n" + "\n" + "string不是基本数据类型，那么一个string的内存位置是什么呢？一共有两种情况：\n" + "　　1、string直接赋值：\n" + "　　　　String s = \"haha\";\n" + "　　　　s的引用存在栈内存中，引用指向的haha存在方法区的常量池中（先判断常量池中是否有一个haha，存在则直接指向）\n" + "　　2、string对象new创建\n" + "　　　　String s = new String(\"haha\");\n" + "　　　　s的引用存在于栈内存中，引用指向的haha对象，存在堆内存中（每new一次，在堆中创建一个新的haha对象）\n" + "\n" + "和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象\n" + "\n" + "StringBuffer是线程安全的，可以在多线程操作字符串\n" + "StringBuilder是非线程安全的，性能会比StringBuffer好些"
        const val thread_application = "进程和线程的区别"
        const val thread_application_answer = "首先是定义：进程是执行中的一段程序，一个应用至少有一个进程，而线程是用来执行任务的。他们之间是包含关系，一个进程中能有一个或多个线程。\n" + "\n" + "二是进程可以拥有系统分配的资源，但线程只涉及运行栈和程序计数器。\n" + "\n" + "还有就是开销上，线程要比进程小很多，主要就是这三点。\n" + "\n" + "（每当有线程被创建的时候，JVM就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。）\n"
        const val hash_map_hashtable = "HashMap与HashTable的区别"
        const val hash_map_hashtable_answer = " Hashtable 数据结构是table数组，用元素Entry来保存数据，基中的方法是Synchronize的，而HashMap是不加锁的，在多线程并发的环境下，可以直接使用Hashtable，但使用HashMap时就必须要自己增加同步处理\n" + "\n" + " Hashtable中，key和value都不允许出现null值。HashMap中key和value都可以为null\n" + "\n" + "HashMap 要比 HashTable 效率高，现在用hashtable比较少。\n\n\n jdk8以前：使用链地址法(拉链法)\n" + "从 jdk8开始，使用的是链表与红黑数转换\n" + "HashMap:\n" + "1、如果冲突数量小于等于8，则是以链表方式解决冲突。\n" + "2、而当冲突大于8时且数组size>64，就会将冲突的Entry转换为红黑树进行存储。 3.而又当数量小于6时，则又转化为链表存储。\n" + "\n" + " 而在Hashtable中， 都是以链表方式存储。 遍历方法也不一样 HashMap：iterator Hashtable：enumeration "
        const val clean_apk = "APK体积优化"
        const val clean_apk_answer = "1、使用Lint工具查找没有使用到的资源\n" + "\n" + "2、对图片进行过滤，能用.9就用.9，不能用的可以把图片进行压缩，像tinypng就挺好用的，如果可以就使用一套图就行，我一般用xxhdpi的\n" + "\n" + "3、对lib库进行精简，只保留有用的库\n" + "\n" + "4、使用proguard混淆代码"
        const val interrupt_interrupted = "interrupt(),interrupted() 和 isinterrupted() 的区别"
        const val interrupt_interrupted_answer = "interrupt方法主要作用是将线程的中断状态设置为true，如果遇到被阻塞的线程会抛出InterruptedException异常（同时中断状态为false）。\n" + "\n" + "interrupted()用来清除当前线程的中断状态，还会返回当前线程的状态，如果线程已中断，则返回true，否则返回false。而且会清除当前Thread的中断状态，置为false。\n" + "\n" + "isInterrupted是用来获取调用线程的中断状态的，但不会重置中断状态\n" + "\n" + "一般interrupt会和isInterrupted，配合while循环、try、catch一起来使用\n"
        const val thread_status = "线程有几种状态"
        const val thread_status_answer = "在 Thread 类里有一个枚举类型 State，定义了线程的几种状态，分别有：\n" + "\n" + "New: new 一个实例出来，线程就进入了初始状态。\n" + "\n" + "Runnable: 就绪状态，像调用start() 、sleep（）结束、他线程 join() 结束都会进入runnable。线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态\n" + "\n" + "Blocked： 没有获取到锁被阻塞的状态\n" + "\n" + "WAITING： 处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n" + "\n" + "TIMED_WAITING： 处于这种状态的线程不会被分配 CPU 执行时间，在达到一定时间后它们会自动唤醒。\n" + "\n" + "TERMINATED： 当线程的 run() 方法完成时，或者主线程的 main() 方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。"
        const val binder_info = "介绍下Binder机制"
        const val binder_info_answer = "有些铺垫信息，我先讲下，我们开发的应用程序所运行的空间可以叫用户空间，Linux 内核的运行空间叫内核空间，为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。\n" + "\n" + "应用程序如果想访问内核空间，需要通过系统调用，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定\n" + "\n" + "如果一个用户空间想与另外一个用户空间通信，Android系统可以通过添加一个内核模块运行在内核空间，也就是（Loadable Kernel Module，LKM），用户进程之间的通过这个模块作为桥梁，就可以完成通信了。这个内核模块叫做 Binder 驱动;\n" + "\n" + "还有个ServerManager需要讲下，他是个进程，它里面维护了一张表，表里面存储的是向他注册过的进程信息。也可以简单的理解成像一个电话本，我们要和别人打电话时，一定要有电话号码。所以，服务端需要先在ServerManager中去注册信息。\n" + "\n" + "客户端进程就会通过Binder驱动向ServerManger查询服务端进程的信息，ServerManage就会将服务端进程的信息返回给客户端进程，客户端与服务端进程之间就可以通过这些信息，利用Binder驱动来进行通信了；\n" + "\n" + "所以，总结来说，Binder通信机制分三步：\n" + "第一步：ServerManager在其内部维护一张表；\u2028\n" + "第二步：服务端进程向ServerManager注册信息；\n" + "第三步：客户端进程向ServerManager取得信息，通过Binder驱动与服务端进程通信；\n" + "\n" + "（1）通常意义上来说，Binder就是指Andriod的通信机制；\n" + "（2）对于服务端进程来说，Binder指的是Binder本地对象，对于客户端进程来说，Binder指的是Binder代理对象。\n" + "（3）对于传输过程来说，Binder是可以进行跨进程传递的对象；"
        const val reverse_list = "算法反转链表"
        const val reverse_list_answer = "class Solution {\n" + "    public ListNode reverseList(ListNode head) {\n" + "        if(head == null||head.next == null){\n" + "            return head;\n" + "        }\n" + "        ListNode cur = reverseList(head.next);\n" + "        head.next.next = head;\n" + "        head.next = null;\n" + "        return cur;\n" + "    }\n" + "}\n" + "\n" + "链表反转是用递归来实现，共有六步\n" + "第1步写方法reverseList，传入节点head，返回节点ListNode\n" + " public ListNode reverseList(ListNode head)\n" + "\n" + "第2步：先做一层判断，触发终止时结束递归，并返回最后的节点head\n" + " if(head == null||head.next == null){\n" + "            return head;\n" + "  }\n" + "\n" + "第3步：然后创建一个要返回的节点，递归调用reverseList，传入下一个head.next，这里假设传1-2-3-4-5，那这一步会递归的执行5回\n" + " ListNode cur = reverseList(head.next);\n" + "\n" + "/** 从这步向下的三行代码，递归传入的会一轮一轮反执行回来 */\n" + "\n" + "第4步：比如4的next 是5，那4的next的next等于4，意思是让5指向4\n" + "head.next.next = head;\n" + "\n" + "第5步：现在head已经是4了，5已经指向4了，要把4指向5的置null\n" + "head.next = null;\n" + "\n" + "第6步：返回节点cur\n" + "return cur;\n" + "\n" + "\n" + "时间复杂度：O(n)其中 n是链表的长度。需要遍历链表一次。\n" + "空间复杂度：O(1)反转指针而已"
        const val has_cycle = "链表是否有环"
        const val has_cycle_answer = "public class Solution {\n" + "    public boolean hasCycle(ListNode head) {\n" + "        ListNode slow = head,fast = slow;\n" + "        while(true){\n" + "            if(fast == null||fast.next == null){\n" + "                return false;\n" + "            }\n" + "            slow = slow.next;\n" + "            fast = fast.next.next;\n" + "            if(slow == fast) return true;\n" + "        }\n" + "    }\n" + "}\n" + "\n" + "判断链表是否有环，核心思想是创建一快一慢两个指针，慢的走1步，快的走2步，然后在while循环中两个一起向前走，如果两节点相待了，那就说明有环，否则就没有。共有六步\n" + "\n" + "第一步：创建方法hasCycle，参数为节点head，返回值为boolean\n" + "public boolean hasCycle(ListNode head)\n" + "\n" + "第二步：创建一慢一快两指针，slow等于节点，fast等于slow\n" + "ListNode slow = head,fast = slow;\n" + "\n" + "第三步：写一个while循环，条件是true，一直跑\n" + "while(true){\n" + "\n" + "第四步：如果fast全等于null，或fast.next全等于null，说明到头了，还没有相等相遇，没有环返回false\n" + "if(fast == null||fast.next == null){\n" + "    return false;\n" + "}\n" + "\n" + "第五步：slow节点前移一步，fast节点前移两步\n" + "slow = slow.next;\n" + "fast = fast.next.next;\n" + "\n" + "第六步：判断，如果slow全等于fast，说明相遇了有环，返回true\n" + "\n" + "时间复杂度：O(N)，其中 N 是链表中的节点数\n" + "空间复杂度：O(1)，我们只使用了两个指针的额外空间。\n"
        const val merge_two_lists = "合并两个有序链表"
        const val merge_two_lists_answer = "class Solution {\n" + "    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n" + "        ListNode dum  = new ListNode(0),cur = dum;\n" + "        while(l1 !=null&&l2 !=null){\n" + "            if(l1.val<l2.val){\n" + "                cur.next = l1;\n" + "                l1 = l1.next;\n" + "            }else{\n" + "                cur.next = l2;\n" + "                l2 = l2.next;\n" + "            }\n" + "            cur = cur.next;\n" + "        }\n" + "        cur.next = l1!=null?l1:l2;\n" + "        return dum.next;\n" + "    }\n" + "}\n" + "\n" + "链表l1,l2是递增的，因此核心思想是使用双指针l1和l2通过while循环遍历两链表，根据l1.val和l2.val的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。\n" + "\n" + "第一步：创建方法mergeTwoLists，返回节点ListNode，参数是l1、l2两个节点\n" + "public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n" + "\n" + "第二步：创建伪头部dum，还需要再创建一个cur，做为移动指针\n" + "ListNode dum  = new ListNode(0),cur = dum;\n" + "\n" + "第三步：创建while循环，条件是l1不等于null并且l2也不等于null\n" + "while(l1 !=null&&l2 !=null){\n" + "\n" + "第四步：比较l1的val值与l2的val值大小，如果l1的val小，把l1添加到cur后面，l1向后移一位\n" + "if(l1.val<l2.val){\n" + "    cur.next = l1;\n" + "    l1 = l1.next;\n" + "}\n" + "\n" + "第五步：如果l2的val小，把l2添加到cur后面，l2向后移一位\n" + "else{\n" + "    cur.next = l2;\n" + "    l2 = l2.next;\n" + "}\n" + "\n" + "第六步：指针cur向后移一位\n" + "cur = cur.next;\n" + "\n" + "第七步：有一方为null结束后，看还剩下谁，把不为null的放在cur后面\n" + "cur.next = l1!=null?l1:l2;\n" + "\n" + "第八步：返回伪头部后面的链表\n" + "return dum.next;\n" + "\n" + "\n" + "时间复杂度 O(M+N)O(M+N) ： M、N分别为链表 l1 、 l2 的长度，合并操作需遍历两链表\n" + "空间复杂度 O(1) ： 节点引用 dum , cur 使用常数大小的额外空间。\n" + "\n"
        const val k_th_from_end = "链表倒数第K个节点"
        const val k_th_from_end_answer = "倒数第K个节点\n" + "\n" + "class Solution {\n" + "    public ListNode getKthFromEnd(ListNode head, int k) {\n" + "        ListNode former = head, latter = head;\n" + "        for(int i = 0; i < k; i++)}\n" + "            former = former.next;\n" + "\t}\n" + "        while(former != null) {\n" + "            former = former.next;\n" + "            latter = latter.next;\n" + "        }\n" + "        return latter;\n" + "    }\n" + "}\n" + "\n" + "核心思想：创建一前一后双指针，快的先前进K步，然后启动一个while循环，同步前进，当快的到头后，慢的就是倒数第K个节点。\n" + "\n" + "第一步：创建方法名为getKthFromEnd，返回参数为ListNode节点，参数有两个，一个是head节点，一个是相隔距离K\n" + "public ListNode getKthFromEnd(ListNode head, int k) {\n" + "\n" + "第二步：创建一前一后两个节点，都等于head\n" + "ListNode former = head, latter = head;\n" + "\n" + "第三步：创建个for循环，把前面的节点向前先移动K部\n" + "for(int i = 0; i < k; i++){\n" + "     former = former.next;\n" + "}\n" + "\n" + "第四步：创建一个while循环，条件是former不为null，然后former和latter同步前移\n" + " while(former != null) {\n" + "     former = former.next;\n" + "     latter = latter.next;\n" + " }\n" + "\n" + "第五步：返回慢的节点，也就是倒数第K个节点\n" + "return latter;\n" + "\n" + "\n" + "时间复杂度 O(N) ： N 为链表长度；总体看， former 走了 N 步， latter 走了 (N-k)步。\n" + "空间复杂度 O(1) ： 双指针 former , latter 使用常数大小的额外空间。"
        const val catch_exception = "如何捕捉异常"
        const val catch_exception_answer = "Exception分为两类：一种是CheckedException，一种是UncheckedException，如果是CheckedException，可以用try\\catch来捕捉，如果是运行时异常，可以自定义一个工具类，实现UncaughtExceptionHandler接口，然后在application中初始化，用这个工具来捕获unchecked异常。里面需要重写一个uncaughtException方法，在里面完成错误信息收集，发送错误报告等操作"
        const val ui_block = "UI卡顿原因及优化"
        const val ui_block_answer = "Android系统每隔16ms发出VSYNC垂直同步信号，不能在16ms内完成界面的渲染，那么就会出现丢帧卡顿现象。严重的话就会被用户感知到。\n" + "\n" + "\n" + "引起卡顿主要有以下几点原因\n" + "\n" + "1、主线程被阻塞\n" + "2、资源紧张，比如频繁GC引起的内存抖动，或CPU、GPU负荷过重\n" + "3、UI页面太复杂，过度绘制，导致无法在16MS内渲染完\n" + "\n" + "\n" + "UI卡顿的优化\n" + "\n" + "布局优化：\n" + "1、对大图做压缩、增加复用，使用include、ViewStub、merge标签\n" + "2、减少布局的嵌套、去除冗余的布局\n" + "3、在层级一样的情况下，可以优先选用开销更小的布局，如Linearlayout\n" + "\n" + "\n" + "如何检测\n" + "\n" + "1、可以使用android sdk带的Systrace工具，它可以抓trace文件，然后用Chrom来做分析。里面会包含每个CPU，以及图形渲染，输入事件等等内容。还会给出性能分析结果和优化建议\n" + "2、还可以通过Looper r 消息处理前后的日志输出作为检测点，计算出消息处理的耗时，如果超出16ms，说明发生了卡顿，此时就可以把UI线程的堆栈日志打印出来。"
        const val not_ui_refresh = "为什么非 UI 线程不能更新 UI"
        const val not_ui_refresh_answer = "因为一旦多线程抢着更新UI，那么界面将会乱套更新了，所以在Android中规定必须在主线程更新UI。\n" + "\n" + "他的原理是在根视图ViewRootImpl源码中的requestLayout方法中有个checkThread()方法，他在那做了个检测，如果非UI线程调用会报错。（ViewRootImpl对象是在onResume方法回调之后才创建）\n" + "\n" + "SurfaceView是一个特例。\n" + "SurfaceView是存在于独立UI线程的，它拥有surface(表面)的canvas，在绘制时，可以通过加锁和解锁来绘制，所以当界面如果更新操作时间较长，而且数据量较大的话，一般采用SurfaceView方式更新屏幕，而少用View"
        const val jump_steps = "青蛙跳台阶"
        const val jump_steps_answer = "class Solution {\n" + "    public int numWays(int n) {\n" + "        int a= 1,b=1,sum;\n" + "        for(int i = 0;i<n;i++){\n" + "            sum =(a+b)%1000000007;\n" + "            a = b;\n" + "            b = sum;\n" + "        }\n" + "        return a;\n" + "    }\n" + "}\n" + "\n" + "核心思想：此问题基本与斐波那契数列一至，只是斐波那契是从0开始，而青蛙跳台阶是从1开始，也就是求n级台阶的跳法，也就是n-1级的值。斐波那契：n = (n-1)+(n-2)\n" + "\n" + "第一步：创建方法numWays，传入N级台阶数，返回int类型，有几种跳法\n" + "public int numWays(int n) {\n" + "\n" + "第二步：初始化两级台阶的值，与辅助变量sum\n" + "int a= 1,b=1,sum;\n" + "\n" + "第三步：创建for循环，执行n次\n" + "for(int i = 0;i<n;i++){\n" + "\n" + "第四步：计算sum值，然后前进a=b，前进b=sum\n" + "sum =(a+b)%1000000007;\n" + "a = b;\n" + "b = sum;\n" + "\n" + "第五步：循环结束后，n的前一级的值，也就是a就是结果，返回\n" + "return a;\n" + "\n" + "\n" + "时间复杂度 O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。\n" + "空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。"
        const val serializable_parcelable = "Serializable和Parcelable的区别"
        const val serializable_parcelable_answer = "所谓的序列化指的是把对象转换成字节流的过程，可以保存到文件中，也可以用来网络传输数据。\n" + "反序列化既是相反的过程，可以从我们的文件中把字节流读出来，转换为对象供我们使用。\n" + "\n" + "\n" + "序列化有两个方法，一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，但在序列化的时候会产生大量的临时变量，内部会执行大量的i/o操作，效率很低。而实现Parcelable接口稍微复杂一些，但效率更高，在内存中读写，但对象不能保存到磁盘中，因为Parcelable在外界有变化的情况下不能很好的保证数据的持续性\n" + "\n" + "Parcelable用法\n" + "\n" + "1）implements Parcelable\n" + "2）实现接口中的两个方法，一个是描述内容的，返回0就行。还有个是重写writeToParcel方法，将你的对象序列化为一个Parcel对象，把属性都写入Parcel对象中\n" + "4）实例化静态内部对象CREATOR实现接口Parcelable.Creator，实例化CREATOR时要实现其中的两个方法，其中createFromParcel的功能就是从Parcel中读取我们的对象（另一个是供外部类反序列化本类数组使用）\n" + "\n" + "调用方法\n" + "\n" + "存：intent.putExtra(\"key\", new Book(\"哈\", \"鸿\", 8));\n" + "取： Book book = intent.getParcelableExtra(\"key\");"
        const val delete_node = "删除链表的节点"
        const val delete_node_answer = "删除链表的节点\n" + "\n" + "class Solution {\n" + "    public ListNode deleteNode(ListNode head, int val) {\n" + "        if(head.val == val) return head.next;\n" + "        ListNode pre = head,cur = pre.next;\n" + "        while(cur!=null&&cur.val!=val){\n" + "            pre = cur;\n" + "            cur = cur.next;\n" + "        }\n" + "        if(cur.val == val) pre.next = cur.next;\n" + "        return head;\n" + "    }\n" + "}\n" + "\n" + "核心思想：建两个指针，当前指针cur与后指针pre，启动一个while循环，条件就是当前指针不为null，并且当前指针val与目标val不等，然后当前指针前移，后继指针跟上。遇到相待的cur，把后节点指向前节点的下一位，返回haed就行了\n" + "\n" + "第一步：创建方法deleteNode，返回头部节点ListNode，参数一个是head，还有一个是目标值val。\n" + "public ListNode deleteNode(ListNode head, int val) {\n" + "\n" + "第二步：判断头部节点head与目标值val是否相待，相等直接返回head.next。\n" + "if(head.val == val)  return head.next;\n" + "\n" + "第三步：创建后节点pre等于head，前节点为pre.next。\n" + "ListNode pre = head, cur = pre.next;\n" + "\n" + "第四步：启动一个while循环，条件是前节点cur不为null，并且cur.val不等于目标val。然后后节点pre等于cur，前节点前移一步。\n" + "while(cur!=null&&cur.val!=val){\n" + "    pre = cur;\n" + "    cur = cur.next;\n" + "}\n" + "\n" + "第五步：如果前节点val等于目标val，那把后节点指向前节点的下一位\n" + "if(cur.val == val) pre.next = cur.next;\n" + "\n" + "第六步：返回头部\n" + "return head;\n" + "\n" + "\n" + "时间复杂度 O(N) ： N 为链表长度，删除操作平均需循环 N/2 次，最差 N 次。\n" + "空间复杂度 O(1) ： cur, pre 占用常数大小额外空间。"
        const val more_process = "应用内多进程"
        const val more_process_answer = "优点\n" + "1、让一个组件运行在单独的进程中，可以减少主进程所占用的内存，降低被系统杀死的概率。\n" + "2、如果子进程因为某种原因崩溃了，不会直接导致主程序的崩溃，可以降低我们程序的崩溃率。\n" + "3、即使主进程退出了，我们的子进程仍然可以继续工作\n" + "\n" + "\n" + "实现：只需要添加 android:process 的属性即可，属性名可以自定义，相同的属性名的进程在同一个里面运行。\n" + "\n" + "1 . 如果android:process的值以冒号开头的话，那么该进程就是私有进程，其他应用的组件不可以和它跑在同一个进程中。\n" + "\n" + "2 . 如果以.开头，那么就是公有进程，其他应用的组件不可以和它跑在同一个进程中。其他应用通过设置相同的ShareUID可以和它跑在同一个进程。\n" + "\n" + "ShareUserId的作用，数据共享、调用其他程序资源。在manifest里可以配置android:sharedUserId=\"com.mythou.share\"\n" + "\n" + "\n" + "多进程的问题\n" + "\n" + "问题1：Application的多次重建，会初始化两回\n" + "解决：判断是否为主进程，只有主进程的时候才执行下面的操作\n" + "String processName = this.getProcessName();\n" + "processName.equals(this.getPackageName())\n" + "\n" + "问题2：静态成员的失效，设置了process属性后，产生了两个隔离的内存空间，一个内存空间里值的修改并不会影响到另外一个内存空间。所以就算是静态成员也是两个不同的成员值。\n" + "\n" + "问题3：文件共享问题，多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等，即便上锁，排队等机制，对多进程也较难实现\n" + "解决：解决方法就是统一由主进程来处理，子进程通知主进程来操作。\n" + "\n" + "问题4：调试断点，调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试。\n" + "解决：临时去掉process标签，统一在一个进程里调试，结束后再还原标签\n"
        const val sp_about = "SharedPreFerences原理、安全性"
        const val sp_about_answer = "简介：\n" + "SharedPreFerences作为Android存储数据方式之一，只支持java基本数据类型，且在进程内数据共享\n" + "\n" + "\n" + "为什么说是轻量级存储\n" + "之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会一次性把整个文件全部加载进内存，如果SharedPreference文件比较大，会导致阻塞线程、产生大量临时对象引起GC、key和value会占用大量内存\n" + "\n" + "\n" + " 使用sharedpreferences保存key-values的步骤：\n" + "\n" + "  1）使用activity类的getSharedPreferences方法获得SharedPreference对象，\n" + "  2）使用sharedpreferences接口的edit获得Sharedpreferences.Editor对象\n" + "  3）通过sharedpreferences.editor接口的putXxx方法保存键值对，\n" + "  4）通过Sharedpreferences.editor接口的commit（）方法保存键值对\n" + "\n" + "\n" + "SharedPrefereces内部工作原理\n" + "\n" + "调用getSharedPreferences（）；创建一个SharedPreferences对象，其中会先判断是否存在对应\n" + "xml文件，如果对应的xml不存在则重新创建一个对应xml文件，如果存在则会把xml文件解析后存入一个map对象中(通过I/O流操作和xmlUtil，map为ArrayMap)。EditorImpl的putXXX方法，主要是将数据保存在一个Map中，这些数据是存储在内存中，只有调用了commit()或apply()方法之后，才会同步到磁盘中。\n" + "\n" + "\n" + "两个提交方式：\n" + "\n" + "commit会立即并同步保存数据。\n" + "apply则异步保存数据，从而提高了性能。如果你不关心它的返回类型，则apply优先于commit\n" + "\n" + "\n" + "进程是否安全\n" + "\n" + "在进程间是不安全的。原因是系统对SharedPreferences的读写有一定的缓存策略，即内存中有一份SharedPreferences文件的缓存，在多进程模式下，系统对它的读写变的不可靠，当面对高并发的读写访问，SharedPreferences很很大几率会造成数据丢失，所以，不建议在进程通信中使用SharedPreferences。\n" + "\n"
        const val merge_num = "合并两个有序数组(Arrays.sort())"
        const val merge_num_answer = "合并两个有序数组(Arrays.sort())\n" + "\n" + "class Solution {\n" + "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "        for (int i = 0; i < n; ++i) {\n" + "            nums1[m + i] = nums2[i];\n" + "        }\n" + "        Arrays.sort(nums1);\n" + "    }\n" + "}\n" + "\n" + "核心思想：将数组2内元素通过for循环添加到数组1中，再通过Arrays的sort方法，把num1进行排序\n" + "\n" + "第一步：创建方法merge，无返回参数，入参是两个数组和他们的长度\n" + "public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "\n" + "第二步：启动for循环，执行次数与数组2和长度相同\n" + "for (int i = 0; i < n; ++i) {\n" + "\n" + "第三步：循环内，在数组1后面逐个添加数组2的元素\n" + "nums1[m + i] = nums2[i];\n" + "\n" + "第四步：通过Arrays.sort()方法，把num1进行排序\n" + "Arrays.sort(nums1);\n" + "\n" + "\n" + "时间复杂度：O((m+n) log(m+n))。\n" + "排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n) log(m+n))。\n" + "\n" + "空间复杂度：O( log(m+n))。\n" + "排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O( log(m+n))。"
        const val merge_num_traverse = "合并两个有序数组（遍历）"
        const val merge_num_traverse_answer = "合并两个有序数组（遍历）\n" + "\n" + "class Solution {\n" + "    public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "        int k = m + n - 1;\n" + "        while (n > 0 && m > 0) {\n" + "            if (nums1[m - 1] < nums2[n - 1]) {\n" + "                nums1[k] = nums2[n - 1];\n" + "                n--;\n" + "            } else {\n" + "                nums1[k] = nums1[m - 1];\n" + "                m--;\n" + "            }\n" + "            k--;\n" + "        }\n" + "        for (int i = 0; i < n; i++) {\n" + "            nums1[i] = nums2[i];\n" + "        }\n" + "    }\n" + "}\n" + "\n" + "核心思想：先得到双数组之和的辅助下标k，然后再把数组1与数组2的的最后一位元素一一比较，从大到小，从后到前，反向放入nums1中。当有一组放完后，再把剩余一组，通过for循环逐个放入。\n" + "\n" + "第一步：创建方法merge，无返回参数，入参是两个数组和他们的长度\n" + "public void merge(int[] nums1, int m, int[] nums2, int n) {\n" + "\n" + "第二步：算出两数组总长的辅助下标k，为放入数组1做准备\n" + "int k = m + n - 1;\n" + "\n" + "第三步：启动个while循环，条件是m与n都大于0，开始准备遍历数组1与数组2\n" + "while (n > 0 && m > 0) {\n" + "\n" + "第四步：如果数组1最后一位小于数组2的最后一位，那把数组2的最后一位放到数组1的k下标上，并执行n--，下次比较下一位。\n" + "if (nums1[m - 1] < nums2[n - 1]) {\n" + "     nums1[k] = nums2[n - 1];\n" + "     n--;\n" + "}\n" + "\n" + "第五步：反之，则把数组1的最后一位放到数组1的k下标上，并执行m--，下次比较下一位。\n" + "else {\n" + "   nums1[k] = nums1[m - 1];\n" + "   m--;\n" + "}\n" + "\n" + "第六步：肯定有一方还有值，直接启动个for循环，把数组2的值搬过来，如果数组2没值，就跳过了。\n" + "for (int i = 0; i < n; i++) {\n" + "   nums1[i] = nums2[i];\n" + "}\n" + "\n" + "\n" + "时间复杂度：O(M + N)\n" + "空间复杂度：O(1)"
    }
}

