package com.example.kotlin.data

/**
 * Author: sym
 * Date: 2021/7/13 8:11 PM
 * Describe:
 */
 class QA{

    companion object {
        const val cache_optimization = "内存优化"
        const val cache_optimization_answer = "1、可以在Androidmanifest文件中application节点加入android:largeHeap=“true”来增加其dalvik虚拟机中堆的大小\n" + "\n" + "2、解决内存泄漏的问题，像静态引用啊、单例啊什么的\n" + "\n" + "3、对图片进行管理 ，把大图都做一遍压缩过滤，能换webp(androidstudio自带covert to webp)都换，在不失真的情况下尽量压缩，尽量用.9。\n" + "\n" + "4、 修改对象引用类型，增强GC收回的效率\n" + "\n" + "5、其他还有些细节，比如增加复用，减少不必要的全局变量，少用枚举啊等等"
        const val cache_big = "扩大内存"
        const val cache_big_answer ="Android为每个进程分配内存时，采用弹性的分配方式，即刚开始并不会给应用分配很多的内存，而是给每一个进程分配一个“够用”的内存大小。\n" + "\n" + "ActivityManager的getLargeMemoryClass()可以获得开启largeHeap最大的内存大小\n" + "通过ActivityManager的MemoryInfo，可以获取到应用最大使用内存大小getLargeMemoryClass()\n" + "\n" + "\n" + "1、创建一个新的进程，那么我们就可以把一些对象分配到新进程的heap上了，从而达到一个应用程序使用更多的内存的目的，建议把一些高消耗但不常用的模块放到独立的进程，不使用的进程可及时手动关闭；void killBackgroundProcesses(String packageName)\n" + "\n" + "2、可以在Androidmanifest文件中application节点加入android:largeHeap=“true”来增加其dalvik虚拟机中堆的大小。开子进程，分担内存"
        const val performance_optimization = "性能优化"
        const val performance_optimization_answer = "性能优化：Android的性能优化，主要是从以下几个方面进行优化的：\n" + " \n" + "一是稳定性，是否有内存溢出、崩溃的情况\n" + "\n" + "二是流畅性，有没有卡顿，冷启动时间长不长\n" + "\n" + "三是耗损是否严重，耗电、流量多不多啊\n" + "\n" + "四是安装包体积等，有没有冗余可优化空间 \n\n\n内存优化\n1.使用leakcanery先解决程序中内存占用较大的业务模块中的内存泄漏\n" + "2.移除程序中多余的代码和引用，这里使用默认的lint检测再配合shrinkResources来删除无效资源\n" + "3.优化图片，保证图片放置在合理的文件夹，根据View大小加载合适的图片大小，根据手机状态配置bitmap和回收策略\n" + "4.优化对象创建，比如string，使用对象池等\n\nAndroid官方对象池的简单实现：SimplePool，也是用得最多的实现\n" + "原理：使用了“懒加载”的思想。当SimplePool初始化时，不会生成N个T类型的对象存放在对象池中。而是当每次外部调用release()时，才把释放的T类型对象存放在对象池中。要先放入，才能取出来。   这样就避免了内存抖动。\n\nMemory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。\n" + "瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。\n"
        const val tcp_shake_hands = "Tcp握手过程"
        const val tcp_shake_hands_answer = "TCP三次握手：\n" + "\n" + "1：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；\n" + "\n" + "2：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n" + "\n" + "3：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n" + "\n" + "四次挥手：\n" + "1、主动关闭方会发一个长度为0的数据包以及FIN关闭标识。\n" + "\n" + "2、被动方收到FIN后，会发一个ACK确认包，确认序号+1。\n" + "\n" + "3、确认无需要发送数据后，被动关闭方也会发一个FIN包，告诉主动关闭方，我也不会再发数据了。\n" + "\n" + "4主动关闭方发ACK确认，确认序号+1。\n\n" + "两次不行，为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。\n" + "\n" + "确认号要加1，因为报文不一定会按发送的时序到达目标，为了区分所以要加1\n" + "\n" + "出现大量的close_wait是因为被动关闭方没有发送FIN包确认关闭，是程序的问题。\n" + "如果是server主动关闭链接,那么Client则有可能进入CLOSE_WAIT,如果Client不发送FIN包，该关不关,那么client就一直会处在CLOSE_WAIT状态\n" + "\n" + "为什么是4次握手，因为被动方收到FIN后，需要先确认，防止主动方因等待时间过长再发FIN，被动方处理完数据后再发FIN"
        const val draw_view = "自定义View的流程"
        const val draw_view_answer = "介绍下实现一个自定义View的基本流程\n" + "①.自定义View的属性 编写attr.xml文件 ②.在layout布局文件中引用，同时引用命名空间 ③.在View的构造方法中获得我们自定义的属性 ，在自定义控件中进行读取（构造方法拿到attr.xml文件值） ④.重写onMesure 、onDraw    如果有需要还可以重写onTouchEvent"
        const val synchronized_lock_diff = "synchronized和Lock的区别、适用场景"
        const val synchronized_lock_diff_answer = "区别：\n" + "1、定义和使用：synchronized是java的关键字，可以作用于类、函数、对象，但lock是接口，需要线程去持有使用实现lock的对象来使用。\n" + "\n" + "2、操作性：synchronized加锁和解锁都是自动进行的，易于操作，但lock（或实现接口的reentrantlock）都需要手动上锁解锁，最好还要配合try-finaly来使用，防止死锁\n" + "\n" + "3、灵活性：最重要的，synchronized的是不可终断锁，等待锁过程是固定的，等不到就会一直等，但lock可以trylock尝试上锁，而且能够拿到锁定与否的状态(boolean=lock.trylock())，会有更多的选择，可以提高多个线程进行读操作的效率。\n" + "\n" + "4、性能：如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized\n" + "\n" + "\n" + "适用场景：少量线程同步适合用synchronized，大量线程适合用lock"
        const val true_lock = "实锁的种类"
        const val true_lock_answer = "1、synchronized\n" + "\n" + "2、lock  lock里又可以细分ReentrantLock、ReentrantReadWriteLock是一个读写锁，如果读的线程比写的线程要多很多的话，那可以考虑使用它。它使用state的变量高16位是读锁，低16位是写锁\n" + "\n" + "3、ReadWriteLock读写锁，需要读和写是互斥的，写和写是互斥的，但是读和读是不需要互斥的\n" + "\n" + "ReadWriteLock rwl = new ReentrantReadWriteLock();\n" + "rwl.writeLock().lock();// 取到写锁  \n" + "rwl.writeLock().unlock();// 释放写锁\n" + "rwl.readLock().lock();// 取到读锁 \n" + "rwl.readLock().unlock();// 释放读锁"
        const val false_lock = "虚锁的种类"
        const val false_lock_answer = "有很多并不是指实际的锁，是根据锁的特性起的名字，比如公平锁、可重入锁、独享锁、乐观锁、自旋锁之类的\n" + "\n" + "1、公平锁：先来先得，按顺利获得锁。非公平锁：有可能后申请的线程比先申请的线程优先获取锁，随机性.ReentrantLock 默认采用非公平锁，除非在构造方法中传入参数 true 。\n" + "\n" + "public ReentrantLock(boolean fair) \n" + "\n" + "2、可重入锁：递归锁也算。同一个线程在进入内层方法会自动获取锁，可重入锁的一个好处是可一定程度避免死锁。场景：一个synchronized方法需要调用另一个synchronized方法时。\n" + "\n" + "3、 独享锁/共享锁：独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。\n" + "\n" + "4、乐观锁/悲观锁：乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度，悲观锁：悲观的认为，不加锁的并发操作一定会出问题。乐观锁：乐观的认为，不加锁的并发操作是没有事情的\n" + "\n" + "5、分段锁\n" + "分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。\n" + "\n" + "6、偏向锁/轻量级锁/重量级锁\n" + "这三种锁是指锁的状态，并且是针对Synchronized\n" + "\n" + "偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。\n" + "\n" + "轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。\n" + "\n" + "重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。\u2028\n" + "7、自旋锁\n" + "自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。\n"
        const val twice_lock = "可重入锁"
        const val twice_lock_answer = "在JAVA环境下ReentrantLock和synchronized都是可重入锁。\n" + "\n" + "synchronized是一个可重入锁。在一个类中，如果synchronized方法1调用了synchronized方法2，方法2是可以正常执行的，这说明synchronized是可重入锁。否则，在执行方法2想获取锁的时候，该锁已经在执行方法1时获取了，那么方法2将永远得不到执行。\n" + "\n" + "可重入锁主要用在线程需要多次进入临界区代码时，需要使用可重入锁。具体的例子，比如上文中提到的一个synchronized方法需要调用另一个synchronized方法时。"
        const val four_components = "四大组件"
        const val four_components_answer = "Activity【活动】：用于表现功能。 \n" + "Service【服务】：后台运行服务，不提供界面呈现。 \n" + "BroadcastReceiver【广播接收器】：用来接收广播。 \n" + "Content Provider【内容提供商】：支持在多个应用中存储和读取数据，相当于数据库。\n"
        const val activity_life = "Activity生命周期及跳转"
        const val activity_life_answer = "onCreate:create表示创建\n" + "onStart:start表示启动\n" + "onResume:resume表示继续、重新开始\n" + "onPause:pause表示暂停\n" + "onStop：stop表示停止\n" + "onDestroy：destroy表示销毁\n" + "onRestart：restart表示重新开始\n" + "\n" + "当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume，最后才执行A的onStop!!!\n" + "\n" + "当B按下返回键，B先执行onPause，然后是A再执行onRestart -> onStart -> onResume，最后才是B执行onStop  -> onDestroy\n" + "\n" + "如果B是dialog或透明的，A只会执行onPause，不会执行onStop。当A跳转到B的时候，A先执行onPause，然后居然是B再执行onCreate -> onStart -> onResume。（注意：A的 onStop 不会执行）\n" + "\n" + "当B按下返回键，B先执行onPause，然后是A只会执行 onResume，最后 B 执行onStop  -> onDestroy。\n\n Activity弹出 Dialog 对生命周期\n" + "生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响"
        const val android_configChanges = "activity横纵向切换，或页面发生改变时"
        const val android_configChanges_answer = "程序在运行时，一些设备的配置可能会发生改变，如：横竖屏切换、键盘的可用性等这样的事情发生的时候，activity在没有配置android:configChanges属性时会重新启动\n" + "生命周期：onSaveInstanceState-->onPause-->onStop-->onDestroy-->onCreate-->onStart-->onRestoreInstanceState-->onResume\n" + "\n" + "但如果给configChanges配置了orientation|keyboardHidden|screenSize这些属性后，再发生屏幕改变会调用onConfigurationChanged方法，我们可以通过Configuration里的orientation属性判断是横向还是纵向。\n" +"\n"+"onNewIntent 什么时候调用\n"+"如果此次启动不创建该Activity的新实例,则系统会调用原有实例的onNewIntent()方法来处理此intent"
        const val fragment_life = "fragment生命周期"
        const val fragment_life_answer = "onAttach() 在Fragment 和 Activity 建立关联是调用（Activity 传递到此方法内）\n" + "\n" + "onCreate()\n" + "\n" + "onCreateView() 当Fragment 创建视图时调用\n" + "\n" + "onActivityCreated() 在相关联的 Activity 的 onCreate() 方法已返回时调用。\n" + "\n" + "onStart() ：Fragment对用户可见的时候调用，前提是Activity已经started。\n" + "\n" + "onResume()：Fragment和用户之前可交互时会调用，前提是Activity已经resumed。\n" + "\n" + "onPause()：Fragment和用户之前不可交互时会调用。\n" + "\n" + "onStop()：Fragment不可见时会调用。\n" + "\n" + "onDestroyView() 当Fragment中的视图被移除时调用\n" + "\n" + "onDestroy()\n" + "\n" + "onDetach() 当Fragment 和 Activity 取消关联时调用。"
        const val fragment_life_change = "fragment切换时生命周期的变化"
        const val fragment_life_change_answer = "1、用replace替换后Fragment都是销毁重新创建的,生命周期全走。加了回退栈的，只是销毁视图onDestroyView() -> 重新创建视图onCreateView()。这种方法会消耗流量和性能\n" + "\n" + "2、add hide show------onHiddenChange()，使用hide() show()方法切换fragment 不会走任何的生命周期 无法通过生命周期进行刷新，需要监听onHiddenChanged方法，来判断fragment显示与否。add 与 remove，会走正常创建与销毁周期。"
        const val service_create = "service两种启动方式"
        const val service_create_answer = "两种启动方式：\n" + "\n" + "通过StartService启动Service：startService(new Intent(this, NormalService.class));\n" + "\n" + "通过bingService启动Service:bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);"
        const val service_two_create_diff = "两种启动的区别"
        const val service_two_create_diff_answer = "主要是生命周期不同\n" + "\n" + "startService一旦服务开启跟开启者就没有任何关系\n" + "\n" + "而bindService可以通过unBindService来停掉Service。而且调用者挂了，服务也会跟着挂掉。"
        const val service_life = "Service生命周期"
        const val service_life_answer = "startService方式\n" + "onCreate()：创建  \n" + "onStartCommand()：运行\n" + "onDestroy() ：停止\n" + "\n" + "bindService方式\n" + "onCreate()：创建\n" + "onBind()：运行\n" + "onUnbind()：取消绑定 \n" + "onDestroy() ：停止"
        const val service_stop = "如何停止service"
        const val service_stop_answer = "终止的话使用stopSelf()或stopService(intent)\n" + "\n" + "混合启动如何停止：同时使用 startService 与 bindService Service 的终止，需要unbindService与stopService同时调用，才能终止 Service。不管 startService 与 bindService 的调用顺序"
        const val service_activity_info = "activity与service通信"
        const val service_activity_info_answer = "一、通过Intent，startService（intent）来启动Service，在intent中放入数据，在Service的onStartCommant()中接收通过intent传过来的值。（性能差）\n" + "\n" + "二、binder+回调\n" + "在Activity中实现ServiceConnection，在onServiceConnected()中获取Service的实例，通过这个实例就能调用Service的方法和变量了。通过回调可以将Service主动将变化通知Activity。\n" + "\n" + "三、Broadcase方式\n" + "在Service中需要通知更新UI的地方，发送广播，在Activity中注册广播，在BroadcaseRecever中接受广播，更新UI。\n" + "\n" + "四、EventBus"
        const val activity_launchMode = "Activity启动模式"
        const val activity_launchMode_answer = "standard 模式:这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。\n" + "\n" + "singleTop 模式:如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的\n" + "\n" + "singleTask 模式:如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建\n" + "\n" + "singleInstance 模式：在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再启动该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。"
        const val activity_task = "如何理解Task栈？"
        const val activity_task_answer = "Android平台设计了一种堆栈机制用于管理Activity，也就是Task,它遵循先进后出的原则，系统总是显示位于栈 顶的Activity，从逻辑上将，位于栈顶的Activity也就是最后打开的Activity"
        const val activity_launchMode_how = "如何设置启动方式 "
        const val activity_launchMode_how_answer = "1、设置启动模式的位置在 AndroidManifest.xml 文件中 Activity 元素的 Android:launchMode 属性。\n" + "\n" + "2、通过intent跳转时，给intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)"
        const val activity_launchMode_question = "SingleInstance在中间会遇到的问题"
        const val activity_launchMode_question_answer = "第一种情况：因为栈不同A开启B，B开启C，如果finish C，那么A会显示而不是我们想要的B。可以通过记录开启activity，在被关闭的activity的finish方法中重新开启activityB。\n" + "\n" + "第二种情况：A开启B，然后按home键，再开应用，显示的是A，这是因为launch启动我们应用的时候 会从默认的栈找到栈顶的activity显示，这个解决办法的思路跟第一种差不多\n" + "\n" + "第三种情况：A开启C，C开启B，B开启A，结果显示的是C，这还是两个栈造成的，B开启A的时候，其实是到达A所处的栈，栈顶是C，所以就显示C了，解决办法是用flag把默认栈activity清理了，重新开启A，或者回退到C时再开启A。"
        const val http_https = "Http与Https的区别"
        const val http_https_answer = "主要有3点不同\n" + "1、安全性：HTTPS不是明文传输的，会通过SSL数据加密、TLS验证身份，以及数据完整性保护（收方或非法者不能伪造、篡改报文，运营商加广告）而HTTP是明文传输无状态的（比较独立，服务器与客户端都不会记录信息），所以安全性要高于HTTP\n" + "2、HTTPS需要申请CA证书，而HTTP不需要\n" + "3、用的端口也不一样，HTTP是80，HTTPS是443"
        const val jvm_model = "JVM模型"
        const val jvm_model_answer = "虚拟机栈\n" + "Java 方法执行的内存模型，每个方法执行的时候，都会创建一个栈帧用于保存局部变量表，操作数栈，动态链接，方法出口信息等。一个方法调用的过程就是一个栈帧从 VM 栈入栈到出栈的过程。VM 栈主要用于存储方法包含的信息如，基本数据类型、局部变量等，VM 栈也是线程私有的\n" + "\n" + "堆区\n" + "所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象都在这分配内存。Java 堆是线程共享的。\n" + "\n" + "方法区\n" + "存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。这部分区域包含「运行时常量池」，所以这个区域主要存储常量。方法区是线程共享的\\n\"\n" + "\n" + "本地方法栈\n" + "执行 Native 方法的栈，与 VM 栈发挥的作用非常相似，VM 栈执行Java 方法（字节码）服务，Native 方法栈执行的是 Native 方法服务。Native 栈也是线程私有的\n" + "\n" + "程序计数器\n" + "一块较小的内存空间，是字节码解释器的行为指示器。程序执行的过程中会有分支、循环、跳转、异常处理、线程恢复等基础功能，也就是程序运行碰到了关键字或特殊行为，字节码解释器就需要进行特殊处理，而字节码需要怎么做正是由程序计数器去通知。程序计数器是线程私有的"
        const val jvm_gc_root = "GC root 对象"
        const val jvm_gc_root_answer = "1.虚拟机栈(栈帧中的本地变量表)中引用的对象\n" + "2.方法区中类静态属性引用的对象\n" + "3.方法区中常量引用的对象\n" + "4.本地方法栈中 JNI(一般说的 Native 方法)引用的对象"
        const val volatile_features = "volatile特性"
        const val volatile_features_answer = "Volatile关键字可以修饰变量，用于多线程的访问。它能保证内存的可见性和有序性，但不能保证原子性\n" + "\n" + "内存可见性：如果对变量加上volatile关键字修饰的话，它可以保证当有线程对变量值做了变动之后，会立即刷回到主内存中，所有线程都能读到相同的值\n" + "\n" + "有序性：JVM为了保证执行上的效率，可能会对指令进行重排序，而加上volatile关键字修饰后，在指令间插入一个屏障点，就告诉JVM和CPU，不能进行重排优化。其实volatile有序性是通过内存屏障实现的\n" + "\n" + "不保证原子性：有个例子，1000个线程同时去对被volatile修饰过的变量进行+1操作，但值确肯定不是1000，也就是说volatile并不能保证一个线程执行完，另一个线程才开始执行，不能保证操作并不是不可分割的。"
        const val synchronize_principle = "synchronized原理"
        const val synchronize_principle_answer = "在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。所有锁都是存储在 Java 对象头里的。jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。\n" + "\n" + "如果是方法级的同步，JVM会从方法表结构 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。如果是的话，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。\n" + "\n" + "代码块的同步是利用 monitorenter 和 monitorexit 这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当 jvm 执行到 monitorenter 指令时，当前线程试图获取 monitor 对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器 + 1；当执行 monitorexit 指令时，锁计数器 - 1；当锁计数器为 0 时，该锁就被释放了。如果获取 monitor 对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。"
        const val volatile_synchronize_different = "volatile与synchronized区别"
        const val volatile_synchronize_different_answer = "1、volatile本质上是直接从主内存中读取值，无法保证同步\n" + "\n" + "2、volatile只能实现变量的修改可见性，并不能保证原子性；而synchronizedl则因为能保证线程安全，可以保证变量的修改可见性和原子性。\n" + "\n" + "3、volatile只能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。\n" + "\n" + "4、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。"
        const val synchronize_range = "锁的作用范围"
        const val synchronize_range_answer = "作用在方法上：\n" + "\n" + "实例方法：被锁的是该类实例对象\n" + "public synchronized void method(){}\n" + "\n" + "表态方法：锁住的是类的所有对象\n" + "public static synchronized void method(){}\n" + "\n" + "\n" + "\n" + "作用在代码块上：\n" + "\n" + "实例对象：被锁的是类的实例对象\n" + "synchronized(this){}\n" + "\n" + "Class对象：被锁的是类的所有对象\n" + "synchronized(Demo.class){}\n" + "\n" + "任意实例对象Object\n" + "String a = “”;\n" + "synchronized(a){}\n" + "\n" + "\n" + "总结下，除了静态方法和锁class，其他的都是作用在实例上。"
        const val handler_four_components= "Handler四大组件"
        const val handler_four_components_answer = "Message\n" + "Message是在线程之间传递的消息，它可以在内部携带信息，用于在不同线程之间交换数据。\n" + "\n" + "Handler\n" + "处理者，它主要用来发送和处理消息。发送消息一般是使用Handler的sendMessage()方法，消息经过处理后，最终传递到Handler的handlerMessage()方法中。\n" + "\n" + "MessageQueue\n" + "消息队列，它主要用来存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理。每个线程只有一个Messgequeue\n" + "\n" + "Looper\n" + "是每个线程中MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，每当发现MessageQueue中存在一条消息，就会将其取出传递到Handler的handleMessage()方法当中。注意：每个线程中只会有一个Looper对象。"
        const val handler_use = "Handler的使用"
        const val handler_use_answer = "Handler异步消息处理流程：\n" + "首先在UI线程我们创建了一个Handler实例对象，重写handleMessage方法，我们可以通过这个方法的参数msg来实现接受消息过后Ui线程的逻辑处理。\n" + "\n" + "在子线程中需要更新UI的时候，可以通过obtain获取一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理。\n" + "\n" + "Looper会不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法 "
        const val handler_child_create = "子线程中创建handler"
        const val handler_child_create_answer = "子线程中创建Handler的方法：需要调用Looper.prepare()创建一个looper,并调用looper.loop来启动循环\n" + "\n" + "一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？\n" + "一个Thread只能有一个Looper，一个MessageQueen，可以有多个Handler。\n" + "\n" + "以一个线程为基准，他们的数量级关系是：Thread(1) : Looper(1) : MessageQueue(1) : Handler(N)。"
        const val what_anr = "ANR是什么"
        const val what_anr_answer = "ANR就是ApplicationNotResponding，应用无响应：\n" + "\n" + "当操作在一段时间内系统无法处理时，会在系统层面会弹出ANR对话框\n" + "\n" + "产生ANR可能是因为5s内无响应用户输入事件、10s内未结束BroadcastReceiver、20s内未结束Service\n" + "\n" + "想要避免ANR就不要在主线程做耗时操作，而是通过开子线程，具体方法比如使用Thread或Runnable接口、还有像AsyncTask、IntentService、HandlerThread都可以"
        const val watching_anr = "如何监控ANR"
        const val watching_anr_answer = "可以通过命令，把/data/anr/trace（吹西死）文件pull到当前目录下，无需root权限即可获取，Input dispatching timed out\n" + "\n" + "或是通过继承FileObserver，来监测data/anr目录下文件的变化，但这种方式兼容性比较差，需要root获取系统权限，开发测试阶段还是很好用的\n" + "\n" + "还有一种是，ANR-WatchDog是参考Android WatchDog机制，起个单独线程向主线程发送一个变量+1操作，自我休眠，休眠过后判断变量是否+1完成，如果未完成则告警。但也无法保证能捕捉所有ANR，比如我的休眠时间和系统时间正好错过，我还没记录你已经报错退出了 ，那就无法捕捉。\n" + "\n" + "还有blockcanary我看网上说可以捕捉一部分，但我觉得应该也有它的局限性。主要就这几种吧，还是推荐FileObserver配合WatchDog混合使用。"
        const val solve_anr = "怎么解决ANR"
        const val solve_anr_answer = "想要避免ANR就不要在主线程做耗时操作，可以通过开子线程来完成，具体方法比如使用Thread或Runnable接口、还有像AsyncTask、IntentService、HandlerThread都可以"
        const val block_canary_principle = "BlockCanary原理"
        const val block_canary_principle_answer = "blockcanary利用了主线程的消息队列处理机制\n" + "\n" + "通过就是Looper里setMessageLogging自定义一个 Printer，来获取主线程dispatch这个message的开始和结束时间\n" + "\n" + "并判定该时间超过阈值(如2000毫秒)为主线程卡慢发生，并dump出各种信息，提供开发者分析性能瓶颈。"
        const val touch_event = "事件分发流程"
        const val touch_event_answer = "Android的UI界面由Activity、ViewGroup、View 及其派生类组成，1个点击事件发生后，如果我们没有对控件里面的方法进行重写或更改返回值，而直接用super调用父类的默认实现，该事件会先传到Activity、再传到ViewGroup、最终再传到 View，再从最底层开始往上传，那这个传递模型就类似于一个U型。\n" + "\n" + "其中共涉及3个方法，分发方法dispachTouchEvent、拦截onIntercepteorTouchEvent、处理onTouchEvent。其中分发和处理是三层都有的，拦截方法是ViewGrop独有的。\n" + "\n" + "分发方法不处理会给到下一层或下一个方法处理，而它返回true和false都和处理方法一样，直接消费或是给到上一级的处理方法。\n" + "\n" + "而拦截方法返回true会给到本层的onTouchEvent处理,false和默认方法都不拦截，会向下走。\n"
        const val touch_event_move = "action_move与action_up传递流程"
        const val touch_event_move_answer = "ACTION_DOWN事件在哪个控件消费了（return true）， 不管他是传到底层返上来的，还是直接拦截在这一层消费的，那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）直接传到这一层，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。\n" + "\n" + "在ViewGroup源码中使用了一个全局变量mFirstTouchTarget来记录是否有View处理了Down事件。mFirstTouchTarget默认为null，如果发现了View可以处理，那么就会把mFirstTouchTarget的值设置为对应的View。那么随之而来的Down和Up都会交给该View处理，（mFirstTouchTarget为单链表结构）"
        const val touch_event_target = "mFirstTouchTarget为什么是链表结构"
        const val touch_event_target_answer = "因为链表结构更适合添加touchTarget\n" + "\n" + "多指触控时。第一根按下的手指触发ACTION_DOWN事件,之后按下的手指触发ACTION_POINTER_DOWN事件。\n" + "\n" + "所以当有多指进行触控的时候，addTouchTarget方法可能会被调用多次，mFirstTouchTarget以链式结构存储对应的view。"
        const val touch_event_conflict = "滑动冲突解决方案"
        const val touch_event_conflict_answer = "1、可以考虑从父布局的拦截方法onInterceptTouchEvent来处理，如果需要拦截返回true.\n" + "\n" + "2、如果不修复父布局，可以当前view.getParent().requestDisallowInterceptTouchEvent(true/false);如果传true表示父布局不做处理\""
        const val touch_event_x_different = "getX、getRawX、getTranslationX区别"
        const val touch_event_x_different_answer = "getX()是表示触摸点距离自身view左边的距离。\n" + "\n" + "getRawX()表示的是触摸点距离屏幕左边界的距离\n" + "\n" + "View.getWidth():表示的是当前控件的宽度\n" + "\n" + "View.getTranslationX()计算的是该View在X轴的偏移量。初始值为0，向左偏移值为负，向右偏移值为正。"
        const val memory_leak = "内存泄漏原因及如何解决"
        const val memory_leak_answer = "单例造成的内存泄漏：单例生命周期和应用的生命周期一样长，单例对象还持有该对象的引用，就会使得该对象不能被正常回收，替换上下文applicationcontext\n" + "\n" + "Handler造成的内存泄漏:Activity结束时，未处理的消息持有handler的引用，而handler又持有它所属的外部类也就是Activity的引用。将Handler声明为静态内部类。因为静态内部类不会持有外部类的引用，所以不会导致外部类实例出现内存泄露。在Handler中添加对外部Activity的弱引用。用完后记得清空队列removeCallbacksAndMessages\n" + "\n" + "非静态内部类造成的内存泄漏:非静态内部类默认会持有外部类的引用，如果里面再有个静态实例或延时任务，就会出现泄漏\n" + "\n" + "资源未关闭造成的内存泄漏：对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，从而造成内存泄漏\n" + "\n" + "集合容器中的内存泄露:在退出程序之前，将集合里的东西clear，然后置空，让相关对象不再被引用"
        const val hash_map="HashMap原理"
        const val hash_map_answer="HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表的表头，由 Node 内部类完成存储，Node类实现了 Map.Entry<K,V>接口。\n" + "\n" + "当存储对象时，将 K/V 键值传给 put() 方法：首先会计算出Key的hash值，如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞\n" + "\n" + "如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对，如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）"
        const val how_hash="如何计算hash值的？"
        const val how_hash_answer="采用高位16位组成的数字与源哈希值取异或而生成的哈希值作为用来计算的\n" + "\n" + "为什么要用异或？减少碰撞。可以将高低位二进制特征混合起来\n" + "\n" + "异或：两个值相同结果为0，不同结果为1"
        const val change_big="扩容机制"
        const val change_big_answer="HashMap的初始容量16，默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。\n" + "\n" + "ArrayList初始是10，每次扩容是原来得1.5倍。数组进行扩容时，会将老数据中得元素重新拷贝一份道新的数组中，负载因子1\n" + "\n" + "\n" + "初始容量 负载因子 扩容增量\n" + "ArrayList 10 1 0.5倍\n" + "Vector 10 1 1倍\n" + "HashSet 16 0.75 1 倍\n" + "HashMap 16 0.75 1 倍"
        const val red_black_time="红黑数查找性能"
        const val red_black_time_answer="jdk1.8引入了红黑树的设计，当hash表的单一链表长度超过 8 个的时候，链表结构就会转为红黑树结构。\n" + "\n" + "红黑树查询：其访问性能近似于折半查找，时间复杂度 O(logn)；\n" + "\n" + "链表查询：这种情况下，需要遍历全部元素才行，时间复杂度 O(n)；\n" + "\n" + "简单的说，红黑树是一种近似平衡的二叉查找树，其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)。"
        const val aidl = "aidl"
        const val aidl_answer = "AIDL是进程间通讯的一种方式，一般会与Service、Binder共同完成交互通信。\n" + "\n" + "首先服务端需要先创建AIDL接口文件，定义自己所需要的方法，配置好后build项目，生成aidl JAVA文件，里面会自动生成一个静态的抽像类Stub，继承了Binder，而且还实现了自己所定制aidl接口\n" + "\n" + "然后客户端需要先配置一个与服务端相同的aidl-java文件，并与服务端通过BindService的方式启动一个远程服务，服务端在onBind方法中，传给客户端一个stub代理对象，客户端在ServiceCnection的回调中得到了这个stub代理对象，就可以通过stub里定义好的接口进行通信了。\n" + "\n" + "客户端向服务端：直接用ServiceCnected里返回的bind调用就可以了。\n" + "服务端向客户端：通过接口回调，在客户端ServiceCnected里注册个callback，然后进行通信。"
        const val thread_pool_create = "线程池创建方法"
        const val thread_pool_create_answer = "创建线程池的方式一般有两种：\n" + "\n" + "1、通过Executors工厂方法创建\n" + "\n" + "2、 通过ThreadPoolExecutor构造函数创建。\n" + "\n" + "newThreadPoolExecutor(intcorePoolSize, intmaximumPoolSize, longkeepAliveTime,TimeUnitunit,BlockingQueue<Runnable>workQueue)自定义创建"
        const val thread_four_api = "Executors API提供的4种线程池"
        const val thread_four_api_answer = "Executors.newSingleThreadExecutor()：单线程的线程池，只有一个线程在工作，任务按顺利执行\n" + "\n" + "Executors.newFixedThreadPool(3)：构建固定线程数的线程池，默认情况下，空闲线程不会被回收\n" + "\n" + "Executors.newCachedThreadPool():创建一个会根据需要创建新线程的线程池，线程数随着任务量而变动，空闲线程超过60秒将被回收\n" + "\n" + "Executors.newScheduledThreadPool(空或int):创建定时线程任务的线程池，可以通过传参设置固定数量，它的实例可以调用\n" + "\n" + "scheduleAtFixRate(runnable,第一次执行延迟时间，每隔多久执行，时间单位)来周期性执行任务。"
        const val thread_seven_params = "ThreadPoolExecutor 线程池构造函数的七个参数"
        const val thread_seven_params_answer = "1、corePoolSize 线程池核心线程大小\n" + "\n" + "2、maximumPoolSize 线程池最大线程数量\n" + "\n" + "3、keepAliveTime 空闲线程存活时间\n" + "\n" + "4、unit 空闲线程存活时间单位\n" + "\n" + "5、workQueue 工作队列，JDK提供了四种\n" + "\n" + "6、threadFactory 线程工厂\n" + "\n" + "7、handler 拒绝策略，JDK提供了四种"
        const val thread_work_principle = "线程池相关"
        const val thread_work_principle_answer = "线程池任务提交过程,核心流程其实就是走的ThreadPoolExcutor类中的execute(runnable)方法：\n" + "\n" + "a. 首先判断核心线程池中的线程是否已经满了，如果没满，则创建一个核心线程执行任务，否则进入下一步\n" + "\n" + "b. 判断工作队列是否已满，没有满则加入工作队列，否则执行下一步\n" + "\n" + "c. 判断线程数是否达到了最大值，如果不是，则创建非核心线程执行任务，否则执行饱和策略，默认抛出异常"
        const val thread_shut_down = "如何关闭线程池"
        const val thread_shut_down_answer = "1. shutdown() 不接收新任务,会处理已添加任务\n" + "\n" + "2. shutdownNow() 不接受新任务,不处理已添加任务,中断正在处理的任务"
        const val thread_pool_work_queue = "工作队列 wordQueue"
        const val thread_pool_work_queue_answer = "SynchronousQueue:无缓冲等待队列.从队列中取和放都是阻塞方法,如果队列满了再往里放,会进入阻塞.如果队列中没有任务在往出取也会进入阻塞.类似于生产者与消费者模式那种的.这个队列只能装一个任务.\n" + "\n" + "LinkedBlockingQueue:无界缓存队列. 长度是Integer.MAX_VALUE,当执行的线程数量等于核心线程数量的时候,剩余的任务会在阻塞队列中等待.所以在使用这个队列的时候,最大线程数的参数相当于无效了.\n" + "\n" + "ArrayBlockingQueue:有界缓存队列可以定义队列的长度.\n" + "\n" + "PriorityBlockingQueue（具有优先级的无界阻塞队列，优先级通过参数Comparator实现）\n" + "\n" + "注意\n" + "1. 当workQueue使用的是无界限队列时，maximumPoolSize参数就变的无意义了，比如new LinkedBlockingQueue(),或者new ArrayBlockingQueue(Integer.MAX_VALUE);\n" + "\n" + "2. 使用SynchronousQueue队列时由于该队列没有容量的特性，所以不会对任务进行排队，如果线程池中没有空闲线程，会立即创建一个新线程来接收这个任务。maximumPoolSize要设置大一点。\n" + "\n" + "3. 核心线程和最大线程数量相等时keepAliveTime无作用."
        const val thread_pool_reject_policy = "线程池的拒绝策略"
        const val thread_pool_reject_policy_answer = "CallerRunsPolicy：不抛弃线程 调用线程池的线程帮助执行，如果线程池已经shutdown，则直接抛弃任务。\n" + "\n" + "AbortPolicy：该策略下，直接丢弃任务，并抛出\n" + "\n" + "RejectedExecutionException异常\n" + "\n" + "DiscardPolicy：该策略下，直接丢弃任务，什么都不做。\n" + "\n" + "DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列"
        const val thread_pool_recycling = "非核心线程的回收"
        const val thread_pool_recycling_answer = "工作线程启动后，会进入一个runWorker的方法里。\n" + "\n" + "里面是一个while循环，循环判断任务是否为空，若不为空，执行任务；若取不到任务，或发生异常，退出循环，执行processWorkerExit(w, completedAbruptly);\n" + "\n" + "在这个方法里把工作线程移除掉。"
        const val leak_canary="LeakCanary原理"
        const val leak_canary_answer="Leakcanary在初始化时会返回一个refWatcher监听器，他会注册一个callback来监听Activity的onDestroy方法。activity在执行onDestroy后需要被回收，监听机制将Activity包装到WeakReference中，被WeakReference包装过的Activity对象如果被回收，该WeakReference引用会被放到ReferenceQueue中。如果过5秒没有回收，监听机制会手动触发次GC，如果还没有被回收，那就说明Activity可能已经泄露。 这个时候就可以抓取内存dump文件来分析展示了。"
        const val java_reference = "java引用类型"
        const val java_reference_answer = "强引用：当我们使用new创建对象时，被创建的对象就是强引用，如Object object = new Object()，其中的object就是一个强引用了。如果一个对象具有强引用，JVM就不会去GC它，JVM宁可会报OOM来终止程序，也不回收该对象。\n" + "\n" + "软引用: 如果一个对象只具备软引用，如果内存空间足够，那么JVM就不会GC它，如果内存空间不足了，就会GC该对象。\n" + "\n" + "弱引用: 如果一个对象只具有弱引用，只要JVM的GC线程检测到了，就会立即回收。弱引用的生命周期要比软引用短很多。不过，如果垃圾回收器是一个优先级很低的线程，也不一定会很快就会释放掉软引用的内存。\n" + "\n" + "虚引用：如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行GC。\n" + "\n" + "\n" + "软引用一般用于图片缓存，场景，图片编辑bitmap，用法类似于SoftReference<String> sr = new SoftReference<String>(new String(\"hello\")); System.out.println(sr.get());\n" + "WeakReference<Car> weakCar = new WeakReference<Car>(car); if(weakCar.get()!=null)，虚引用可以解决一些内存泄漏的问题，如Handler之类的。"
        const val java_reference_queue = "ReferenceQueue的使用与作用"
        const val java_reference_queue_answer = "ReferenceQueue queue = new ReferenceQueue();\n" + "\n" + "SoftReference ref = new SoftReference( aMyObject , queue );\n" + "\n" + "\n" + "当软引用对象被GC之后，虽然这个SoftReference对象指向的对象已不存在,但这个SoftReference对象本身还占用内存，如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法。ReferenceQueue的poll()方法来检查是否有它所关心的非强引用对象被回收。作用就是通知处理"
        const val thread_local="ThreadLocal原理"
        const val thread_local_answer = "ThreadLocal是一个关于创建线程局部变量的类。使用场景如下所示：\n" + "\n" + "* 有助于线程安全，因为每个线程都会有一个对应的实例。承载一些线程相关的数据，避免在方法中来回传递参数。\u2028\n" + "* 实现单个线程单例以及单个线程上下文信息存储，比如交易id等。\n" + "\n" + "\n" + "什么是ThreadLocal\n" + "\n" + "ThreadLocal 是 Thread 的共享变量。有助于线程安全，因为每个线程都会有一个对应的实例。承载一些线程相关的数据，避免在方法中来回传递参数，或加synchronized上锁那么麻烦。\n" + "\n" + "\n" + "ThreadLocal的原理\n" + "\n" + "ThreadLocal中有一个ThreadLocalMap中有一个table数组，元素是Entry。根据ThreadLocal(需要转换获取到Hash Key)能get到对应的Enrty。\u2028Entry中key为ThreadLocal, value就是存储的数值。\n"
        const val sleep_wait = "sleep、wait、notify、notifyAll区别"
        const val sleep_wait_answer = "sleep、wait最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。\n" + "\n" + "1. sleep是Thread类的静态方法,wait是Object类中定义的方法\n" + "2. Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁,而wait 会释放当前线程锁\n" + "3. Thread.sleep需要设定休眠时间.Object.wait也可以设定wait时间,或者通过线程执行notify/notifyAll进行唤醒\n\nnotify与notifyAll\n\n1. notify唤醒一个线程,如果有多线程在wait,可能是随机一个\n" + "\n" + "2. notifyAll唤醒所有在等待的线程,\n" + "\n" + "3. 使用中尽量使用notifyAll,因为notify容易导致线程死锁(nofity只唤醒一个,其他等待的线程没有唤醒)"
        const val version_features = "android版本特性"
        const val version_features_answer = "6.0增加运行时权限\n" + "\n" + "7.0分屏多任务、夜间模式\n" + "\n" + "8.0画中画android:supportsPictureInPicture=ture，调用接口、指纹手势\n" + "TextView 字体自动适配\n" + "\n" + "9.0“刘海”屏幕支持，可以通过windowInsets.getDisplayCutout()、增加ImageDecoder替换BitmapFactory，代码更优雅\n" + "\n" + "10支持可折叠设备、5G 网络、应用使用黑色主题\n" + "\n" + "11、更好地支持瀑布屏，即无边框的全面屏\n" + "提供了适用于不同运营商的各种5G图标显示解决方案  可以通过API修改显示"
        const val handler_thread = "HandlerThread"
        const val handler_thread_answer = "HandlerThread继承自Thread，因此HandlerThread其实就是一个线程。他和优点就是，HandlerThread的run方法里就调用了Looper.preper()，和looper.loop()方法，为我们创建好了消息Looper.可以直接拿来用。使用场景就是，在子线程中执行耗时的、可能有多个任务的操作。比如说多个网络请求操作，或者多文件 I/O 等等。使用 HandlerThread 的典型例子就是 IntentService\n" + "\n" + "\n" + "HandlerThread handlerThread = new HandlerThread(\"handlerThread\");\n" + "handlerThread.start(); \n" + "\n" + "创建Handler\n" + "Handler mCheckMsgHandler = new Handler(mHandlerThread.getLooper()){\n" + "     @Override\n" + "     public void handleMessage(Message msg){\n" + "         // 进行耗时操作\n" + "     }\n" + "};"
        const val invalidate = "postInvalidate和Invalidate的区别"
        const val invalidate_answer = "一般来说，如果View确定自身不再适合当前区域，比如说它的LayoutParams发生了改变，需要父布局对其进行重新测量、布局、绘制这三个流程，往往使用requestLayout。而invalidate则是刷新当前View，使当前View进行重绘，不会进行测量、布局流程，因此如果View只需要重绘而不需要测量，布局的时候，使用invalidate方法往往比requestLayout方法更高效\n" + "\n" + "postInvalidate\n" + "这个方法与invalidate方法的作用是一样的，都是使View树重绘，但两者的使用条件不同，postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。"
        const val app_start_process = "APP启动过程"
        const val app_start_process_answer = "注（AMS是system_server中的一个进程）\n" + "\n" + "1、Launcher响应用户点击，通知AMS，需要启动一个应用\n" + "\n" + "2、AMS会检查这个应用程序所需要的进程是否存在，不存在就会请求Zygote进程启动需要的应用程序进程\n" + "\n" + "3、Zygote进程接收到AMS请求并通过fock自身创建应用程序进程，并执行ActivityThread的main方法\n" + "\n" + "4、然后App进程，通过Binder IPC向AMS进程发起attachApplication请求；\n" + "\n" + "5、AMS进程在收到请求后，进行一系列准备工作后，再通过Binder IPC向App进程发送handleBindApplication,也就是初始化Application并调用onCreate方法请求，和scheduleLaunchActivity创建启动Activity请求。\n" + "\n" + "6、App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；\n" + "\n" + "7主线程在收到Message后，通过反射机制创建目标Activity，并回调Activity.onCreate()等方法。到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。"
        const val app_start_about_role = "App启动中涉及的模块及作用"
        const val app_start_about_role_answer = "ActivityManagerService：（AMS）AMS是Android中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。\n" + "\n" + "ActivityThread：应用的入口类，通过调用main方法，开启消息循环队列。ActivityThread所在的线程被称为主线程；\n" + "\n" + "ApplicationThread：ApplicationThread提供Binder通讯接口，AMS则通过代理调用此App进程的本地方法\n" + "\n" + "Application：通过反射的方式创建了一个Application对象，并且调用了Appliction的attach()方法，而attach方法又调用了attachBaseContext方法，现在应该明白为什么该方法在Application的onCreate之前调用了。\n"
        const val app_start_start_time = "计算启动时间"
        const val app_start_start_time_answer = "本地调试的话，直接一个命令就可以了，adb shell am start -W com.example.kotlin/com.example.kotlin.activity.MainActivity，其中有个TotalTime表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，本地用这个就可以了\n" + "\n" + "冷启动：\n" + "在Application.attachBaseContext() 开始的位置记录就可以，因为在这之前 Context 还没有初始化， App 的具体业务逻辑还没开始执行。\n" + "\n" + "结束时间点：\n" + "可以在 Activity.onWindowFocusChanged 记录应用启动的结束时间点，从onWindowFocusChanged被执行起，用户可以与应用进行交互了，真正的visible时间点。如果后面有焦点变化，也会调这个方法，需要区分好。\n" + "\n" + "热启动启动时间点：\n" + "可以在 Activity.onRestart() 中记录起始时间点。\n" + "\n" + "统计线上应用的话，就需要打点了，起始时间点比较容易记录："
        const val app_start_optimize = "APP启动优化"
        const val app_start_optimize_answer = "1、在application中配置一个theme，在style中定义广告页或默认图，让用户先看默认图。\n" + "\n" + "2、在Application和activity初始化的时候，把耗时操作放到子线程中进行，非必要的功能可以懒加载，还有布局层次也要减少"
        const val app_start_method_sequence = "启动过程中方法调用顺序"
        const val app_start_method_sequence_answer = "-> Application 构造函数\n" + "\n" + "-> Application.attachBaseContext()\n" + "\n" + "-> Application.onCreate()\n" + "\n" + "-> Activity 构造函数\n" + "\n" + "-> Activity.setTheme()\n" + "\n" + "-> Activity.onCreate()\n" + "\n" + "-> Activity.onStart\n" + "\n" + "-> Activity.onResume\n" + "\n" + "-> Activity.onAttachedToWindow\n" + "\n" + "-> Activity.onWindowFocusChanged"
        const val assets_res = "Assets目录与res目录的区别"
        const val assets_res_answer = "res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即可，assets文件夹下的文件不会被映射到R文件中，访问的时候需要AssetManager类。\n" + "\n" + "res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹。"
        const val intent_service = "介绍下IntentService"
        const val intent_service_answer = "IntentService其本质上是一个Service，因为它是继承至Service，所以开启IntentService和普通的Service一致。\n" + "\n" + "但是他和普通的Service不同之处在于它可以处理异步任务，在任务处理完之后会自动结束。\n" + "\n" + "另外，我们可以启动多次IntentService，而每一个耗时任务会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且是串行执行。\n" + "\n" + "其实IntentService的内部是通过HandleThread和Handle来实现异步操作的。\"\n" + "\n" + "\n" + "1、新建service类并继承自IntentService\n" + "2、实现service的构造方法\n" + "3、在manifast.xml中注册服务\n" + "4、在服务的onHandleIntent方法中实现业务逻辑\n" + "\n" + "public class WorkService extends IntentService {\n" + "    public WorkService() {\n" + "        //必须实现父类的构造方法\n" + "        super(\"WorkService\");\n" + "    }\n" + "    @Override\n" + "    protected void onHandleIntent(@Nullable Intent intent) {\n" + "                .......\n" + "    }}"
        const val mvp = "介绍下MVP"
        const val mvp_answer = "MVP中的Presenter，它其实是分离了Activity与Fragment的业务逻辑，承担了Controller的功能，view与model之间也是隔离的，需要通过Presenter来进行通信。这种设计的主旨是为了降低耦合度，但也有缺点，就是他们之间的调用，都是通过接口来完成的，这也就造成了接口类和Presenter类等文件非常繁多，我的理解，它就是通过文件与接口数量，换来了强解耦。\n" + "\n" + "MVP模式容易维护，可拆卸，可扩展，耦合性叫MVC较小，结构清晰。\n" + "\n" + "MVP的缺点，在于开发开销相对较大。与MVC相比，需要维护更多的接口。\n" + "\n" + "\n" + "View <— —> Presenter <— —> Model\n" + "\n" + "Model层：同样提供数据操作的功能\n" + "View层：由Activity、Fragment、或某个View控件担任\n" + "Presenter层：作为View层和Model层沟通的中介。\n" + "\n" + "接口：\n" + "public interface ContributorView extends MvpView {\n" + "     void start();\n" + "}\n" + "\n" + "\n" + "public class MyActivity extends Mvp抽像类<接口，Prisenter>implements ContributorView{\n" + "\n" + "@Override  \n" + "     public void start() {  \n" + "          showProgress();  \n" + "     }  \n" + "\n" + " }\n" + "\n" + "\n" + "public class ContributorPresenter extends MvpBasePresenter<ContributorView> { \n" + "\n" + "@Override\n" + "     public void onStart() {\n" + "          ContributorView view = getView();\n" + "          if(view != null){\n" + "\t\t//也就是让Activity去显示\n" + "               view.onLoadContributorStart();\n" + "          }\n" + "     }\n" + "\n" + "     public void get(){\n" + "\t  //网络请求，model层就是okhttp等等\n" + "     }\n" + "}"
        const val final_finally_finalize = "Java 中的 final, finally 和 finalize?"
        const val final_finally_finalize_answer = "\n" + "final：对基本类型而言，你不能改变其数值，对于引用，你不能将其指向一个新的引用，即用final关键字修饰方法，它表示该方法不能被覆盖重写，但是可以被重载，用final修饰的类是无法被继承的\n" + "finally：是异常处理中进行收场处理的代码块，比如配合lock使用，在finally里面关闭锁。关闭一个数据库连接，清理一些资源占用的问题。不管有没有异常被捕获，finally子句中的代码都会被执行。\n" + "finalize：finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，定位bug"
        const val equals_deng = " == 和 equals() 有什么区别？"
        const val equals_deng_answer = "1、对于==，比较的是值是否相等\n" + "\n" + "如果作用于基本数据类型的变量，则直接比较其存储的 值是否相等，\n" + "\n" + "如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等。\n" + "\n" + "\n" + "2、equals()方法不能作用于基本数据类型的变量，在没有重写equals()的类中，调用equals()方法其实和使用==的效果一样，也是比较的是引用类型的变量所指向的对象的地址\n" + "\n" + "不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。"
        const val equals_hash_code = " hashCode()与equals()"
        const val equals_hash_code_answer = "hashCode也是Object类的一个方法。返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。\n" + "\n" + "如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。\n" + "\n" + "如果两个对象不equals，他们的hashcode有可能相等。\n" + "\n" + "如果两个对象hashcode相等，他们不一定equals。\n" + "\n" + "如果两个对象hashcode不相等，他们一定不equals。"
        const val overloading_overriding = "重载和重写的区别"
        const val overloading_overriding_answer = "重载：方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。\n" + "\n" + "重写：是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。如果父类的方法有异常声明，那么子类重写这个方法时候，所要声明的异常不应该比父类的大。只能是小等，或者可以没有\n" + "\n" + "可否重写父类的静态方法\n" + "\n" + "静态方法，是在运行时，虚拟机已经认定此方法属于哪个类。 静态方法的调用不需要实例化， \"重写\"只能适用于实例方法.不能用于静态方法.对于静态方法,只能隐藏... "
        const val java_three_point = "java三大特性"
        const val java_three_point_answer = "封装：将类的属性和方法细节隐藏起来，只对外提供访问和修改接口\n" + "\n" + "\n" + "继承：一个类可以使用另一个类的部分属性与方法，比如子类继承父类后，除了private子 类不可见，其他属性与方法都可以使用\n" + "\n" + "\n" + "多态：一种类形具有表现多种形态的能力，多态的作用就是消除类型之间的耦合关系，它的三个必要条件是继承、重写、父类引用指向子类对象。这样可以提高程序的扩展力，是一种面向抽象编程的思想。"
        const val generic_reflection = "介绍下 泛型、反射"
        const val generic_reflection_answer = "泛型：\n" + "在集合中存储对象并在使用前进行类型转换是很不方便的，并且容易出错，为了防止这种情况，泛型产生。泛型提供了编译期的类型安全，确保我们只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException（类型转换异常）\n" + "\n" + "反射：就是动态加载一个指定的类，并获取该类中的所有的内容，比如有些第三方的JAR文件中的资源，我们没法直接调用，就可以用反射这种比较原始的方法来调用。\n" + "\n" + "1、获得Class对象，就是获取到指定的名称的字节码文件对象。\n" + "Class c = Class.forName(className);\n" + "\n" + "2、实例化对象，获得类的属性、方法或构造函数。\n" + "\u2028Field[] fields = c.getDeclaredFields();\u2028\u2028for (int i = 0; i < fields.length; i++) {\n" + "\n" + "// 打印属性的 修饰符 类型 名称\n" + "System.out.println(Modifier.toString(fields[i].getModifiers()) + \" \" + fields[i].getGenericType() + \" \"+ fields[i].getName());}\n" + "\n" + "\n" + "\n" + "3、访问属性、调用方法、调用构造函数创建对象。"
        const val join_about = "如何让线程按顺序执行"
        const val join_about_answer = "可以用线程类的join()方法，join()方法的作用，是等待这个线程结束；在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕.\n" + "\n" + "newSingleThreadExecutor()方法创建的线程池是一个基于FIFO先进先出的队列，也就是说，当我们依次将thread1，thread2，thread3加入队列中时，实际在就绪状态的只有thread1这个线程，thread2，thread3则会被添加到队列中等待，当thread1执行完毕后，则会按进入队列的先后顺序执行队列中的其他线程。"
        const val deadlock_about = "什么是死锁？死锁的四个条件，如何避免死锁"
        const val deadlock_about_answer = "死锁：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程都处于阻塞状态，无法继续。\n" + "\n" + "\n" + "四个条件\n" + "1、互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。\n" + "\n" + "2、请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n" + "\n" + "3、不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。\n" + "\n" + "4、循环等待条件:若干进程间形成首尾相接循环等待资源的关系\n" + "\n" + "\n" + "如何避免\n" + "\n" + "1、合理分配资源，做好解耦工作，避免线程交叉竞争\n" + "\n" + "2、锁的范围尽可能的要小，能用同步代码块就别用方法锁和类锁\n" + "\n" + "3、避免多次上锁，注意加锁顺序\n" + "\n" + "4、使用锁时，可以多考虑些可操作的锁，比如可中断锁，以及在上锁前判断下上锁状态等。\n"
        const val sum_link = "数组和链表的区别"
        const val sum_link_answer = "数组：是将元素在内存中连续存储的；它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效率比较高；它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低。\n" + "\n" + "链表：是动态申请内存空间，不需要像数组需要提前申请好内存的大小，链表只需在用的时候申请就可以，根据需要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）"
        const val array_link = "ArrayList和LinkedList的区别，以及应用场景"
        const val array_link_answer = "Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中后面的所有数据。最差情况是ON\n" + "\n" + "linkedList是基于双链表的，他的特点就是插入和删除非常快，只需要改变相邻节点的指针就可以了，但他如果用来查询就很慢了，最差情况是ON，因为他需要一个一个去找。\n" + "\n" + "除此之外像ArrayList是数组结构，所以他的起始容量是10，当数组需要增长时，就会新增一个为原来1.5倍容量的新数组，然后把原数组的数据原封不动的复制到新数组中，再把新数组赋值给原来的数组对象就完成了。所以会有空间浪费的情况\n" + "\n" + "一般情况下，LinkedList的占用空间更大，因为每个节点要维护指向前后地址的两个节点，但也不是绝对，如果刚好数据量超过ArrayList默认的临时值时，ArrayList占用的空间也是不小的，因为扩容的原因会浪费将近原来数组一半的容量\n"
        const val string_string_buffer = "介绍下String，为什么要设计成不可变的？以及StringBuffer、StringBuilder"
        const val string_string_buffer_answer = "String并不是基础类型，是final修饰的java类，之所以被设计成不可变主要是为了保证数据不被污据，方法区中的字符串池，当一个字符串已经被创建并且该字符串在池中，该字符串的引用会立即返回给变量，而不是重新创建一个字符串再将引用返回给变量。如果字符串不是不可变的，那么改变一个引用（如:string2）的字符串将会导致另一个引用（如:string1）出现脏数据。\n" + "\n" + "string不是基本数据类型，那么一个string的内存位置是什么呢？一共有两种情况：\n" + "　　1、string直接赋值：\n" + "　　　　String s = \"haha\";\n" + "　　　　s的引用存在栈内存中，引用指向的haha存在方法区的常量池中（先判断常量池中是否有一个haha，存在则直接指向）\n" + "　　2、string对象new创建\n" + "　　　　String s = new String(\"haha\");\n" + "　　　　s的引用存在于栈内存中，引用指向的haha对象，存在堆内存中（每new一次，在堆中创建一个新的haha对象）\n" + "\n" + "和String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象\n" + "\n" + "StringBuffer是线程安全的，可以在多线程操作字符串\n" + "StringBuilder是非线程安全的，性能会比StringBuffer好些"
        const val thread_application = "进程和线程的区别"
        const val thread_application_answer = "首先是定义：进程是执行中的一段程序，一个应用至少有一个进程，而线程是用来执行任务的。他们之间是包含关系，一个进程中能有一个或多个线程。\n" + "\n" + "二是进程可以拥有系统分配的资源，但线程只涉及运行栈和程序计数器。\n" + "\n" + "还有就是开销上，线程要比进程小很多，主要就是这三点。\n" + "\n" + "（每当有线程被创建的时候，JVM就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。）\n"
        const val hash_map_hashtable = "HashMap与HashTable的区别"
        const val hash_map_hashtable_answer = "最大的不同是hashtable是线程安全的，里面方法是synchronized，而HashMap是非线程安全的。所以HashMap性能更好些。也正是因为HashTable性能弱些，所以它用的是头插法，否则还要遍历到链表的尾部插入。\n" + "\n" + "Hashtable中，key和value都不允许出现null值。HashMap中key和value都可以为null\n" + "\n" + "另外他们初始容量不一样，HashTable是11，但HashMap是16，而且HashTable没有红黑数支持，HashMap它数组到64，链表长度到8就会转成红黑数，还有扩容，HashTable是2倍+1，而HashMap是变为2位。\n" + "\n" + "再有就是哈希值的计算不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值(高16位异或低16位)，并且HashMap 支持key 为null 就是在这里的"
        const val clean_apk = "APK体积优化"
        const val clean_apk_answer = "在APP中图片就占据了很大的一部分体积，所以图片的优化是我们要关注的重点。\n" + "首先是图片格式，可以把UI同学给的图都过一遍，把png都转换webp(androidstudio自带covert to webp)或是压缩一遍，在不失真的情况下尽量压缩，还有些是可以用.9的图，就用.9来拉伸，这些都是很有效的。\n" + "\n" + "再有就是移除无用资源，可以通过Remove Unused Resources来查找出无用资源，或是用lint也行\n" + "\n" + "在gradle中打开代码压缩(minifyEnabled)、开启混淆压缩\n" + "\n" + "一些SO，也可以酌情精简，比如我们市场上基本都是使用基于armeabi的CPU架构（ABI），像微信、头条，都只保留了一套armeabi的so，所以我们也可以做些精简\n" + "\n" + "再有就是移除国际语言gradle中    defaultConfig{resConfigs 'en’}\n" + "\n" + "通过第三方框架来做资源混淆压缩啊等等（通过微信的开源的AndResGuard，资源混淆的原理是通过修改APK包里的resource.arsc文件，修改文件中的字符串池中的字符串，将其修改为简单短小的字符串，以此来减少文件大小）\n"
        const val interrupt_interrupted = "interrupt(),interrupted() 和 isinterrupted() 的区别"
        const val interrupt_interrupted_answer = "interrupt方法主要作用是将线程的中断状态设置为true，如果遇到被阻塞的线程会抛出InterruptedException异常（同时中断状态为false）。\n" + "\n" + "interrupted()用来清除当前线程的中断状态，还会返回当前线程的状态，如果线程已中断，则返回true，否则返回false。而且会清除当前Thread的中断状态，置为false。\n" + "\n" + "isInterrupted是用来获取调用线程的中断状态的，但不会重置中断状态\n" + "\n" + "一般interrupt会和isInterrupted，配合while循环、try、catch一起来使用\n"
        const val thread_status = "线程有几种状态"
        const val thread_status_answer = "在 Thread 类里有一个枚举类型 State，定义了线程的几种状态，分别有：\n" + "\n" + "New: new 一个实例出来，线程就进入了初始状态。\n" + "\n" + "Runnable: 就绪状态，像调用start() 、sleep（）结束、他线程 join() 结束都会进入runnable。线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态\n" + "\n" + "Blocked： 没有获取到锁被阻塞的状态\n" + "\n" + "WAITING： 处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n" + "\n" + "TIMED_WAITING： 处于这种状态的线程不会被分配 CPU 执行时间，在达到一定时间后它们会自动唤醒。\n" + "\n" + "TERMINATED： 当线程的 run() 方法完成时，或者主线程的 main() 方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。"
        const val binder_info = "介绍下Binder机制"
        const val binder_info_answer = "因为Linux 内核与用户空间是隔离的，所以为了支持用户程序之间通讯，Android系统通过添加一个内核模块运行在内核空间，也就是LKM，用户程序就可以通过这个模块来作为桥梁，完成通信。\n" + "\n" + "Binder 通信采用 C/S 架构，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务\n" + "\n" + "首先需要服务端向 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表中插入服务端的信息，并缓存到 ServiceManager 中去，这样就有了服务端。\n" + "\n" + "有了服务端，客户端就可以通过 ServiceManager 拿到服务端的代理，并通过Binder驱动与服务端进程通信；"
        const val catch_exception = "如何捕捉异常"
        const val catch_exception_answer = "Exception分为两类：一种是CheckedException，一种是UncheckedException，如果是CheckedException，可以用try\\catch来捕捉，如果是运行时异常，可以自定义一个工具类，实现UncaughtExceptionHandler接口，然后在application中初始化，用这个工具来捕获unchecked异常。里面需要重写一个uncaughtException方法，在里面完成错误信息收集，发送错误报告等操作"
        const val ui_block = "卡顿的原因"
        const val ui_block_answer = "卡顿最根本原因是因为掉帧，我们手机正常情况下是每秒60帧，也就是16ms一帧。\n" + "\n" + "但如果我们的线程被阻塞住了，或是因为内存不够、过度绘制这些原因，导致系统无法在16ms内绘制好，就会出现掉帧的情况，也就是我们说的卡顿，严重的话就会被用户感知到。"
        const val how_solve_block = "卡顿如何解决"
        const val how_solve_block_answer = "这要根据实际情况来做处理了\n" + "\n" + "如果是主线程阻塞的原因，可以用TraceView，它可以看出代码在运行时的一些具体信息，方法调用时长，次数，时间比率，了解代码运行过程的效率问题。\n" + "\n" + "如果是内存引起的卡顿，可以通过leakcanary，看看是不是有内存泄漏啊，或是通过Memory Profiler看看对于一些大图的加载处理，是不是需要优化的。\n" + "\n" + "过度绘制，就直接使用系统的过度绘制检测就可以了，如果是蓝绿一层两层的就可以，红色就需要再优化优化。\n"
        const val not_ui_refresh = "为什么非 UI 线程不能更新 UI"
        const val not_ui_refresh_answer = "因为一旦多线程抢着更新UI，那么界面将会乱套更新了，所以在Android中规定必须在主线程更新UI。\n" + "\n" + "他的原理是在根视图ViewRootImpl源码中的requestLayout方法中有个checkThread()方法，他在那做了个检测，如果非UI线程调用会报错。（ViewRootImpl对象是在onResume方法回调之后才创建）\n" + "\n" + "SurfaceView是一个特例。\n" + "SurfaceView是存在于独立UI线程的，它拥有surface(表面)的canvas，在绘制时，可以通过加锁和解锁来绘制，所以当界面如果更新操作时间较长，而且数据量较大的话，一般采用SurfaceView方式更新屏幕，而少用View"
        const val serializable_parcelable = "Serializable和Parcelable的区别"
        const val serializable_parcelable_answer = "所谓的序列化指的是把对象转换成字节流的过程，可以保存到文件中，也可以用来网络传输数据。\n" + "反序列化既是相反的过程，可以从我们的文件中把字节流读出来，转换为对象供我们使用。\n" + "\n" + "\n" + "序列化有两个方法，一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，但在序列化的时候会产生大量的临时变量，内部会执行大量的i/o操作，效率很低。而实现Parcelable接口稍微复杂一些，但效率更高，不过有个插件，Parcelable Code Generator，一键生成，也挺好用的。另外在内存中读写，但对象不能保存到磁盘中，因为Parcelable在对数据做持久化上不是太好，或是在外界有变化的情况下不能很好的保证数据的持续性，或是多版本版本兼容问题\n" + "\n" + "Parcelable用法\n" + "\n" + "1）implements Parcelable\n" + "2）实现接口中的两个方法，一个是描述内容的，返回0就行。还有个是重写writeToParcel方法，将你的对象序列化为一个Parcel对象，把属性都写入Parcel对象中\n" + "4）实例化静态内部对象CREATOR实现接口Parcelable.Creator，实例化CREATOR时要实现其中的两个方法，其中createFromParcel的功能就是从Parcel中读取我们的对象（另一个是供外部类反序列化本类数组使用）\n" + "\n" + "\n" + "调用方法\n" + "\n" + "存：bundle.putParcelable(\"book\", book);intent.putExtras(bundle);\n" + "\n" + "取：Bundle bundle = intent.getExtras();Book book = bundle.getParcelable(\"book\");"
        const val more_process_purpose = "应用内多进程的目的、优点"
        const val more_process_purpose_answer = "1、让一个组件运行在单独的进程中，可以减少主进程所占用的内存，降低被系统杀死的概率。\n" + "\n" + "2、如果子进程因为某种原因崩溃了，不会直接导致主程序的崩溃，可以降低我们程序的崩溃率。\n" + "\n" + "3、即使主进程退出了，我们的子进程仍然可以继续工作"
        const val more_process_use = "应用内多进程的方法"
        const val more_process_use_answer = "实现：只需要添加 android:process 的属性即可，属性名可以自定义，相同的属性名的进程在同一个里面运行。\n" + "\n" + "1 . 如果android:process的值以冒号开头，“:”的含义是要在当前进程名前面加上包名，那么该进程就是私有进程，其他应用的组件不可以和它跑在同一个进程中。\n" + "\n" + "2 . android:process=“xxx.xxx.xxxx.xxx” 完整的命名方式，或点开头的，属于全局进程，其它应用通过ShareUID方式可以和它跑在同一个进程中。\n" + "\n" + "ShareUserId的作用，数据共享、调用其他程序资源。在manifest里可以配置android:sharedUserId=\"com.mythou.share\""
        const val more_process_question = "应用内多进程的问题"
        const val more_process_question_answer = "问题1：Application的多次重建，会初始化两回\n" + "解决：判断是否为主进程，只有主进程的时候才执行下面的操作\n" + "String processName = this.getProcessName();\n" + "processName.equals(this.getPackageName())\n" + "\n" + "问题2：静态成员和单例失效，设置了process属性后，产生了两个隔离的内存空间，一个内存空间里值的修改并不会影响到另外一个内存空间。所以就算是静态成员也是两个不同的成员值。\n" + "\n" + "问题3：文件共享问题，多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等，即便上锁，排队等机制，对多进程也较难实现\n" + "解决：解决方法就是统一由主进程来处理，子进程通知主进程来操作。\n" + "\n" + "问题4：调试断点，调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，无法实现在不同的进程间调试。\n" + "解决：临时去掉process标签，统一在一个进程里调试，结束后再还原标签\n" + "\n" + "问题5：通信方式也会改变，原来可以直接通信，现在需要借肋binder ipc"
        const val sp_about = "介绍下SP"
        const val sp_about_answer = "SP作为Android存储数据方式之一，它是轻量级存储，只支持java基本数据类型，且在进程内可以进行数据共享"
        const val sp_why_light = "为什么说是SP是轻量级存储"
        const val sp_why_light_answer = "之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会一次性把整个文件全部加载进内存，如果SharedPreference文件比较大，会导致阻塞线程、产生大量临时对象引起GC、key和value会占用大量内存，非常消耗资源"
        const val sp_save_steps = "使用SP保存key-values的步骤"
        const val sp_save_steps_answer = "1）使用activity类的getSharedPreferences方法获得SharedPreference对象\n" + "\n" + "2）使用SP接口的edit获得Sharedpreferences.Editor对象\n" + "\n" + "3）通过sharedpreferences.editor接口的putXxx方法保存键值对，\n" + "\n" + "4）通过Sharedpreferences.editor接口的commit（）方法保存键值对"
        const val sp_principle = "SP内部工作原理"
        const val sp_principle_answer = "1、调用getSharedPreferences（）；创建一个SharedPreferences对象，其中会先判断是否存在对应xml文件\n" + "\n" + "2、如果对应的xml不存在则重新创建一个对应xml文件，如果存在则会把xml文件解析后存入一个map对象中(通过I/O流操作和xmlUtil，map为ArrayMap)。\n" + "\n" + "3、EditorImpl的putXXX方法，主要是将数据保存在一个Map中，这些数据是存储在内存中，只有调用了commit()或apply()方法之后，才会同步到磁盘中。"
        const val sp_two_save_method = "SP的两种提交方式"
        const val sp_two_save_method_answer = "commit会立即并同步保存数据。\n" + "\n" + "apply则异步保存数据，从而提高了性能。如果你不关心它的返回类型，则apply优先于commit"
        const val sp_why_no_safe = "SP是否是线程安全的？"
        const val sp_why_no_safe_answer = "SharePreferences是线程安全的 里面的方法有大量的synchronized来保障 \n\n在进程间是不安全的。原因是系统对SharedPreferences的读写有一定的缓存策略，即内存中有一份SharedPreferences文件的缓存\n" + "\n" + "在多进程模式下，系统对它的读写变的不可靠，当面对高并发的读写访问，SharedPreferences很很大几率会造成数据丢失\n" + "\n" + "所以，不建议在进程通信中使用SharedPreferences。"
        const val lazy_fragment_purpose = "fragment懒加载的目的"
        const val lazy_fragment_purpose_answer="viewpager+fragment结合使用等场景下，因为viewpager有着预加载机制：默认一次加载当前页面前后两个页面，如果不进行懒加载会导致多个fragment页面的生命周期被调用，这样一是会消耗内存、CPU资源，二是造成流量浪费。\n" + "\n" + "注释：同级下，onResume也会被调用"
        const val lazy_fragment_support = "support包 fragment懒加载方法"
        const val lazy_fragment_support_answer="1、viewpager+fragment场景时，主要的方法是Fragment中的setUserVisibleHint()，此方法会在onCreateView(）之前执行。使用getUserVisibleHint() 可以返回fragment是否可见状态。 通过在setUserVisibleHint中判断显示与否，再进行异步初始化，初始化后显示正常UI。\n" + "onCreateView—> lazyLoad()异步初始化方法\n" + "setUserVisibleHint—>if (isVisibleToUser)—>lazyLoad()异步初始化方法\n" + "\n" + "2、add+show+hide场景时，我们可以利用onHiddenChanged 来完成懒加载机制,它里面会返回个boolean，相当于onPause、onResume\n" + "\n" + "3、当add+hide+show和viewpager+fragment 嵌套组合时，也可以配合setUserVisibleHint+onHiddenChanged来进行懒加载，但需要设置些变量来管理状态"
        const val lazy_fragment_androidx = "Androidx下 fragment懒加载方法："
        const val lazy_fragment_androidx_answer="1、ViewPager+Fragment，在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有behavior字段的构造函数，当mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT后，只有显示的fragment才会调用onResume我们只需要在onResume中，来进行懒加载就可以了。可以加个标识，防止多次加载。\n" + "\n" + "2、add+show+hide在add fragment时仅把要显示的fragment通过setMaxLifecycle设置为只有显示的fragment调用resume，其他fragment均设置为STARTED。\n" + "在show、hide切换显示的fragment时仅把show的fragment通过setMaxLifecycle设置为只调用onResume，其他hide的fragment再还原成STARTED\n" + "\n" + "3、复杂嵌套\n" + "当fragment嵌套fragment等复杂情况下，只要父fragment回调onresume生命周期函数那被嵌套的所有同级子fragment都会回调onresume，所以我们需要再加上fragment是否隐藏的标识，来判断是否要进行懒加载\n" + "\n" + "ViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法,可以通过setOffscreenPageLimit（）传入Int,来控制两侧要加载的数量\n" + "\n" + "解释：懒加载，只有显示时才执行onResume(),viewpager 的适配器构造行数里有个字段，可以控制是否是运行完全周期，还是显示后才只调用onResume"
        const val android_class_load = "Android类加载机制"
        const val android_class_load_answer = "在Android中，类加载最上层是ClassLoader这个抽象类，它有两个子类\n" + "\n" + "BootClassLoader：用于加载Android Framework层class文件。\n" + "\n" + "还有个BaseDexClassLoader，也就是我们常用的父类加载器，它有两个子类，\n" + "\n" + "一个是PathClassLoader用于加载程序中已安装的apk的dex，比如我们自己写的类。\n" + "\n" + "还有一个是DexClassLoader，和PathClassLoader比，只是构造方法不同，多了一个optimizedDirectory参数，它可以加载指定目录下(不限于内部)的 dex/jar/apk 文件\n" + "\n" + "因为ClassLoader的双亲委派机制，加载流程最后会到BaseDexClassLoader中的findClass方法中，apk中的dex文件也会被解析保存到父类加载器的dexElements的数组中，然后通过遍历数组加载指定的文件。\n" + "\n" + "可说可不说 ——> 像基于类加载的热修复框架就是用的这个原理来完成类目的替换。"
        const val class_load = "类加载机制、流程"
        const val class_load_answer = "类加载指的是将类的class文件动态的加载到内存中，最终可以被虚拟机直接使用， 这些工作是通过加载器来完成的\n" + "\n" + "JVM采用的是双亲委派加载，也就是有任务会先委派给父加载器，这样从下到上逐层委派，最终会给到根类加载器，如果父类无法加载，子类才会自己尝试加载。双亲委派机制的好处一是可以避免重复加载，二是防止核心API被随意篡改。\n" + "\n" + "整体加载流程也可以叫生命周期有七步：\n" + "1、加载：把class文件加载到内存里，转换成二进制字节流\n" + "2、验证：格式、字节码等验证，保证符合虚拟机要求\n" + "3、准备：在方法区为类变量分配内存设默认值\n" + "4、解析：把虚拟机常量池中的符号引用转换为直接引用也就是内存地址\n" + "5、初始化：为类的静态变量赋初值\n" + "6、使用：\n" + "7、卸载：执行完成\n" + "\n" + "解析这一步是不固定的，有可能会放在初始化之后，为了支持JAVA语言的动态绑定"
        const val class_load_three = "JVM预定义有三种类加载器"
        const val class_load_three_answer = "1是根类加载器bootstrap classloader，他主要加载JDK/lib目录下的rt、resources等jar包和class等核心类库，他底层是由C++代码来编写的。\n" + "\n" + "2是扩展类加载器，Extention ClassLoader，可以加载ext目录下的jar包和class文件\n" + "\n" + "3是系统类加载器，App ClassLoader，加载当前应用的classpath下的所有类"
        const val abstract_interface = "抽像类与接口的差别"
        const val abstract_interface_answer = "抽象类是对整个类进行抽象，包括属性和方法，是一种模板设计。我们可以有选择地重写需要用到的方法。而接口是对行为的抽象，实现接口的一定要实现接口里定义的所有方法，里面不能有私有的方法或变量，是用于让别人使用的。还有就是一个具体类只能extends一个抽象类，可以implements多个接口。\n" + "\n" + "还有些就是定义上的区别，比如抽像类可以有构造器，但接口没有，访问修饰符抽像类可以有public protected  default等，但接口默认修饰符是public，不可以用其他修饰符。"
        const val blocking_queue = "阻塞队列的原理"
        const val blocking_queue_answer = "阻塞队列实际上是使用了Condition来模拟线程间协作，调用Condition的await()和signal()方法也都是上锁的，原理就是类似于Looper，那种生产者与消费者的场景，当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程会被唤醒，就可insert了"
        const val handler_async = "Handler同步屏障"
        const val handler_async_answer = "屏障消息是用来挡住普通消息来保证异步消息优先处理的。在next()方法中，判断下队首消息的的target是否为空，如果为空的话，说明是同步屏障消息，那它就会寻找队列中的下一个异步消息优先处理。\n" + "\n" + "Handler有个构造方法，可以传入async标志为true，这样构造的Handler发送的消息就是异步消息，优先级高于普通消息，优先发送\n" + "\n" + "还可以通过message.setSynchronus();把本条消息设成异步消息。\n" + "\n" + "同步屏障是通过MessageQueue的postSyncBarrier方法插入到消息队列的。\n" + "\n" + "移除屏障可以通过MessageQueue的removeSyncBarrier方法：\n" + "\n" + "屏障消息和普通消息的区别在于屏障没有tartget，普通消息有target是因为它需要将消息分发给对应的handler，而屏障不需要被分发，"
        const val delay_message = "延迟消息处理"
        const val delay_message_answer = "Handler会先在sendMessageAtTime这个方法里去计算消息被处理的时间，也就是当前时间加上延迟时间\n" + "\n" + "然后再把消息在enqueueMessage这个方法当中，按时间msg.when的时间先后顺序插入到消息队列中去\n" + "\n" + "handler每次插入message都会唤醒线程，通过next()方法，依次拿到队首消息，先判断屏障消息，如果不是的话\n" + "\n" + "再判断当前时间是否小于消息的执行时间，如果小于就是消息还没准备好发送，就会设置一个超时时间，给到nextPollTimeoutMillis，然后通过调用nativePollOnce本地方法进行阻塞\n" + "\n" + "等到时间后，再通过pipe管道写入数据来唤醒线程，判断时间到后，发送消息"
        const val why_no_die = "为什么Looper.loop不会卡死"
        const val why_no_die_answer = "looper.loop()是个死循环，但并不是所有的死循环都会卡死进程的，如果我们的程序运行完就结束了，那我们的应用也就没法使了。\n" + "\n" + "所以我们的应用还需要依赖死循环一直执行下去。真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume里的耗时操作\n" + "\n" + "而looper.loop在没有事务要处理的时候，便阻塞在messagequeue中的nativePollOnce()方法里。\n" + "\n" + "这是个本地代码，会通过Linux epoll监听文件描述符的写入事件来实现阻塞，直到有新事务要处理的时候，才会调用nativeWake方法，通过往pipe管道写入数据来唤醒主线程工作。\n" + "\n" + "在这期间，主线程是处于休眠状态的，并不会消耗大量CPU资源，所以looper.loop本身不会导致应用卡死。"
        const val how_many_string = "string在使用时会创建几个对象"
        const val how_many_string_answer = "String str1 = \"abc\"; // 在常量池中，如果有不需要创建  1个\n" + "\n" + "String str2 = new String(\"abc\"); // 在堆上 str2 常量池中“abc” abc如果有不需要创建   1或2个\n" + "\n" + "String str = \"abc\" + \"def\"; //在编译时已经被合并成“abcdef”字符串，因此，只会创建1个对象。\n" + "\n" + "String str = \"abc\" + new String(\"def\"); //“abc”和“def”，堆中对象new String(\"def\")和“abcdef”。还会创建一个StringBuilder来进行字符串的拼接\u2028  字符串、new、builder"
        const val volatile_principle = "volatile原理"
        const val volatile_principle_answer = "一、volatile可见性的实现就是借助了CPU的lock指令，通过在写volatile的机器指令前加上lock前缀，使写volatile具有以下两个原则：\n" + "\n" + "1、写volatile时处理器会将缓存写回到主内存。\n" + "\n" + "2、一个处理器的缓存写回到内存会导致其他处理器的缓存失效。\n" + "\n" + "\n" + "二、禁止指令重排序是通过加内存屏障来实现的。JMM为volatile加内存屏障有以下4种情况：写volatile与后面的写操作重排序、写volatile与后面的读操作重排序，读volatile与后面的读操作重排序、防止读volatile与后面的写操作重排序。\n" + "\n" + "在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。\n" + "\n" + "在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。\n" + "\n" + "在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。\n" + "\n" + "在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序。"
        const val fragment_activity_communication="fragment与Activity通信"
        const val fragment_activity_communication_answer="第一种：setArguments  bundle\n" + "\n" + "activity:\n" + "MyFragment myFragment = new MyFragment();\n" + "Bundle bundle = new Bundle();\n" + "bundle.putString(\"DATA\",values);//这里的values就是我们要传的值\n" + "myFragment.setArguments(bundle);\n" + "\n" + "Fragment:\n" + "Bundle bundle = getArguments();\n" + "        if(bundle!=null){\n" + "            titles = bundle.getString(\"title\");\n" + "        }\n" + "\n" + "\n" + "第二种：接口,编写接口，定义方法，在fragment中的attach方法中获取到宿主activity并赋值\n" + "if(activity instanceof FragmentBackListener ) {\n" + "    listener = (FragmentBackListener )activity; // 2.2 获取到宿主activity并赋值\n" + "} \n" + "\n" + "//fragment按钮点击时\n" + "listener.dosomething()\n" + "\n" + "\n" + "第三种：直接调用，上下文强转\n" + "  @Override\n" + "       public void onAttach(Context context) {\n" + "           super.onAttach(context);\n" + "           titles = ((MainActivity)getActivity()).getTitles();\n" + "\t}\n" + "\n" + "\n" + "第四种：广播和eventbus"
        const val design_patterns = "介绍下设计模式"
        const val design_patterns_answer = "常用的有\n" + "Builder模式：比如AlertDialog.Builder、glide、okhttp、retrofit在创建时都有用到，建造者模式的意思就是说将一个复杂的对象一步一步进行建造，同样的构建过程，但可以创建不同的功能与样式\n" + "\n" + "适配器模式：比如GridView、ListView与Adapter，把一个类的接口变换成客户端所期待的另一种接口，从而可以兼容正常工作\n" + "\n" + "职责链模式：View的测量、事件分发、OK都是。使多个对象都有机会处理请求，从而避免请求的发送者和接收者直接的耦合关系。\n" + "\n" + "观察者模式：比如ContentObserve、eventbus、还有些系统广播，监听wifi状态的。定义了对象之间的一对多的关系，当触发事件后，会遍历全部的register。\n" + "\n" + "享元模式：比如Java的常量池，线程池，Message的消息池。使用享元对象有效地支持大量的细粒度对象\n" + "\n" + "工厂模式：BitmapFactory、ThreadFactory，定义一个创建对象的接口，让子类决定实例化哪个类\n" + "\n" + "还有像builder是中介者模式，activity是模板方法模式，aidl用到了代理模式，这些都算是常见的。另外还有解释器模式（PackageParser来解释AndroidManifest）、备忘录模式（onSaveInstanceState）可能用的不太多。\n" + "\n" + "设计模式整体一共有23种，其实每天都会用啊，只是没有去归纳总结。有建造型5个、结构型：7个、行为型： 11个。\n"
        const val https_process = "Https传输流程"
        const val https_process_answer = "HTTPS流程\n" + "\n" + "1、客户端向服务端发送通信请求，明确好需要确信的信息，像ssl协议的版本、支持的加密算法，压缩方法等。\n" + "\n" + "2、服务端收到请求，会确认客户端传来的信息，如果协议版本不对，会关闭加密通信。同时服务端还会向客户端传送自己的公钥证书\n" + "\n" + "3、客户端收到证书后，首先会进行验证合法性，是否过期、发行机构、域名是否匹配等。验证通过之后，就会生成一个随机的对称密钥（session key），再使用证书中的公钥进行加密，然后传递给服务器端\n" + "\n" + "4、服务器收到使用公钥加密的内容，使用私钥解密后，拿到客户端值过来的随机值，然后把内容通过该值进行对称加密，传给客户端。\n" + "\n" + "5、客户端再用之前生成的随机值来解密，拿到内容\n" + "\n" + "整体过程就是先确认信息，然后是非对称加密传输对称加密的密钥，再拿对称密钥加密解密。\n"
        const val concurrent_hash_map = "ConcurrentHashMap 原理"
        const val concurrent_hash_map_answer = "在JDK 1.7中，ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成的。使用的是分段锁技术(ReentrantLock)，然后给每一段数据配一把锁（segment），当一个线程占用一把锁（segment）访问其中一段数据的时候，其他段的数据也能被其它的线程访问，默认分配16个segment，效率要比hashtable要高很多。\n" + "\n" + "JDK1.8中ConcurrentHashMap取消了segment分段锁，而采用CAS(原子操作)和synchronized来保证并发安全。数据结构跟HashMap很像，数组+链表/红黑二叉树。\n" + "synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升了很多。"
        const val auto_adapter_screen = "屏幕适配方案"
        const val auto_adapter_screen_answer = "1、在布局文件中写view宽高可以多用 wrap_content,match_parent，让view自适应，用权重weight来替代固定值，距离单位用dp，字体单位用sp，\n" + "\n" + "2、自适配图片，也就是在res下的选择相应的dpi，没特殊需求的话推荐xxdpi，1080*1920，这样就可以满足向上向下兼容，节省空间\n" + "\n" + "3、如果有指定需求，可以创建指定的分辨率资源进行适配，手机会根据分辨率去找设定的资源，比如layout的布局，layout-800 * 480，  value-1080*1920\n" + "\n" + "了解 —> 还有一种是修改手机的设备密度 density，他是通过appDisplayMetrics.density动态设置，来使不同分辨率，来实现UI样式统一，不过这种方式只能一刀切的将整个项目进行适配，但适配范围是不可控的，一般不用。"
        const val http_error_code = "http错误码"
        const val http_error_code_answer = "1xx   信息性状态码，接受的请求正在处理\n" + "\n" + "2xx\t成功状态码，请求正常\n" + "200： 请求成功。一般用于GET与POST请求\n" + "201 - Created 服务器已经创建了文档，Location头给出了它的URL\n" + "202 - Accepted 已经接受请求，但处理尚未完成\n" + "\n" + "3xx\t重定向状态码\n" + "301 Moved Permanently：永久性重定向\n" + "302 Found：临时性重定向\n" + "\n" + "4xx\t客户端错误状态码\n" + "400：Bad Request 请求出现语法错误\n" + "401 - Unauthorized 访问被拒绝，客户试图未经授权访问受密码保护的页面。\n" + "403 - Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致\n" + "404 - Not Found 无法找到指定位置的资源。这也是一个常用的应答\n" + "\n" + "5xx\t服务端错误状态码\n" + "500 - Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求\n" + "502 - Bad Gateway 服务器用作网关或代理服务器时收到了终端服务器的无效响应\n" + "503 - Service Unavailable 服务不可用，服务器由于维护或者负载过重未能应答\n"
        const val url_process = "输入一个网址的全过程"
        const val url_process_answer = "输入网址后，首先会从浏览器、系统、路由器当中查看是否有缓存，如果有从缓存当中显示页面，没有的话再进行DNS域名解析，把域名转换成IP，然后TCP连接，进行请求，请求成功后再把数据进行解析，页面渲染。"
        const val tcp_udp_different = "TCP、UDP协议的区别"
        const val tcp_udp_different_answer = "UDP：面向无连接，速率快。不可靠\n" + "\n" + "TCP：在传递数据之前先建立连接，数据传输结束后还要释放资源。可靠但传输速率相对慢。\n" + "\n" + "TCP的可靠性体现在：在传递数据之前建立连接，在数据传递时，通过确认、窗口、重传、拥塞机制来保证数据传输的可靠性。\n" + "\n" + "适用场景：UDP：适用于实时应用（IP电话、视频会议、直播等）。TCP:适用于要求可靠传输的应用，例如文件传输"
        const val net_work_level = "网络通信一共有几层"
        const val net_work_level_answer = "OSI模型，也就是开放式系统互联通信参考模型。这个模型把网络通信的工作分为7层，分别是\n" + "物理层,\n" + "数据链路层,\n" + "网络层,\n" + "传输层,\n" + "会话层，\n" + "表示层\n" + "和应用层。\n" + "\n" + "1至4层被认为是低层，这些层与数据移动密切相关。5至7层是高层，包含应用程序级的数据。每一层负责一项具体的工作，然后把数据传送到下一层"
        const val framework_about = "介绍下Android架构"
        const val framework_about_answer ="android架构有四层（application程序层、framework程序框架层、libraris程序运行库层、linux核心层），framework处于第二层，也叫应用程序框架层，主要是为应用层的开发者提供API各种服务的。\n" + "该层包括活动管理器、窗口管理器、内容提供者、视图系统、包管理器、电话管理器、资源管理器、位置管理器、通知管理器和 XMPP 服务十个部分。\n" + "\n" + "Framework框架包含了3个主要部分：服务端、客户端、Linux驱动。\n" + "\n" + "像AMS（ActivityManagerService）WMS（WindowManagerService）这些都是常接触到的系统服务（这些系统服务都是以一个线程的方式存在于SystemServer进程中。）\n" + "\n" + "客户端：ActivityThread、Activity、PhoneWindow、WindowManager这些也算是常接触到的客户端类\n" + "\n" + "Linux驱动和Framework相关的主要包含两部分，分别是SurfaceFlingger(SF)和Binder。\n" + "每一个窗口都对应一个Surface, SF驱动的作用是把各个Surface显示在同一屏幕上。Binder驱动的作用是提供跨进程（IPC)的消息传递机制。"
        const val jvm_gc_work = "简述GC机制"
        const val jvm_gc_work_answer ="Java 中的堆是用于存放实例对象的，堆被划分成年轻代 ( Young )、老年代 ( Tenured)。\n" + "\n" + "年轻代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。配比是8：1：1。大多数刚被创建的对象会存放在伊甸园空间，当空间不足时，会触发MinorGC，MinorGC采用复制算法。首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域，清空Eden和ServicorFrom中的对象，再把ServicorTo和ServicorFrom互换。将在指定次数回收后仍然存在的对象移动到老年代中,MinorGC执行完后，会得到一个空的可用的年经代。\n" + "\n" + "在年轻代经历多次垃圾回收后仍然存活的对象，会被放到老年代，老年代空间不足时会触发Full GC，所采用的是标记-清除算法，或者标记整理算法。\n" + "首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。\n" + "\n" + "老年代触发Full GC的频率要比年轻代低，耗时要长。\n" + "\n" + "之前还有持久代，用于存放静态文件，如今Java类、方法等，JAVA8 开始持久代也已经被彻底删除了。现在取代它的是方法区。"
        const val mark_rubbish = "标记垃圾的算法："
        const val mark_rubbish_answer ="主要是可达性分析算法：通过栈中的引用、方法区中的常量和静态变量这些根节点开始向下搜索，当没有被这个引用链相关联，也就是从GC Roots到这个对象不可达时，则证明对象是不可用的。\n" + "\n" + "了解  --->引用计数算法：对象有一个引用，就增加一个计数，删除一个引用，就减少一个计数。垃圾回收时，只回收计数为0的对象。此算法无法处理循环引用的对象。"
        const val clean_rubbish = "清除垃圾的算法："
        const val clean_rubbish_answer ="1、标记清除法：第一阶段从根节点标记所有引用对象，第二阶段遍历整个堆，对未做标记的对象进行清除。缺点此算法会暂停整个应用，stop the world，而且会产生内存碎片。老年代\n" + "\n" + "2、复制算法：此算法把内存划为两个相等的区域，每次只使用其中一个区域，垃圾回收时，把正在使用的对象复制到另外一个区域，算法可以整理相应的内存，缺点是需要2倍的区域。一般用于年轻代。\n" + "\n" + "3、标记整理：第一阶段从根节点标记所有引用对象，第二阶段清除未标记对象，然后把堆中的存活对象向一端按顺序存放。一般用于老年代"
        const val rubbish_robot = "垃圾收集器介绍下"
        const val rubbish_robot_answer ="JVM1.5以上支持CMS垃圾收集器，最新JDK9之后默认使用的是G1收集器，\n" + "\n" + "CMS使用的是标记-清除算法，会有内存碎片，适用于老年代，它需要与Serial收集器和Parallel New收集器搭配使用。\n" + "\n" + "而G1采用适用于整个堆区，有两个优点：\n" + "\n" + "第一点：G1会压缩空闲内存使之足够紧凑，是通过用regions代替细粒度的空闲列表进行分配，减少内存碎片的产生。\n" + "\n" + "第二点：G1的STW更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。而CMS只能是尽量减少STW为目的，时间不可控"
        const val android_base = "简述Android系统的基本架构"
        const val android_base_answer ="Android 系统架构分从下往上为 Linux 内核层、系统运行库层、应用程序框架层 和 应用程序层，各层的功能为：\n" + "\n" + "Linux 内核层负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能；\n" + "\n" + "系统运行库层通过一些 C/C++ 库来为 Android 系统提供主要的特性支持；\n" + "\n" + "应用程序框架层提供构建应用程序时可能用到的各种 API，开发人员主要是使用该层封装好的 API 进行快速开发；\n" + "\n" + "应用程序层提供一些核心应用程序包。"
        const val view_draw_process = "view的绘制流程"
        const val view_draw_process_answer ="view的绘制是从根视图 ViewRoot 的 performTraversals() 方法开始，从上到下遍历整个视图树，具体操作是分发给 ViewGroup 的，ViewGroup 通过遍历自身所有的子 View，并逐个调用子 View 的 measure、layout、draw 方法实现测量、定位、绘制操作。\n" + "\n" + "如果想自定义View的测量，需要重写onMeasure()方法，我们可以通过mesureSpec获取到view的尺寸，改写过后还需要调用setmeasuredimension方法来配置他的宽高。(布局文件是warp，但我们想改成固定值就可以用onMesure)\n" + "\n" + "layout的作用就是为整个View树计算实际的位置，他和mesure一样，需要递归的去计算每一个子视图的位置。如果需要重写，可以调用onLayout方法，要传入标识，还有左上右下这4个相对于父view的距离参数。\n" + "\n" + "draw作用就是绘制View 的背景、子View、还有前景跟滚动条等。还有一个onDraw空方法，自定义View的话需要重写，在里面绘制自己需要添加的内容"
        const val surfaceView_about = "介绍下SurfaceView"
        const val surfaceView_about_answer ="SurfaceView在单独线程中进行绘图，有独立的绘图表面。适用于界面频繁更新、对帧率要求较高的情况。像相机预览、地图之类的都可以使用。\n" + "\n" + "SurfaceView可以控制刷新频率。\n" + "SurfaceView底层利用双缓存机制，绘图时不会出现闪烁问题。双缓冲技术是游戏开发中的一个重要的技术，主要是为了解决 反复局部刷屏带来的闪烁，surfaceView是通过surfaceHolder.lockCanvas锁定画布，实现下一张图片的绘制，再通过另外的线程刷新界面，绘制图片。\n" + "View是直接在ondraw里绘制图片，刷新界面。\n" + "\n" + "View适用主动更新，SurfaceView 适用被动更新"
        const val surfaceView_use = "SurfaceView的使用"
        const val surfaceView_use_answer ="首先要继承SurfaceView，实现SurfaceHolder.Callback接口。\n" + "\n" + "重写方法：\n" + "surfaceChanged：surface大小或格式发生变化时触发，在surfaceCreated调用后该函数至少会被调用一次。\n" + "surfaceCreated：Surface创建时触发，一般在这个函数开启绘图线程（新的线程，不要再这个线程中绘制Surface）。\n" + "surfaceDestroyed：销毁时触发，一般不可见时就会销毁。\n" + "\n" + "利用getHolder()获取SurfaceHolder对象，调用SurfaceHolder.addCallback添加回调\n" + "\n" + "SurfaceHolder.lockCanvas 获取Canvas对象并锁定画布，调用Canvas绘图，SurfaceHolder.unlockCanvasAndPost 结束锁定画布，提交改变。"
        const val list_diff = "RecyclerView 与 ListView 的区别"
        const val list_diff_answer="一. RecyclerView多了一些LayoutManager工作，但实现了布局效果多样化\n" + "1、ListView 的布局比较单一，只有一个纵向效果。\n" + "2、RecyclerView 可以在LayoutMananger中设置：线性布局（纵向，横向），表格布局，瀑布流布局\n" + "\n" + "二.一些常用功能的api不同，比如 Listview可以通过addHeaderView() 与 addFooterView()来添加头部item与底部item，但RecyclerView需要在Adapter中自己编写。还有Listview有onItemClickListener、onItemLongClickListener(),但RecyclerView需要通过addOnItemTouchListener或在item中实现。其他还有Listview没有局部刷新（notifyItemChanged），setTag()、getTag()等。\n" + "\n" + "三.ViewHolder的编写规范化，ListView是需要自己定义的，而RecyclerView是规范好的\n" + "\n" + "四.RecyclerView有嵌套滚动机制，但Listview没有：\n" + "在事件分发机制中，Touch事件在进行分发的时候，由父View向子View传递，一旦子View消费这个事件的话，那么接下来的事件分发的时候，父View将不接受，由子View进行处理；但是与Android的事件分发机制不同，嵌套滚动机制（Nested Scrolling）可以弥补这个不足，能让子View与父View同时处理这个Touch事件，主要实现在于NestedScrollingChild与NestedScrollingParent这两个接口；而在RecyclerView中，实现的是NestedScrollingChild，所以能实现嵌套滚动机制；"
        const val butter_knife = "ButterKnife作用及原理"
        const val butter_knife_answer="可以用来做View绑定和Click事件处理功能，\n" + "\n" + "编译代码时，butterKnife会扫描Java代码中所有的ButterKnife注解@Bind、@OnClick、@OnItemClicked这些类，然后ButterKnifeProcessor会帮你生成一个Java类，这个ViewBinder类中包含了所有对应的代码，比如@Bind注解对应findViewById(), @OnClick对应了view.setOnClickListener()等等 。我们会调用ButterKnife.bind(this)，动态注入所有的注解过的View属性和click方法"
        const val mvc = "介绍下MVC及优缺点"
        const val mvc_answer="MVC特点是设计简单，便于敏捷开发，适合中小项目，但因为它的view和model是可见的，外加它的Controller也就是Activity角色比较模糊，当业务越来越复杂时，就会变的十分臃肿了，不容易维护。\n" + "\n" + "这种设计模式最简单，但问题有三：\n" + "\n" + "（1）、View和Model相互可见，耦合度高。\n" + "\n" + "（2）、如果程序复杂，那么Activity这个Controller将十分繁琐复杂，不容易维护。\n" + "\n" + "（3）、Activity角色模糊，View或Model。\n" + "\n" + "\n" + "Controller <— —> View <— —> Model\n" + "\n" + "Controller —> Model\n" + "\n" + "View层：一般由XML布局文件充当。\n" + "Model层：一些数据处理的工作，比如网络数据请求、数据库操作等。\n" + "Controller层：通常由Activity、Fragment充当，并在其中进行界面、数据相关的业务处理。"
        const val mvvm = "介绍下MVVM及优缺点"
        const val mvvm_answer="MVVM：MVVM由三部分组成，M，V，VM，分别代表Modle，View，ViewModle。谈论MVVM的前提是需要了解DataBinding，即Modle与View的进行绑定，包括单向绑定（Modle影响View），双向绑定（Modle与View相互影响）。\n" + "\n" + "MVVM的侧重点在于数据与UI的联动，自动更新，而非降低耦合度。对于耦合度的问题，其实还是需要结合MVP模式来解决。\n" + "\n" + "\n" + "view —> ViewModel <— —> Model\n" + "\n" + "Model层：Model层保存了业务数据与处理方法，提供最终所需数据\n" + "View层:对应Activity以及XML，但是比起MVC与MVP框架中的View层，更加简洁\n" + "ViewModel：负责实现View与Model的交互，将两者分离\n" + "\n" + "MVVM的侧重点在于数据与UI的联动，自动更新，而非降低耦合度。对于耦合度的问题，其实还是需要结合MVP模式来解决。\n" + "\n" + "/***Activity内***/\n" + "\n" + "mDataBinding = DataBindingUtil.setContentView(this, R.layout.activity_query_weather);\n" + "\n" + "// 创建ViewModel\n" + "mViewModel = new QueryWeatherViewModel();\n" + "\n" + "// 绑定View和ViewModel\n" + "mDataBinding.setViewModel(mViewModel);\n" + "\n" + "\n" + "\n" + "layout：布局根节点必须是<layout> . 同时layout只能包含一个View标签. 不能直接包含<merge>\n" + "\n" + "data：<data>标签的内容即DataBinding的数据. data标签只能存在一个.\n" + "\n" + "variable：通过<variable>标签可以指定类, 然后在控件的属性值中就可以使用\n" + "\n" + "/***Layout布局内***/\n" + "\n" + "<data>\n" + "\n" + "    <import type=\"android.view.View\" />\n" + "\n" + "    <variable\n" + "        name=\"viewModel\"\n" + "        type=\"com.github.cyc.mvvmdemo.weather.viewmodel.QueryWeatherViewModel\" />\n" + "</data>\n" + "\n" + "<TextView\n" + "            android:layout_width=\"wrap_content\"\n" + "            android:layout_height=\"wrap_content\"\n" + "            android:text=\"@{user.userName}\"\n" + "/>"
        const val hot_class_load = "类加载方案"
        const val hot_class_load_answer = "虚拟机加载类的时候都需要ClassLoader,ClassLoader有一个子类BaseDexClassLoader，而BaseDexClassLoader下有一个\n" + " \n" + "数组——DexPathList，是用来存放dex文件，当BaseDexClassLoader通过调用findClass方法时，实际上就是遍历数组，\n" + " \n" + "找到相应的dex文件，找到，则直接将它return。而热修复的解决方法就是将新的dex添加到该集合中，并且是在旧的dex的前面，\n" + " \n" + "所以就会优先被取出来并且return返回。\n" + "\n" + "QQ空间超级补丁和Nuwa用的就是这种\n" + "\n" + "微信tinker是新旧apk做diff，得到path.dex再与手机原本的dex合并，生成新的class.dex，然后再反射将此dex放在第一个元素。bsdiff可以得到两个不同文件中的不同信息，旧文件+新文件=差分文件\n" + "bspatch：旧文件+差分文件=新文件\n" + "\n" + "优点：补丁包较小，支持资源替换\n" + "缺点：需要重启才能生效。"
        const val hot_below_replace = "底层替换方案"
        const val hot_below_replace_answer = "底层替换方法，不会从新加载类，限制较多，不能增减原有类的方法和字段，是及时生效的\n" + "\n" + "原理是直接在native层，通过反射替换方法入口，或者整个方法体。\n" + "\n" + "阿里Andfix用的就是这种方案\n" + "\n" + "优点：立即生效，消耗低。\n" + "缺点：仅支持方法的替换。"
        const val hot_instant_run = "instantRun方案"
        const val hot_instant_run_answer = "原理是每个类都增加一个静态变量，在每个方法执行前，判断此变量是否发生变化，变化了执行新的类中方法\n" + "\n" + "像美团的Robust为每个class增加了个类型为ChangeQuickRedirect的静态成员，而在每个方法前都插入了使用changeQuickRedirect相关的逻辑，当 changeQuickRedirect不为null时，可能会执行到accessDispatch从而替换掉之前老的逻辑，达到fix的目的。替换的方式也是通过反射将changeQuickRedirect的值赋为补丁对象完成补丁加载操作。\n" + "\n" + "优点：兼容性高，开发透明；实时生效。\n" + "缺点：会增大方法数，影响运行效率，不支持资源替换。\n" + "\n" + "了解 --> 当应用获取到加载补丁后，会创建DexClassLoader加载补丁，每个补丁有被修复的类信息及该类对应的补丁信息。通过被修复的类信息找到该类，反射将changeQuickRedirect的值赋为补丁对象完成补丁加载操作。"
        const val sleep_0 = "sleep(0)的作用"
        const val sleep_0_answer ="在线程中，调用sleep（0）可以释放cpu时间，让线程马上重新回到就绪队列而非等待队列，sleep(0)释放当前线程所剩余的时间片（如果有剩余的话），这样可以让操作系统切换其他线程来执行，提升效率。"
        const val thread_create = "线程创建方式"
        const val thread_create_answer = "创建线程主要有种方式，最后都是start();\n" + "\n" + "一、继承Thread类，覆写run方法。\n" + "\n" + "class ThreadA extends Thread{\n" + "        @Override\n" + "        public void run() {\n" + "           …..\n" + "        }}}\n" + "\n" + "ThreadA t = new Thread;  \n" + "t.start();  \n" + "\n" + "\n" + "二、实现Runnable接口，重写run方法\n" + "\n" + "class runnable implements Runnable {\n" + "         @Override\n" + "         public void run() {\n" + "  …..\n" + "         }}\n" + "\n" + "MyRunnable runnable = new MyRunnable();\n" + "new Thread(runnable).start();\n" + "\n" + "\n" + "\n" + "3、还有一种是实现 Callable 接口， Callable接口是Runnable接口的增强版本，需要利用TaskFutrue来创建有返回线程\n" + "class CallableThread implements Callable<String> {\u2028 @Override\u2028 public String call() throws Exception {\u2028  ….\u2028 }}\n" + "\n" + "CallableThread ct1 = new CallableThread();\n" + "FutureTask<String> task1 = new FutureTask<String>(ct1);\n" + "Thread thread1 = new Thread(task1);  //创建第一个线程\u2028thread1.start(); //启动第一个线程\u2028System.out.println(\"task1 get value: \"+task1.get())\u2028"
        const val thread_stop = "关闭线程"
        const val thread_stop_answer ="1、使用boolean标志位终止线程，让线程自己完成运行，要用volatile声明。\n" + "\n" + "2、使用Interrupte方法标记停止，然后while循环和isInterrupted判断是否被中断，并添加中断逻辑。\n" + "\n" + "3、是已经过时的stop方法。不推荐STOP的原因：线程被杀掉，马上被别的线程上锁，数据写还一半就被别的线程上锁，连清理的机会都没有，拿到异常数据，一定会出问题。"
        const val thread_change = "线程的切换"
        const val thread_change_answer ="切换方法：join()、yeild()、wait()notify、reentraintLock和condition的await()、singin()\n" + "\n" + "sleep()使当前线程进入停滞状态(阻塞当前线程)，让出CUP的使用，不释放锁\n" + "\n" + "wait() 方法 暂停线程，释放 cpu 控制权，同时释放对象锁的控制\n" + "\n" + "yield() 只是给相同优先级的线程让出 cpu 资源，如果没有相同优先级的线程，那么它还是会得到执行\n" + "\n" + "join()可以放参数，表示等多久，也可以线程来调，谁调谁先执行   下面代码表示  thread1先执行     join (0) 等价于 join ()无限等待\n" + "    private val thread1 = Thread{\n" + "        Thread.sleep(1000)\n" + "        println(join1)\n" + "    }\n" + "    private val thread2 =Thread{\n" + "        thread1.join()\n" + "        println(join2)\n" + "    }\n" + "\n" + "condition Condition与Lock配合完成等待通知机制\n" + "\n" + "        public static ReentrantLock lock = new ReentrantLock();\n" + "        public static Condition condition = lock.newCondition();\n" + "\n" + "        lock.lock();//事前加lock，保证线程同步，相当于Synchronized作用\n" + "        conditionA.await();//进入等待，需要被通知才能继续运行下面代码，绑定conditionA对象\n" + "        conditionA.signalAll();//选择性地通知唤醒所有绑定conditionA的对象"
        const val thread_safe = "线程安全"
        const val thread_safe_answer ="主要是保证线程中途不被其他线程干扰，可以通过synchronized或使用lock来保证线程同步，还可以使用ThreadLocal来维护变量\n" + "\n" + "还可以保证内存可见性，可以使用volatile修饰变量"
        const val kotlin_good = "Kotlin优点"
        const val kotlin_good_answer = "Kotlin相比较Java优点还是比较明显的，它完全兼容JAVA，AS就提供了JAVA项目转Kotlin的功能。首先它是空指针安全的，对于非空引用类型，Kotlin在编译时就会进行检测，如果值是null，会编译失败。如果想要允许为null，我们需要在变量的类型后面加上一个?号，表明它是可空类型。\n" + "\n" + "再有就是扩展函数，我们可以不通过继承、不修改源码等方式，给对象类增加属性和方法，比如一个TextView，我们只是用扩展属性调用的方式就可以给它进行加粗操作。最后还有像智能转换，支持lamda等比较快捷的特性\n" + "\n" + "还有协程，省去了传统 Thread 多线程并发机制中的性能损耗，还可以顺序调用异步代码，避免回调地狱。\n" + "\n" + "还有就是数据类 Data Class，它们可以自动生成样板，像equals，hashCode，toString，getter / setter等可以直接使用等。\n" + "\n"
        const val kotlin_coroutines = "介绍下Kotlin Coroutines(协程)"
        const val kotlin_coroutines_answer = "协程可以理解是轻量级的线程，它依赖于线程，但不像线程，切换或阻塞的开销都比较大，协程挂起时不需要阻塞线程，还有就是一个线程中可以创建任意个协程。\n" + "\n" + "另外它不需要多次回调，有点类似rxjava，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样（协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来）\n" + "\n" + "fun main(args: Array<String>) {\n" + "    launch(CommonPool) {\n" + "        delay(1000L) \n" + "        println(\"World!\") \n" + "    }\n" + "    println(\"Hello,\")\n" + "    Thread.sleep(2000L)\n" + "}\n" + "\n" + "/* \n" + "运行结果: (\"Hello,\"会立即被打印, 1000毫秒之后, \"World!\"会被打印)\n" + "Hello, \n" + "World!\n" + "*/"
        const val coroutines_create = "async与launch 创建的区别"
        const val coroutines_create_answer = "launch - 创建协程\n" + "async - 创建带返回值的协程，返回的是 Deferred 类\n" + "\n" + "在概念上，async 就类似于 launch。它启动了⼀个单独的协程，这是⼀个轻量级的线程并与其它所有的 协程⼀起并发的⼯作。不同之处在于 launch 返回⼀个 Job 并且不附带任何结果值，⽽ async 返回 ⼀个 Deferred⼀个轻量级的⾮阻塞 future，这代表了⼀个将会在稍后提供结果的 promise。你可 以使⽤ .await() 在⼀个延期的值上得到它的最终结果\n" + "（runBlocking单元测试用）"
        const val coroutines_cancel_join = "cancel()与join()"
        const val coroutines_cancel_join_answer = "cancel代码取消协程的执行，join意思是阻塞等待协程结束。也就是说cancel执行后会马上返回，执行后续的代码，但是这个时候协程不一定结束。再调用join方法，这里表示阻塞等待协程结束。确保协程结束之后才执行后续的代码。我们也可以调用job.cancelAndJoin()\n" + "\n" + "协程的取消操作是协作完成的，也就是协程必须协作才能取消。假如协程正在执行任务，如果没有检查协程是否是处于取消状态的话，则无法取消协程的执行。\n" + "\n" + "suspend fun main() {\n" + "    //构建作用区域\n" + "    coroutineScope {\n" + "        var job = launch {\n" + "            var time = System.currentTimeMillis()\n" + "            var i = 0\n" + "            while (i < 5) {\n" + "                if (System.currentTimeMillis() >= time) {\n" + "                    println(\"这是第 \${++i} 次\")\n" + "                    time += 500\n" + "                }\n" + "            }\n" + "        }\n" + "        //非阻塞等待1300毫秒\n" + "        delay(1300)\n" + "        println(\"我已等待结束....\")\n" + "        job.cancel()\n" + "        job.join()\n" + "        // job.cancelAndJoin()\n" + "    }\n" + "}\n" + "\n" + "这是第 1 次\n" + "这是第 2 次\n" + "这是第 3 次\n" + "我已等待结束....\n" + "这是第 4 次\n" + "这是第 5 次\n"
        const val coroutines_stop = "如何停止任务中的协程"
        const val coroutines_stop_answer = "1.使用isActive使计算代码可以取消\n" + " var job = launch {\n" + "      while (isActive) {\n" + "                if (System.currentTimeMillis() >= time) {\n" + "                    println(\"这是第 \${++i} 次\")\n" + "                    time += 500\n" + "                }\n" + "            }\n" + "\n" + "\n" + "2.使用yield()使计算代码可以取消\n" + " var job = launch {\n" + " while (i<5) {\n" + "                yield()\n" + "                if (System.currentTimeMillis() >= time) {\n" + "                    println(\"这是第 \${++i} 次\")\n" + "                    time += 500\n" + "                }\n" + "            }\n" + "\n" + "\n" + "3.使用 finally 关闭资源\n" + "var job = launch {\n" + "            try {\n" + "                repeat(1000){\n" + "                    println(\"这是一次打印\")\n" + "                    delay(500)\n" + "                }\n" + "            }\n" + "            finally {\n" + "                println(\"finally\")\n" + "            }\n" + "        }\n" + "\n" + "\n" + "4.可以使用withTimeoutOrNull\n" + "coroutineScope {\n" + "        withTimeoutOrNull(2000) {\n" + "            launch {\n" + "                repeat(1000) {\n" + "                    println(\"这是一次打印\")\n" + "                    delay(500)\n" + "                }\n" + "            }\n" + "\n" + "        }\n" + "    }\n"
        const val coroutines_async = "async 的使用"
        const val coroutines_async_answer = "用于开启一个新的子协程，与 launch 函数一样可以设置启动模式，不同的是它的返回值为 Deferred，Deferred是Job的子类，但是通过Deferred.await()可以得到一个返回值，简单理解的话，这就是一个带返回值的 launch 函数\n" + "\n" + "\n" + "\n" + "//串行执行\n" + "launch(UI) {                             \n" + "    prograssBar.isVisible = true\n" + " \n" + "    val token = async { getToken() }\n" + "    val profile = async { loadProfile(token.await()) }.await()\n" + "    nameText.text = profile.name\n" + "    \n" + "    prograssBar.isVisible = false\n" + "                                                \n" + "}\n" + "\n" + "//并行执行\n" + "launch(UI) {                                            \n" + "    prograssBar.isVisible = true\n" + " \n" + "    val profile = async { loadProfile() }\n" + "    val articles = async { loadArticles() }\n" + "    show(profile.await(), articles.await())\n" + "    prograssBar.isVisible = false\n" + "                                              \n" + "}"
        const val coroutines_pause_return = "协程体、挂起函数"
        const val coroutines_pause_return_answer ="当程序执行到requestDataAsync内部时, 通过async启动了另外一个新的子协程去拉取数据, 启动这个新的子协程后, 当前的父协程就挂起了, 此时requestDataAsync还没有返回.\n" + "\n" + "\n" + "子协程一直在后台跑, 过了一段时间, 子协程把数据拉回来之后, 会恢复它的父协程, 父协程继续执行, requestDataAsync就把数据返回了.\n" + "\n" + "fun main(...) {\n" + "    launch(Unconfined) {  // 请重点关注协程里是如何获取异步数据的\n" + "        val data = requestDataAsync()  // 异步回来的数据, 像同步一样return了\n" + "        println(\"data is \$it\")\n" + "    }\n" + "\n" + "    Thead.sleep(10000L) // 请不要关注这个sleep\n" + "}\n" + "\n" + "suspend fun requestDataAsync() { // 请注意方法前多了一个suspend关键字\n" + "    return async(CommonPool) { // 先不要管这个async方法, 后面解释\n" + "        // do something need lots of times.\n" + "        // ...\n" + "        data  // return data, lambda里的return要省略\n" + "    }.await()\n" + "}"
        const val flutter_about = "介绍下flutter"
        const val flutter_about_answer = "Flutter 是由Google 开发的一个响应式、跨平台的开发工具，它主要聚焦在在UI搭建和渲染层的事情，架构是采用的分层设计。\n" + "\n" + "从下到上依次为：Embedder（嵌入器）主要是适配各平台的、Engine是些基础库，包括skia和dart等、最上层是Framework，我们的应用围绕 Framework 层来构建的。\n" + "\n" + "我觉得Flutter有两个特性是比较出众的，一是支持热重载，我们在开发时，能把代码文件注入正在运行的Dart虚拟机（VM）中。Flutter框架会自动重新构建widget树，我们可以快速查看更改的效果。\n" + "\n" + "还有就是Widget，widget是整个视图描述的基础，像基础组件、布局、手势等，都是由Widget组件来实现的，通过Widget组件，能够让我们非常轻松的实现Android或者IOS风格的UI效果。"
        const val content_provider = "什么是ContentProvider"
        const val content_provider_answer = "ContentProvider为存储和获取数据提供了统一的接口，供外部调用\n" + "\n" + "外部应用通过getContentResolver().delete(uri,String,String[])(直接调不用继承和实现ContentResolver)"
        const val content_resolver = "介绍下ContentResolver"
        const val content_resolver_answer = "是数据调用者，ContentProvider将数据发布出来，通过ContentResolver对象结合Uri进行调用\\n\" + \"\\n\" + \"通过ContentResolver对象可以调用ContentProvider的增删改查"
        const val content_provider_uri = "什么是URI"
        const val content_provider_uri_answer = "Uri（通用资源标识符 Universal Resource Identifer），代表数据操作的地址，每一个ContentProvider发布数据时都会有唯一的地址。"
        const val content_provider_steps = "创建自定义ContentProvider的步骤"
        const val content_provider_steps_answer = "1.使用SQLite技术，创建好数据库和数据表\n" + "\n" + "2.新建类继承ContentProvider\n" + "\n" + "3.重写6个抽象方法 onCreate、delete、insert、query、update、getType\n" + "\n" + "4.创建UriMatcher，定义Uri规则\n" + "\n" + "5.在Manifest中注册provider\n" + "\n" + "6.ContentResolver对ContentProvider中共享的数据进行增删改查操作"
        const val android_annotation = "什么是注解"
        const val android_annotation_answer = "注解就是一种类似注释的机制，用来将信息或元数据与程序元素(类、方法、成员变量等)进行关联，为程序加以说明。\n" + "\n" + "原理：注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象 \$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用 AnnotationInvocationHandler 的 invoke 方法。该方法会从 memberValues 这个 Map 中索引出对应的值。而 memberValues 的来源是 Java 常量池。\n" + "\n" + "系统内置标准注解：Override、Deprecated、SuppressWarnnings\n" + "\n" + "注释：元数据是指用来描述数据的数据，更通俗一点，就是描述代码间关系，或者代码与其他资源(例如数据库表)之间内在联系的数据。"
        const val animations = "Android动画"
        const val animations_answer = "逐帧动画(Frame Animation) 加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间\n\n" + "补间动画(Tween Animation)也叫视图动画 Tween可以对View对象实现一系列动画效果，比如平移，缩放，旋转，透明度等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。\n\n" + "属性动画(Property Animation) 动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了\n\n\n属性动画\n\nValueAnimator是整个属性动画机制当中最核心的一个类，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。\n" + "\n" + "但如果只是些常规动画，还是使用ObjectAnimator多一些，它会把我们常用的位移、旋转、缩放、透明等效果都做为属性参数直接调用。还可以通过addListener，添加个动画的adapter，来监听它的执行状态。还可以通过setInerpolator来配置插值器，实现些加速或掉落回弹等效果。（通过时间百分比来实现非线性需求）"
        const val value_animations_about = "属性动画介绍"
        const val value_animations_about_answer ="ValueAnimator是整个属性动画机制当中最核心的一个类，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值。\n" + "\n" + "缺点：就是只能对数值计算。要是想对哪个控件操作，需要监听动画过程（通过 addUpdateListener 的监听方法），在监听中对控件操作。这样使用比较麻烦。\n" + "\n" + "而ObjectAnimator就在 ValueAnimator的基础上又做了一层封装,重写了ofInt() ofFloat() ofObject() ofArgb()等方法，可以直接传入view控件，并传入控件的set对应函数名称，拼装成对应的set函数就能实现动画效果，所以用ObjectAnimator来实现动画会更容易些。"
        const val value_animator = "ValueAnimator"
        const val value_animator_answer ="主要的三种方法：\n" + " \n" + "a) ValueAnimator.ofInt(int values)：估值器是整型估值器IntEaluator\n" + " \n" + "b) ValueAnimator.ofFloat(float values):估值器是浮点型估值器FloatEaluator\n" + " \n" + "c) ValueAnimator.ofObject(ObjectEvaluator, start, end):将初始值以对象的形式过渡到结束值，通过操作对象实现动画效果，需要实现Interpolator接口，自定义估值器  \n" + "\n" + "还有ofArgb()修改颜色的，ofPropertyValuesHolder()自定义封装动画\n" + "\n" + "ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);\n" + "anim.setDuration(300);\n" + "anim.start();\n" + "\n" + "可以传入任意多个参数的比如说将一个值在5秒内从0过渡到5，再过渡到3，再过渡到10，就可以这样写：\n" + "\n" + "ValueAnimator anim = ValueAnimator.ofFloat(0f, 5f, 3f, 10f);\n" + "\n" + "我们还可以调用setStartDelay()方法来设置动画延迟播放的时间，调用setRepeatCount()和setRepeatMode()方法来设置动画循环播放的次数以及循环播放的模式，循环模式包括RESTART和REVERSE两种，分别表示重新播放和倒序播放的意思。\n" + "\n" + "期间每次赋值都会调用invalidate()不断刷新视图，即调用onDraw()重新绘制视图；每次绘制视图便实现了动画效果。"
        const val object_animator = "ObjectAnimator"
        const val object_animator_answer ="ObjectAnimator动画原理：根据属性值拼装成对应的set函数的名字，比如”alpha”的拼接方法就是将属性的第一个字母强制大写后，与set拼接，也就是setAlpha,然后通过反射找到对应控件的setAlpha(float alpha)函数，将当前数字值作为setAlpha(float alpha)的参数将其传入。属性值得首字母大小写都可以，最终都会被强转成大写。View中都已经实现了相关的alpha rotation translate scale相关的set方法。\n" + "\n" + "ObjectAnimator的动画设置流程:ObjectAnimator需要指定操作的控件对象，在开始动画时，到控件类中去寻找设置属性所对应的set函数，然后把动画中间值做为参数传给这个set函数并执行它。 \n" + "\n" + "ObjectAnimator只负责把当前运动动画的数值传给set函数。至于set函数里面怎么来做，是我们自己的事了。 \n" + "\n" + "如果我们想要将一个TextView在5秒中内从常规变换成全透明，再从全透明变换成常规\n" + "\n" + "ObjectAnimator animator = ObjectAnimator.ofFloat(textview, \"alpha\", 1f, 0f, 1f);\n" + "animator.setDuration(5000);\n" + "animator.start();\n" + "\n" + "除此之外，还有alpha-透明度，rotation-旋转，translationX-偏移，scaleY-放大"
        const val animator_animator_set = "AnimatorSet"
        const val animator_animator_set_answer = "AnimatorSet是Animator的子类，实现组合动画功能主要需要借助AnimatorSet这个类,\n" + "\n" + " \n" + "AnimatorSet.play(Animator anim)   ：播放当前动画\n" + "\n" + "AnimatorSet.before(Animator anim) ：  将现有动画插入到传入的动画之前执行\n" + "\n" + "AnimatorSet.with(Animator anim)   ：将现有动画和传入的动画同时执行\n" + "\n" + "AnimatorSet.after(Animator anim)   ：将现有动画插入到传入的动画之后执行\n" + "\n" + "AnimatorSet.after(long delay)   ：将现有动画延迟x毫秒后执行\n" + "\n" + "AnimatorSet.playTogether(animA, animB)   ：AB动画共同执行\n" + "\n" + "\n" + "rotate、fadeInOut、moveIn为ObjectAnimator动画对象使用方法如下:\n" + "\n" + "AnimatorSet animSet = new AnimatorSet();\n" + "animSet.play(rotate).with(fadeInOut).after(moveIn);\n" + "animSet.setDuration(5000);\n" + "animSet.start();"
        const val property_values_holder = "PropertyValuesHolder"
        const val property_values_holder_answer = "PropertyValuesHolder的意义就是保存动画过程中所需要的属性和值，其实ofInt()和ofFloat()的内部实现就是通过封装PropertyValuesHolder实例来保存动画状态的。\n" + "\n" + "可以理解PropertyValuesHolder实例就是一个动画，与view当作参数，共同放进ObjectAnimator.(view,ofPropertyValuesHolder实例)来使用\n" + "\n" + "\n" + "PropertyValuesHolder colorHolder = PropertyValuesHolder.ofInt(\"BackgroundColor\", 0xffffffff, 0xffff00ff, 0xffffff00, 0xffffffff);\n" + "PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(\"Rotation\", 60f, -60f, 40f, -40f, -20f, 20f, 10f, -10f, 0f);\n" + "\n" + "ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTextView, rotationHolder, colorHolder);\n" + "animator.setDuration(3000);\n" + "animator.setInterpolator(new AccelerateInterpolator());\n" + "animator.start();"
        const val type_evaluator_about = "TypeEvaluator估值器"
        const val type_evaluator_about_answer = "TypeEvaluator就是告诉动画系统如何从初始值过度到结束值，比如坐标点的估值器，我们就是通过把初始和结束坐标点转成point对象，然后根据决定值fraction来计算当前动画的x和y的值，最后组装到一个新的Point对象当中并返回\n" + "\n" + "用法：自定义类，实现TypeEvaluator接口并重写了evaluate()方法，\n" + "\n" + "以下代码逻辑，先是将startValue和endValue强转成Point对象，然后同样根据fraction来计算当前动画的x和y的值，最后组装到一个新的Point对象当中并返回\n" + "class PointEvaluator{\n" + "    public Object evaluate(float fraction, Object startValue, Object endValue) {\n" + "        Point startPoint = (Point) startValue;\n" + "        Point endPoint = (Point) endValue;\n" + "        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());\n" + "        float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());\n" + "        Point point = new Point(x, y);\n" + "        return point;\n" + "    }\n" + "}\n" + "ValueAnimator.ofObject(new PointEvaluator(), point1, point2)\n"
        const val interpolator_about = "Interpolator插值器"
        const val interpolator_about_answer = "可以通过setInterpolator()   来给动画添加插值器\n" + "\n" + "anim.setInterpolator(new BounceInterpolator());\n" + "\n" + "有线性、加速、减速、周期、弹跳、先加速后减速，其他还有几个是偏移越大，而且速度越快，记不太清了。\n" + "\n" + "Linear Interpolator / 线性插值器\n" + "Accelerate Interpolator / 加速度插值器\n" + "Decelerate Interpolator / 减速插值器\n" + "Accelerate Decelerate Interpolator / 先加速后减速插值器\n" + "Bounce Interpolator / 弹跳插值器\n" + "Cycle Interpolator / 周期插值器"
        const val animator_listener = "属性动画监听种类"
        const val animator_listener_answer = "addListener可以添加四种监听,有开始、重复、取消、结束\n" + "\n" + "animator.addListener(new AnimatorListener() {\n" + "          @Override\n" + "          public void onAnimationStart(Animation animation) {\n" + "              //动画开始时执行\n" + "          }\n" + "      \n" + "           @Override\n" + "          public void onAnimationRepeat(Animation animation) {\n" + "              //动画重复时执行\n" + "          }\n" + " \n" + "         @Override\n" + "          public void onAnimationCancel()(Animation animation) {\n" + "              //动画取消时执行\n" + "          }\n" + "    \n" + "          @Override\n" + "          public void onAnimationEnd(Animation animation) {\n" + "              //动画结束时执行\n" + "          }\n" + "      });"
        const val type_evaluator_interpolator_diff = "估值器与插值器的区别"
        const val type_evaluator_interpolator_diff_answer = "估值器TypeEvalutor，设置动画如何从初始值过渡到结束值的逻辑，以及明确决定值的具体变化数值是多少\n" + "\n" + "插值器Interpolator，辅助动画的运动规律，决定值的变化模式（匀速、加速等）"
        const val lock_use = "lock的使用"
        const val lock_use_answer = "private Lock lock = new Lock();// 锁对象  \n" + "\n" + "1、lock.lock();// 线程输出方法\n" + "\n" + "2、lock.unlock();// 释放锁\n" + "\n" + "3、lock.tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；\n" + "\n" + "4、tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；"
        const val synchronized_use = "Synchronized的用法"
        const val synchronized_use_answer = "Synchronized的用法 ：\n" + "锁主要有三种\n" + "\n" + "类锁:像synchronized(class)或是锁静态方法，这种都是类锁，作用范围比较大，类的所有对象都会被作用到。\n" + "\n" + "第二种是对象锁，像普通方法锁就是，他的作用范围就是一个对象，不同线程不能同时执行一个对象的不同synchronized方法。\n" + "\n" + "还是就是同步代码块，synchronized（obj），这个的作用范围就是被作用的代码块上。"
        const val many_process_communication = "多进程的通信"
        const val many_process_communication_answer = "名称 优点 缺点 使用场景   \n" + "\n" + "Bundle 简单易用 只能传输Bundle支持的数据类型 四大组件的进程间通信\n" + "\n" + "AIDL 功能强大，支持一对多的并发通信，支持实时通信 使用较复杂，需要处理好线程同步 一对多通信且有RPC需求\n" + "\n" + "Messenger 功能一般，支持一对多的穿行通信，支持实时通信 不能很好处理并发现象，不支持RPC，只能传输Bundle支持的数据类型 低并发的一对多即时通信，无RPC需求\n" + "\n" + "ContentProvider 数据访问方面功能强大，支持一对多并发数据共享 受约束的AIDL，主要提供数据源的CRDU操作 一对多的进程间的数据共享\n" + "\n" + "文件共享 简单易用 不适合高并发场景，无法做到进程间的及时通信 没有并发的情形，交换简单的数据\n" + "\n" + "Socket 功能强大，可通过网络传输字节流，支持一对多的并发实时通信 繁琐，不支持直接的RPC 网络数据交换\n" + "\n" + "\n" + "RPC：Remote Procedure Call (远程过程调用) \n" + "IPC：Inter-Process Communication (进程间通信)\n" + "AIDL：Android Interface Definition Languag(Android接口定义语言)   "
        const val ok_http_principle = "OKHttp原理"
        const val ok_http_principle_answer = "execute()及enqueue()这两个方法会最终调用RealCall中的getResponseWithInterceptorChain()（重点）方法，从拦截器链中获取返回结果。而返回结果也会再经过上述拦截器依次处理，最后将结果给到调用方。\n" + "\n" + "主要是利用了责任链模式来实现各种拦截器的添加。是一种分层的思想，每一个Interceptor就是一层，每一层只关心这一层的责任，比如CallserverInterceptor,只关心与服务器连接，Cacheinterceptor只关心缓存的拦截就可以了。他把各种复杂的任务拆分成了一个一个具体独立的任务，对未来的扩展很有帮助。"
        const val ok_http_process = "OkHttp工作流程"
        const val ok_http_process_answer = "先创建 OkHttpClient 实例;\n" + "\n" + "构造 Request 实例，传入 url 等相关参数；\n" + "\n" + "通过前两步中的实例对象构建 Call 对象；\n" + "\n" + "异步请求通过 Call#enqueue(Callback) 方法来提交异步请求，同步请求通过 Call#execute() 直接获取 Reponse ;\n" + "\n" + "\n" + "String url = \"http://wwww.baidu.com\";\n" + "OkHttpClient okHttpClient = new OkHttpClient();\n" + "final Request request = new Request.Builder()\n" + "        .url(url)\n" + "        .get()//默认就是GET请求，可以不写\n" + "        .build();\n" + "Call call = okHttpClient.newCall(request);\n" + "call.enqueue(new Callback() {\n" + "    @Override\n" + "    public void onFailure(Call call, IOException e) {\n" + "        Log.d(TAG, \"onFailure: \");\n" + "    }\n" + "\n" + "    @Override\n" + "    public void onResponse(Call call, Response response) throws IOException {\n" + "        Log.d(TAG, \"onResponse: \" + response.body().string());\n" + "    }\n" + "});"
        const val glide_good_principle = "Glide优点与原理"
        const val glide_good_principle_answer = "glide最大的优势就是对bitmap的管理是跟随生命周期发生改变的。当Activity销毁的时候，之前加载的所有图片的内存都释放了。其它的框架基本都是用Lru算法，当Activity销毁的时候，是不会释放之前加载图片占用的所有内存。\n" + "\n" + "当我们用glide进行加载时，它创建一个无UI的Fragment，并绑定到通过glide.with(context)传进来的Activity上，这样Fragment就可以感知Activity的生命周期了。RequestManager是用来加载、管理图片请求的，它会通过传入的Lifecycle对象，监听到Fragment的生命周期，从而根据生命周期管理让Request做出相对应的处理了。"
        const val glide_cache = "Glide缓存"
        const val glide_cache_answer = "Glide的缓存有内存缓存，和磁盘缓存。其中内存缓存又分为Lru算法的缓存和弱引用缓存。\n" + "\n" + "\n" + "当我们的APP中想要加载某张图片时，先去LruCache中寻找图片，如果LruCache中有，则直接取出来使用，如果LruCache中没有，则去WeakReference中寻找\n" + "\n" + "如果WeakReference中有，则从WeakReference中取出图片使用，同时将图片重新放回到LruCache中，\n" + "\n" + "如果WeakReference中也没有图片，则去文件系统中寻找，如果有则取出来使用，同时将图片添加到LruCache中，\n" + "\n" + "如果没有，则连接网络从网上下载图片。图片下载完成后，将图片保存到文件系统中，然后放到LruCache中。"
        const val ok_http_usr_model = "OkHttp中的设计模式"
        const val ok_http_usr_model_answer = "责任链模式：拦截器链\n" + "\n" + "Builder模式：OkHttpClient的构建过程\n" + "\n" + "外观模式：OkHttpClient封装了很对类对象\n" + "\n" + "工厂模式：Socket的生产\n" + "\n" + "单例模式：线程池\n" + "\n" + "观察者模式：各种回调监听\n" + "\n" + "策略模式：缓存策略"
        const val ok_http_interceptor = "OkHttp拦截器"
        const val ok_http_interceptor_answer = "RetryAndFollowUpIntercepto\n" + "负责重试或请求重定向。\n" + "\n" + "BridgeInterceptor\n" + "对请求头以及返回结果处理。\n" + "\n" + "CacheInterceptor\n" + "负责读取缓存以及更新缓存。\n" + "\n" + "ConnectInterceptor\n" + "负责与服务器建立连接\n" + "\n" + "CallServerInterceptor\n" + "负责从服务器读取响应的数据\n" + "\n" + "\n" + "拦截链会调用proceed方法，用递归的方式来遍历整个拦截器列表，当拦截器集合不为空，一个个加进去，拦截器读取完了，再进行请求"
        const val retrofit_use = "retrofit的使用"
        const val retrofit_use_answer = "// 1、创建Retrofit实体类\n" + "Retrofit retrofit = new Retrofit.Builder()\n" + "    .baseUrl(\"https://api.github.com/\")\n" + "    .build();\n" + "\n" + "// 2、创建接口实现类\n" + "GitHubService service = retrofit.create(GitHubService.class);\n" + "\n" + "// 3、通过实现类得到Call实例\n" + "// https://api.github.com/users/octocat/repos\n" + "Call<List<Repo>> repos = service.listRepos(\"octocat\");\n" + "\n" + "// 4、Call发起同步/异步请求\n" + "/*同步请求\n" + "try {\n" + "    Response<List<Repo>> execute = repos.execute();\n" + "} catch (IOException e) {\n" + "    e.printStackTrace();\n" + "}\n" + "\n" + "5、通过数据转换器解析服务器返回的数据\n" + "*/\n" + "repos.enqueue(new Callback<List<Repo>>() {\n" + "    @Override  //6、通过回调执行器切换线程（子线程 ->>主线程）\n" + "    public void onResponse(Call<List<Repo>> call, Response<List<Repo>> response) {\n" + "\n" + "    }\n" + "\n" + "    @Override\n" + "    public void onFailure(Call<List<Repo>> call, Throwable t) {\n" + "\n" + "    }\n" + "});"
        const val retrofit_principle = "retrofit原理"
        const val retrofit_principle_answer ="Retrofit 通过 java 接口以及注解来描述网络请求，并用动态代理的方式生成网络请求的 request，\n" + "\n" + "然后通过 client 调用相应的网络框架（默认 okhttp）去发起网络请求，\n" + "\n" + "并将返回的 response 通过 converterFactorty 转换成相应的数据 model，\n" + "\n" + "最后通过 calladapter 转换成其他数据方式"
        const val retrofit_good = "retrofit优点"
        const val retrofit_good_answer = "超级解耦 ，接口定义、接口参数、接口回调不在耦合在一起\n" + "\n" + "可以配置不同的httpClient来实现网络请求，如okhttp、httpclient\n" + "\n" + "支持同步、异步、Rxjava\n" + "\n" + "可以配置不同反序列化工具类来解析不同的数据，如json、xml\n" + "\n" + "请求速度快，使用方便灵活简洁"
        const val dynamic_proxy_good = "动态代理的优点"
        const val dynamic_proxy_good_answer ="一个Java Interface是不可以直接创建一个对象的，动态代理所做的是在运行时生成一个实现了该Interface的类的Class对象。\n" + "\n" + "Retrofit使用动态代理，其实是为了开发者在写代码时方便调用，而真正负责生产Call网络工作对象的，还是Retrofit.create函数中定义的这个InvocationHandler。invoke方法是动态代理类处理的主要方法。\n" + "\n" + "说通俗点，就像你通过网络买东西，把需求制定好下单，就会有快递员帮你去购买跑腿，不需要你亲自动手一个道理。"
        const val modify_jar_class = "修改jar中class"
        const val modify_jar_class_answer = "1、新建一个工程，导入jar包到lib目录下(导入后可以看到类的信息)\n" + "\n" + "2、如果要修改上图中的DeviceUtil.class，在新建工程建立同样包名路径的DeviceUtil.java类，并且把DeviceUtil的内容复制过来\n" + "\n" + "3、修改完后，build工程就可以从构建物当中找出修改后DeviceUtil的class文件\n" + "\n" + "4、在Mac系统下，用以下\$ jar uvf path path命令替换掉原来jar中的class文件\n" + "\n" + "5、同理，aar包解压后修改jar包，用步骤4的方法替换掉原来的jar包"
        const val rely_on_repeat = "与SDK中的依赖重复"
        const val rely_on_repeat_answer = "可以使用gradle中的packagingOptions，常见的设置项有4种\n" + "\n" + "packagingOptions {\n" + "        ………\n" + "}\n" + "\n" + "1. exclude，过滤掉某些文件或者目录不添加到APK中，作用于APK，不能过滤aar和jar中的内容。\n" + "\n" + " exclude 'lib/arm64-v8a/libmediaplayer.so'\n" + "\n" + "2. pickFirst，匹配到多个相同文件，只提取第一个，作用于APK，不能过滤aar和jar中的文件。\n" + "\n" + "pickFirst \"lib/armeabi-v7a/libaaa.so\"\n" + "\n" + "3. doNotStrip，可以设置某些动态库不被优化压缩。\n" + "\n" + "doNotStrip \"*/armeabi/*.so\"\n" + "\n" + "4. merge，将匹配的文件都添加到APK中，和pickFirst有些相反，会合并所有文件。\n" + "\n" + "merge '**/LICENSE.txt'"
        const val r_x_java_1 = "RxJava的基础使用"
        const val r_x_java_1_answer = "Rxjava的特点，由于其基于事件流的链式调用、逻辑非常简洁，非常适合于复杂异步的问题处理\n\n\n   创建被观察者，产生事件\n" + "设置事件传递过程中的过滤，合并，变换等加工操作。\n" + "订阅一个观察者对象，实现事件最终的处理。\n" + "\n" + "Observable.create(new ObservableOnSubscribe<Integer>() {\n" + "\n" + "    @Override\n" + "    public void subscribe(@NonNull ObservableEmitter<Integer> emitter) throws Throwable {\n" + "        emitter.onNext(1);\n" + "        emitter.onNext(2);\n" + "        emitter.onNext(3);\n" + "        emitter.onComplete();\n" + "    }\n" + "}).subscribe(new Observer<Integer>() {\n" + "    @Override\n" + "    public void onSubscribe(@NonNull Disposable d) {\n" + "        Log.d(TAG, \"onSubscribe:\" + d.getClass().getName());\n" + "    }\n" + "\n" + "    @Override\n" + "    public void onNext(@NonNull Integer integer) {\n" + "        Log.d(TAG, \"onNext: \" + integer);\n" + "    }\n" + "\n" + "    @Override\n" + "    public void onError(@NonNull Throwable e) {\n" + "        Log.d(TAG, \"onError: \" + e.getMessage());\n" + "    }\n" + "\n" + "    @Override\n" + "    public void onComplete() {\n" + "        Log.d(TAG, \"onComplete\");\n" + "    }\n" + "});\n"
        const val r_x_java_2 = "RxJava线程切换"
        const val r_x_java_2_answer = "线程切换\n" + "\n" + "RxJava 默认，事件的发出和消费都是在同一个线程的。\u2028\n" + "在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）\n" + "\n" + "Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。默认 Scheduler。\n" + "Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n" + "Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler\n" + "Schedulers.computation(): 计算所使用的 Scheduler。\n" + "另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，\n" + "\n" + "Observable<String> observable = Observable.create(new ObservableOnSubscribe<String>() {\n" + "            @Override\n" + "            public void subscribe(ObservableEmitter<String> e) throws Exception {\n" + "               …\n" + "            }\n" + "        })\n" + "                .subscribeOn(Schedulers.io())\n" + "                .observeOn(AndroidSchedulers.mainThread());"
        const val r_x_java_3 = "RxJava - map与flatmap区别"
        const val r_x_java_3_answer = "map与flatmap区别\n" + "\n" + "结论：\n" + "\n" + "map适用于一对一转换\n" + "flatmap适用于一对多，多对多的场景\n" + "\n" + "区别：\n" + "\n" + "1、map是通过原始数据类型返回另外一种数据类型，而flatMap是通过原始数据类型返回另外一种被观察者。\n" + "\n" + "2、map被订阅时每传递一个事件执行一次onNext方法，flatmap多用于多对多，一对多，再被转化为多个时，一般利用from/just进行一一分发，被订阅时将所有数据传递完毕汇总到一个Observable然后一一执行onNext方法\n" + "\n" + "3、map只能一对一进行转换，flatmap既可以单一转换也可以一对多/多对多转换。flatMap并不保证数据有序。\n" + "\n" + "4、concatMap与flatMap使用基本一致，它可以保证数据有序\n" + "\n" + "相同点：\n" + "\n" + "1. 都是依赖FuncX(入参，返回值)进行转换（将一个类型依据程序逻辑转换成另一种类型，根据入参和返回值）\n" + "2. 都能在转换后直接被subscribe\n"
        const val r_x_java_4 = "RxJava相关问题"
        const val r_x_java_4_answer = "1、Observer处理完onComplete后会还能onNext吗?\n" + "\n" + "onComplete是用来控制不能发送数据的，也就是不能onNext了，包括onError也是不能再发送onNext数据了，该方法中也是调用了dispose方法\n" + "\n" + "\n" + "2、你还用过其他哪些操作符?\n" + "\n" + "关于其他的操作符比如merge、concat、zip都是合并，interval是周期执行，timer是延迟发送数据。\n" + "\n" + "\n" + "3、Maybe、Single、Flowable、Completable几种观察者的区别，以及他们在什么场景用？\n" + "\n" + "从上面各个对应的observer接口来看，如果只想发一条数据，或者不发数据就用Maybe，如果想法多条数据或者不发数据就用Observable，如果只发一条数据或者失败就用Single，如果想用背压策略使用Flowable，如果不发数据就用Completable。\t\t\n" + "\n" + "\n" + "4、RxJava的subscribeOn只有第一次生效?\n" + "\n" + "最开始调用的subscribeOn返回的observable会把后面执行的subscribeOn返回的observable给覆盖了，因此我们感官的是只有第一次的subscribeOn能生效。\n" + "\n" + "5、RxJava中背压是怎么回事？\n" + "\n" + "由于被观察者发送事件速度太快，而观察者来不及响应处理所有事件，从而导致事件丢失、OOM等异常。\n" + "\n" + "主要是通过Flowable类来实现的，Flowable其实就是被观察者（Observable）的一种新实现\n" + "\n" + "观察者通过Subscription.request获取事件, request决定了观察者能够接收多少个事件, 如设置了s.request(3)，这就说明观察者能够接收3个事件（多出的事件存放在缓存区）\n" + "\n" + "Flowable默认缓冲区的队列大小为128，即存储128个事件，超出会报错。\n"
        const val jet_pack = "介绍下JetPack"
        const val jet_pack_answer = "Jetpack是一套组件库，它提供了核心库、架构组件、UI组件、帮助我们在不同版本的机器上实现相同的功能代码，像常用的viewPager、fragment、recyclerview这些都是它提供的。\n" + "\n" + "核心库：有appcompat、core\n" + "架构组件：databinding、lifecyle\n" + "UI组件: constraintlayout、recyclerview\n" + "\n" + "其他还有些还有像车载、打印机等不常用的组件"
        const val async_task_use = "AsyncTask的使用"
        const val async_task_use_answer = "public class AsyncTaskTest extends AsyncTask<>{\n" + "\n" + "protected void onPreExecute() {…准备…}\n" + "\n" + "protected Long doInBackground(String... params) {…后台执行…}\n" + "\n" + "protected void onProgressUpdate(Object... values) {…更新中…}\n" + "\n" + " protected void onPostExecute(Long aLong) {…完成…}\n" + "\n" + "}\n" + "\n" + "然后在activity中调用 new AsyncTaskTest().execute()"
        const val async_task_principle = "AsyncTask原理"
        const val async_task_principle_answer = "内部是Handler和两个线程池实现的，Handler用于将线程切换到主线程，两个线程池一个用于任务的排队，一个用于执行任务\n" + "\n" + "当AsyncTask执行execute方法时会封装出一个FutureTask对象，将这个对象加入队列中，如果此时没有正在执行的任务，就执行它，执行完成之后继续执行队列中下一个任务，执行完成通过Handler将事件发送到主线程。\n" + "\n" + "AsyncTask必须在主线程初始化，因为内部的Handler是一个静态对象，在AsyncTask类加载的时候他就已经被初始化了。在Android3.0开始，execute方法串行执行任务的，一个一个来，3.0之前是并行执行的。如果要在3.0上执行并行任务，可以调用executeOnExecutor方法"
        const val async_task_fun = "AsyncTask提供的4个核心方法"
        const val async_task_fun_answer = "1、onPreExecute():该方法在主线程中执行，在执行异步任务之前会被调用，一般用于一些准备工作。\n" + " \n" + "2、doInBackground(String... params):这个方法是在线程池中执行，此方法用于执行异步任务。在这个方法中可以通过publishProgress方法来更新任务的进度，publishProgress方法会调用onProgressUpdate方法，另外，任务的结果返回给onPostExecute方法。\n" + " \n" + "3、onProgressUpdate(Object... values):该方法在主线程中执行，主要用于任务进度更新的时候，该方法会被调用。\n" + " \n" + "4、onPostExecute(Long aLong)：在主线程中执行，在异步任务执行完毕之后，该方法会被调用，该方法的参数及为后台的返回结果。"

    }
}

